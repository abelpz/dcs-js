/* tslint:disable */
/* eslint-disable */
/**
 * DCS (Gitea) API.
 * This documentation describes the DCS (Gitea) API.
 *
 * The version of the OpenAPI document: 1.17.3+dcs
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AddTimeOption } from '../models';
// @ts-ignore
import { Comment } from '../models';
// @ts-ignore
import { CreateIssueCommentOption } from '../models';
// @ts-ignore
import { CreateIssueOption } from '../models';
// @ts-ignore
import { CreateLabelOption } from '../models';
// @ts-ignore
import { CreateMilestoneOption } from '../models';
// @ts-ignore
import { EditDeadlineOption } from '../models';
// @ts-ignore
import { EditIssueCommentOption } from '../models';
// @ts-ignore
import { EditIssueOption } from '../models';
// @ts-ignore
import { EditLabelOption } from '../models';
// @ts-ignore
import { EditMilestoneOption } from '../models';
// @ts-ignore
import { EditReactionOption } from '../models';
// @ts-ignore
import { Issue } from '../models';
// @ts-ignore
import { IssueDeadline } from '../models';
// @ts-ignore
import { IssueLabelsOption } from '../models';
// @ts-ignore
import { Label } from '../models';
// @ts-ignore
import { Milestone } from '../models';
// @ts-ignore
import { Reaction } from '../models';
// @ts-ignore
import { TimelineComment } from '../models';
// @ts-ignore
import { TrackedTime } from '../models';
// @ts-ignore
import { User } from '../models';
// @ts-ignore
import { WatchInfo } from '../models';
/**
 * IssueApi - axios parameter creator
 * @export
 */
export const IssueApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a label to an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {IssueLabelsOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueAddLabel: async (owner: string, repo: string, index: number, body?: IssueLabelsOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueAddLabel', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueAddLabel', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueAddLabel', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/labels`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Subscribe user to issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} user user to subscribe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueAddSubscription: async (owner: string, repo: string, index: number, user: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueAddSubscription', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueAddSubscription', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueAddSubscription', 'index', index)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('issueAddSubscription', 'user', user)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/subscriptions/{user}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add tracked time to a issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {AddTimeOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueAddTime: async (owner: string, repo: string, index: number, body?: AddTimeOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueAddTime', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueAddTime', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueAddTime', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/times`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if user is subscribed to an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCheckSubscription: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueCheckSubscription', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueCheckSubscription', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueCheckSubscription', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/subscriptions/check`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove all labels from an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueClearLabels: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueClearLabels', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueClearLabels', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueClearLabels', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/labels`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a comment to an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {CreateIssueCommentOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateComment: async (owner: string, repo: string, index: number, body?: CreateIssueCommentOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueCreateComment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueCreateComment', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueCreateComment', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/comments`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an issue. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateIssueOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateIssue: async (owner: string, repo: string, body?: CreateIssueOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueCreateIssue', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueCreateIssue', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/issues`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a label
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateLabelOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateLabel: async (owner: string, repo: string, body?: CreateLabelOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueCreateLabel', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueCreateLabel', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/labels`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a milestone
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateMilestoneOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateMilestone: async (owner: string, repo: string, body?: CreateMilestoneOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueCreateMilestone', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueCreateMilestone', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/milestones`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of issue to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDelete: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueDelete', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueDelete', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueDelete', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of comment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteComment: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueDeleteComment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueDeleteComment', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueDeleteComment', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/issues/comments/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index this parameter is ignored
         * @param {number} id id of comment to delete
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        issueDeleteCommentDeprecated: async (owner: string, repo: string, index: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueDeleteCommentDeprecated', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueDeleteCommentDeprecated', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueDeleteCommentDeprecated', 'index', index)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueDeleteCommentDeprecated', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/comments/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a reaction from a comment of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment to edit
         * @param {EditReactionOption} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteCommentReaction: async (owner: string, repo: string, id: number, content?: EditReactionOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueDeleteCommentReaction', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueDeleteCommentReaction', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueDeleteCommentReaction', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/issues/comments/{id}/reactions`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(content, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a reaction from an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {EditReactionOption} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteIssueReaction: async (owner: string, repo: string, index: number, content?: EditReactionOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueDeleteIssueReaction', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueDeleteIssueReaction', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueDeleteIssueReaction', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/reactions`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(content, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a label
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the label to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteLabel: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueDeleteLabel', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueDeleteLabel', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueDeleteLabel', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/labels/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a milestone
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id the milestone to delete, identified by ID and if not available by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteMilestone: async (owner: string, repo: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueDeleteMilestone', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueDeleteMilestone', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueDeleteMilestone', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/milestones/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an issue\'s existing stopwatch.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to stop the stopwatch on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteStopWatch: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueDeleteStopWatch', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueDeleteStopWatch', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueDeleteStopWatch', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/stopwatch/delete`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unsubscribe user from issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} user user witch unsubscribe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteSubscription: async (owner: string, repo: string, index: number, user: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueDeleteSubscription', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueDeleteSubscription', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueDeleteSubscription', 'index', index)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('issueDeleteSubscription', 'user', user)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/subscriptions/{user}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete specific tracked time
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} id id of time to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteTime: async (owner: string, repo: string, index: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueDeleteTime', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueDeleteTime', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueDeleteTime', 'index', index)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueDeleteTime', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/times/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment to edit
         * @param {EditIssueCommentOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEditComment: async (owner: string, repo: string, id: number, body?: EditIssueCommentOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueEditComment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueEditComment', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueEditComment', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/issues/comments/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index this parameter is ignored
         * @param {number} id id of the comment to edit
         * @param {EditIssueCommentOption} [body] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        issueEditCommentDeprecated: async (owner: string, repo: string, index: number, id: number, body?: EditIssueCommentOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueEditCommentDeprecated', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueEditCommentDeprecated', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueEditCommentDeprecated', 'index', index)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueEditCommentDeprecated', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/comments/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit an issue. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to edit
         * @param {EditIssueOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEditIssue: async (owner: string, repo: string, index: number, body?: EditIssueOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueEditIssue', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueEditIssue', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueEditIssue', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set an issue deadline. If set to null, the deadline is deleted. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to create or update a deadline on
         * @param {EditDeadlineOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEditIssueDeadline: async (owner: string, repo: string, index: number, body?: EditDeadlineOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueEditIssueDeadline', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueEditIssueDeadline', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueEditIssueDeadline', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/deadline`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a label
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the label to edit
         * @param {EditLabelOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEditLabel: async (owner: string, repo: string, id: number, body?: EditLabelOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueEditLabel', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueEditLabel', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueEditLabel', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/labels/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a milestone
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id the milestone to edit, identified by ID and if not available by name
         * @param {EditMilestoneOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEditMilestone: async (owner: string, repo: string, id: string, body?: EditMilestoneOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueEditMilestone', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueEditMilestone', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueEditMilestone', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/milestones/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetComment: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueGetComment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueGetComment', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueGetComment', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/issues/comments/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of reactions from a comment of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment to edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetCommentReactions: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueGetCommentReactions', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueGetCommentReactions', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueGetCommentReactions', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/issues/comments/{id}/reactions`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all comments on an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} [since] if provided, only comments updated since the specified time are returned.
         * @param {string} [before] if provided, only comments updated before the provided time are returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetComments: async (owner: string, repo: string, index: number, since?: string, before?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueGetComments', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueGetComments', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueGetComments', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/comments`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any instanceof Date) ?
                    (since as any).toISOString() :
                    since;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any instanceof Date) ?
                    (before as any).toISOString() :
                    before;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all comments and events on an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} [since] if provided, only comments updated since the specified time are returned.
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {string} [before] if provided, only comments updated before the provided time are returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetCommentsAndTimeline: async (owner: string, repo: string, index: number, since?: string, page?: number, limit?: number, before?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueGetCommentsAndTimeline', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueGetCommentsAndTimeline', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueGetCommentsAndTimeline', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/timeline`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any instanceof Date) ?
                    (since as any).toISOString() :
                    since;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any instanceof Date) ?
                    (before as any).toISOString() :
                    before;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetIssue: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueGetIssue', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueGetIssue', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueGetIssue', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list reactions of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetIssueReactions: async (owner: string, repo: string, index: number, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueGetIssueReactions', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueGetIssueReactions', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueGetIssueReactions', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/reactions`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single label
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the label to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetLabel: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueGetLabel', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueGetLabel', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueGetLabel', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/labels/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an issue\'s labels
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetLabels: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueGetLabels', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueGetLabels', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueGetLabels', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/labels`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a milestone
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id the milestone to get, identified by ID and if not available by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetMilestone: async (owner: string, repo: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueGetMilestone', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueGetMilestone', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueGetMilestone', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/milestones/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all of a repository\'s opened milestones
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [state] Milestone state, Recognized values are open, closed and all. Defaults to \&quot;open\&quot;
         * @param {string} [name] filter by milestone name
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetMilestonesList: async (owner: string, repo: string, state?: string, name?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueGetMilestonesList', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueGetMilestonesList', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/milestones`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all comments in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [since] if provided, only comments updated since the provided time are returned.
         * @param {string} [before] if provided, only comments updated before the provided time are returned.
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetRepoComments: async (owner: string, repo: string, since?: string, before?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueGetRepoComments', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueGetRepoComments', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/issues/comments`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any instanceof Date) ?
                    (since as any).toISOString() :
                    since;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any instanceof Date) ?
                    (before as any).toISOString() :
                    before;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repository\'s issues
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {'closed' | 'open' | 'all'} [state] whether issue is open or closed
         * @param {string} [labels] comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded
         * @param {string} [q] search string
         * @param {'issues' | 'pulls'} [type] filter by type (issues / pulls) if set
         * @param {string} [milestones] comma separated list of milestone names or ids. It uses names and fall back to ids. Fetch only issues that have any of this milestones. Non existent milestones are discarded
         * @param {string} [since] Only show items updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show items updated before the given time. This is a timestamp in RFC 3339 format
         * @param {string} [createdBy] Only show items which were created by the the given user
         * @param {string} [assignedBy] Only show items for which the given user is assigned
         * @param {string} [mentionedBy] Only show items in which the given user was mentioned
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueListIssues: async (owner: string, repo: string, state?: 'closed' | 'open' | 'all', labels?: string, q?: string, type?: 'issues' | 'pulls', milestones?: string, since?: string, before?: string, createdBy?: string, assignedBy?: string, mentionedBy?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueListIssues', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueListIssues', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/issues`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (labels !== undefined) {
                localVarQueryParameter['labels'] = labels;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (milestones !== undefined) {
                localVarQueryParameter['milestones'] = milestones;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any instanceof Date) ?
                    (since as any).toISOString() :
                    since;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any instanceof Date) ?
                    (before as any).toISOString() :
                    before;
            }

            if (createdBy !== undefined) {
                localVarQueryParameter['created_by'] = createdBy;
            }

            if (assignedBy !== undefined) {
                localVarQueryParameter['assigned_by'] = assignedBy;
            }

            if (mentionedBy !== undefined) {
                localVarQueryParameter['mentioned_by'] = mentionedBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all of a repository\'s labels
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueListLabels: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueListLabels', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueListLabels', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/labels`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a reaction to a comment of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment to edit
         * @param {EditReactionOption} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuePostCommentReaction: async (owner: string, repo: string, id: number, content?: EditReactionOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issuePostCommentReaction', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issuePostCommentReaction', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issuePostCommentReaction', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/issues/comments/{id}/reactions`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(content, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a reaction to an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {EditReactionOption} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuePostIssueReaction: async (owner: string, repo: string, index: number, content?: EditReactionOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issuePostIssueReaction', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issuePostIssueReaction', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issuePostIssueReaction', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/reactions`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(content, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a label from an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} id id of the label to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueRemoveLabel: async (owner: string, repo: string, index: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueRemoveLabel', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueRemoveLabel', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueRemoveLabel', 'index', index)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueRemoveLabel', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/labels/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace an issue\'s labels
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {IssueLabelsOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueReplaceLabels: async (owner: string, repo: string, index: number, body?: IssueLabelsOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueReplaceLabels', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueReplaceLabels', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueReplaceLabels', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/labels`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset a tracked time of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to add tracked time to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueResetTime: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueResetTime', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueResetTime', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueResetTime', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/times`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for issues across the repositories that the user has access to
         * @param {string} [state] whether issue is open or closed
         * @param {string} [labels] comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded
         * @param {string} [milestones] comma separated list of milestone names. Fetch only issues that have any of this milestones. Non existent are discarded
         * @param {string} [q] search string
         * @param {number} [priorityRepoId] repository to prioritize in the results
         * @param {string} [type] filter by type (issues / pulls) if set
         * @param {string} [since] Only show notifications updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show notifications updated before the given time. This is a timestamp in RFC 3339 format
         * @param {boolean} [assigned] filter (issues / pulls) assigned to you, default is false
         * @param {boolean} [created] filter (issues / pulls) created by you, default is false
         * @param {boolean} [mentioned] filter (issues / pulls) mentioning you, default is false
         * @param {boolean} [reviewRequested] filter pulls requesting your review, default is false
         * @param {string} [owner] filter by owner
         * @param {string} [team] filter by team (requires organization owner parameter to be provided)
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueSearchIssues: async (state?: string, labels?: string, milestones?: string, q?: string, priorityRepoId?: number, type?: string, since?: string, before?: string, assigned?: boolean, created?: boolean, mentioned?: boolean, reviewRequested?: boolean, owner?: string, team?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/repos/issues/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (labels !== undefined) {
                localVarQueryParameter['labels'] = labels;
            }

            if (milestones !== undefined) {
                localVarQueryParameter['milestones'] = milestones;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (priorityRepoId !== undefined) {
                localVarQueryParameter['priority_repo_id'] = priorityRepoId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any instanceof Date) ?
                    (since as any).toISOString() :
                    since;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any instanceof Date) ?
                    (before as any).toISOString() :
                    before;
            }

            if (assigned !== undefined) {
                localVarQueryParameter['assigned'] = assigned;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (mentioned !== undefined) {
                localVarQueryParameter['mentioned'] = mentioned;
            }

            if (reviewRequested !== undefined) {
                localVarQueryParameter['review_requested'] = reviewRequested;
            }

            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }

            if (team !== undefined) {
                localVarQueryParameter['team'] = team;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start stopwatch on an issue.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to create the stopwatch on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueStartStopWatch: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueStartStopWatch', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueStartStopWatch', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueStartStopWatch', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/stopwatch/start`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop an issue\'s existing stopwatch.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to stop the stopwatch on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueStopStopWatch: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueStopStopWatch', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueStopStopWatch', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueStopStopWatch', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/stopwatch/stop`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get users who subscribed on an issue.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueSubscriptions: async (owner: string, repo: string, index: number, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueSubscriptions', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueSubscriptions', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueSubscriptions', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/subscriptions`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List an issue\'s tracked times
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} [user] optional filter by user (available for issue managers)
         * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueTrackedTimes: async (owner: string, repo: string, index: number, user?: string, since?: string, before?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueTrackedTimes', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueTrackedTimes', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueTrackedTimes', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/times`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any instanceof Date) ?
                    (since as any).toISOString() :
                    since;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any instanceof Date) ?
                    (before as any).toISOString() :
                    before;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IssueApi - functional programming interface
 * @export
 */
export const IssueApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IssueApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a label to an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {IssueLabelsOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueAddLabel(owner: string, repo: string, index: number, body?: IssueLabelsOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Label>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueAddLabel(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Subscribe user to issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} user user to subscribe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueAddSubscription(owner: string, repo: string, index: number, user: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueAddSubscription(owner, repo, index, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add tracked time to a issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {AddTimeOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueAddTime(owner: string, repo: string, index: number, body?: AddTimeOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackedTime>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueAddTime(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check if user is subscribed to an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueCheckSubscription(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueCheckSubscription(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove all labels from an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueClearLabels(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueClearLabels(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a comment to an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {CreateIssueCommentOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueCreateComment(owner: string, repo: string, index: number, body?: CreateIssueCommentOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueCreateComment(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create an issue. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateIssueOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueCreateIssue(owner: string, repo: string, body?: CreateIssueOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Issue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueCreateIssue(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a label
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateLabelOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueCreateLabel(owner: string, repo: string, body?: CreateLabelOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Label>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueCreateLabel(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a milestone
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateMilestoneOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueCreateMilestone(owner: string, repo: string, body?: CreateMilestoneOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Milestone>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueCreateMilestone(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of issue to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueDelete(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueDelete(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of comment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueDeleteComment(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueDeleteComment(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index this parameter is ignored
         * @param {number} id id of comment to delete
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async issueDeleteCommentDeprecated(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueDeleteCommentDeprecated(owner, repo, index, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a reaction from a comment of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment to edit
         * @param {EditReactionOption} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueDeleteCommentReaction(owner: string, repo: string, id: number, content?: EditReactionOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueDeleteCommentReaction(owner, repo, id, content, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a reaction from an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {EditReactionOption} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueDeleteIssueReaction(owner: string, repo: string, index: number, content?: EditReactionOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueDeleteIssueReaction(owner, repo, index, content, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a label
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the label to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueDeleteLabel(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueDeleteLabel(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a milestone
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id the milestone to delete, identified by ID and if not available by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueDeleteMilestone(owner: string, repo: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueDeleteMilestone(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an issue\'s existing stopwatch.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to stop the stopwatch on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueDeleteStopWatch(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueDeleteStopWatch(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unsubscribe user from issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} user user witch unsubscribe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueDeleteSubscription(owner: string, repo: string, index: number, user: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueDeleteSubscription(owner, repo, index, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete specific tracked time
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} id id of time to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueDeleteTime(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueDeleteTime(owner, repo, index, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment to edit
         * @param {EditIssueCommentOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueEditComment(owner: string, repo: string, id: number, body?: EditIssueCommentOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueEditComment(owner, repo, id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index this parameter is ignored
         * @param {number} id id of the comment to edit
         * @param {EditIssueCommentOption} [body] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async issueEditCommentDeprecated(owner: string, repo: string, index: number, id: number, body?: EditIssueCommentOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueEditCommentDeprecated(owner, repo, index, id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit an issue. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to edit
         * @param {EditIssueOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueEditIssue(owner: string, repo: string, index: number, body?: EditIssueOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Issue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueEditIssue(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set an issue deadline. If set to null, the deadline is deleted. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to create or update a deadline on
         * @param {EditDeadlineOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueEditIssueDeadline(owner: string, repo: string, index: number, body?: EditDeadlineOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IssueDeadline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueEditIssueDeadline(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a label
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the label to edit
         * @param {EditLabelOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueEditLabel(owner: string, repo: string, id: number, body?: EditLabelOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Label>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueEditLabel(owner, repo, id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a milestone
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id the milestone to edit, identified by ID and if not available by name
         * @param {EditMilestoneOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueEditMilestone(owner: string, repo: string, id: string, body?: EditMilestoneOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Milestone>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueEditMilestone(owner, repo, id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueGetComment(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueGetComment(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of reactions from a comment of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment to edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueGetCommentReactions(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Reaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueGetCommentReactions(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all comments on an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} [since] if provided, only comments updated since the specified time are returned.
         * @param {string} [before] if provided, only comments updated before the provided time are returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueGetComments(owner: string, repo: string, index: number, since?: string, before?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Comment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueGetComments(owner, repo, index, since, before, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all comments and events on an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} [since] if provided, only comments updated since the specified time are returned.
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {string} [before] if provided, only comments updated before the provided time are returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueGetCommentsAndTimeline(owner: string, repo: string, index: number, since?: string, page?: number, limit?: number, before?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TimelineComment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueGetCommentsAndTimeline(owner, repo, index, since, page, limit, before, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueGetIssue(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Issue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueGetIssue(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list reactions of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueGetIssueReactions(owner: string, repo: string, index: number, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Reaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueGetIssueReactions(owner, repo, index, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single label
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the label to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueGetLabel(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Label>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueGetLabel(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get an issue\'s labels
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueGetLabels(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Label>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueGetLabels(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a milestone
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id the milestone to get, identified by ID and if not available by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueGetMilestone(owner: string, repo: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Milestone>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueGetMilestone(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all of a repository\'s opened milestones
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [state] Milestone state, Recognized values are open, closed and all. Defaults to \&quot;open\&quot;
         * @param {string} [name] filter by milestone name
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueGetMilestonesList(owner: string, repo: string, state?: string, name?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Milestone>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueGetMilestonesList(owner, repo, state, name, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all comments in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [since] if provided, only comments updated since the provided time are returned.
         * @param {string} [before] if provided, only comments updated before the provided time are returned.
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueGetRepoComments(owner: string, repo: string, since?: string, before?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Comment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueGetRepoComments(owner, repo, since, before, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repository\'s issues
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {'closed' | 'open' | 'all'} [state] whether issue is open or closed
         * @param {string} [labels] comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded
         * @param {string} [q] search string
         * @param {'issues' | 'pulls'} [type] filter by type (issues / pulls) if set
         * @param {string} [milestones] comma separated list of milestone names or ids. It uses names and fall back to ids. Fetch only issues that have any of this milestones. Non existent milestones are discarded
         * @param {string} [since] Only show items updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show items updated before the given time. This is a timestamp in RFC 3339 format
         * @param {string} [createdBy] Only show items which were created by the the given user
         * @param {string} [assignedBy] Only show items for which the given user is assigned
         * @param {string} [mentionedBy] Only show items in which the given user was mentioned
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueListIssues(owner: string, repo: string, state?: 'closed' | 'open' | 'all', labels?: string, q?: string, type?: 'issues' | 'pulls', milestones?: string, since?: string, before?: string, createdBy?: string, assignedBy?: string, mentionedBy?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Issue>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueListIssues(owner, repo, state, labels, q, type, milestones, since, before, createdBy, assignedBy, mentionedBy, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all of a repository\'s labels
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueListLabels(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Label>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueListLabels(owner, repo, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a reaction to a comment of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment to edit
         * @param {EditReactionOption} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issuePostCommentReaction(owner: string, repo: string, id: number, content?: EditReactionOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issuePostCommentReaction(owner, repo, id, content, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a reaction to an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {EditReactionOption} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issuePostIssueReaction(owner: string, repo: string, index: number, content?: EditReactionOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issuePostIssueReaction(owner, repo, index, content, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a label from an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} id id of the label to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueRemoveLabel(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueRemoveLabel(owner, repo, index, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Replace an issue\'s labels
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {IssueLabelsOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueReplaceLabels(owner: string, repo: string, index: number, body?: IssueLabelsOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Label>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueReplaceLabels(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reset a tracked time of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to add tracked time to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueResetTime(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueResetTime(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search for issues across the repositories that the user has access to
         * @param {string} [state] whether issue is open or closed
         * @param {string} [labels] comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded
         * @param {string} [milestones] comma separated list of milestone names. Fetch only issues that have any of this milestones. Non existent are discarded
         * @param {string} [q] search string
         * @param {number} [priorityRepoId] repository to prioritize in the results
         * @param {string} [type] filter by type (issues / pulls) if set
         * @param {string} [since] Only show notifications updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show notifications updated before the given time. This is a timestamp in RFC 3339 format
         * @param {boolean} [assigned] filter (issues / pulls) assigned to you, default is false
         * @param {boolean} [created] filter (issues / pulls) created by you, default is false
         * @param {boolean} [mentioned] filter (issues / pulls) mentioning you, default is false
         * @param {boolean} [reviewRequested] filter pulls requesting your review, default is false
         * @param {string} [owner] filter by owner
         * @param {string} [team] filter by team (requires organization owner parameter to be provided)
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueSearchIssues(state?: string, labels?: string, milestones?: string, q?: string, priorityRepoId?: number, type?: string, since?: string, before?: string, assigned?: boolean, created?: boolean, mentioned?: boolean, reviewRequested?: boolean, owner?: string, team?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Issue>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueSearchIssues(state, labels, milestones, q, priorityRepoId, type, since, before, assigned, created, mentioned, reviewRequested, owner, team, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Start stopwatch on an issue.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to create the stopwatch on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueStartStopWatch(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueStartStopWatch(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Stop an issue\'s existing stopwatch.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to stop the stopwatch on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueStopStopWatch(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueStopStopWatch(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get users who subscribed on an issue.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueSubscriptions(owner: string, repo: string, index: number, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueSubscriptions(owner, repo, index, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List an issue\'s tracked times
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} [user] optional filter by user (available for issue managers)
         * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueTrackedTimes(owner: string, repo: string, index: number, user?: string, since?: string, before?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TrackedTime>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueTrackedTimes(owner, repo, index, user, since, before, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IssueApi - factory interface
 * @export
 */
export const IssueApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IssueApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a label to an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {IssueLabelsOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueAddLabel(owner: string, repo: string, index: number, body?: IssueLabelsOption, options?: any): AxiosPromise<Array<Label>> {
            return localVarFp.issueAddLabel(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Subscribe user to issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} user user to subscribe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueAddSubscription(owner: string, repo: string, index: number, user: string, options?: any): AxiosPromise<void> {
            return localVarFp.issueAddSubscription(owner, repo, index, user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add tracked time to a issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {AddTimeOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueAddTime(owner: string, repo: string, index: number, body?: AddTimeOption, options?: any): AxiosPromise<TrackedTime> {
            return localVarFp.issueAddTime(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if user is subscribed to an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCheckSubscription(owner: string, repo: string, index: number, options?: any): AxiosPromise<WatchInfo> {
            return localVarFp.issueCheckSubscription(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove all labels from an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueClearLabels(owner: string, repo: string, index: number, options?: any): AxiosPromise<void> {
            return localVarFp.issueClearLabels(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a comment to an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {CreateIssueCommentOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateComment(owner: string, repo: string, index: number, body?: CreateIssueCommentOption, options?: any): AxiosPromise<Comment> {
            return localVarFp.issueCreateComment(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an issue. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateIssueOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateIssue(owner: string, repo: string, body?: CreateIssueOption, options?: any): AxiosPromise<Issue> {
            return localVarFp.issueCreateIssue(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a label
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateLabelOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateLabel(owner: string, repo: string, body?: CreateLabelOption, options?: any): AxiosPromise<Label> {
            return localVarFp.issueCreateLabel(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a milestone
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateMilestoneOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateMilestone(owner: string, repo: string, body?: CreateMilestoneOption, options?: any): AxiosPromise<Milestone> {
            return localVarFp.issueCreateMilestone(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of issue to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDelete(owner: string, repo: string, index: number, options?: any): AxiosPromise<void> {
            return localVarFp.issueDelete(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of comment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteComment(owner: string, repo: string, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.issueDeleteComment(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index this parameter is ignored
         * @param {number} id id of comment to delete
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        issueDeleteCommentDeprecated(owner: string, repo: string, index: number, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.issueDeleteCommentDeprecated(owner, repo, index, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a reaction from a comment of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment to edit
         * @param {EditReactionOption} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteCommentReaction(owner: string, repo: string, id: number, content?: EditReactionOption, options?: any): AxiosPromise<void> {
            return localVarFp.issueDeleteCommentReaction(owner, repo, id, content, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a reaction from an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {EditReactionOption} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteIssueReaction(owner: string, repo: string, index: number, content?: EditReactionOption, options?: any): AxiosPromise<void> {
            return localVarFp.issueDeleteIssueReaction(owner, repo, index, content, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a label
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the label to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteLabel(owner: string, repo: string, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.issueDeleteLabel(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a milestone
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id the milestone to delete, identified by ID and if not available by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteMilestone(owner: string, repo: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.issueDeleteMilestone(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an issue\'s existing stopwatch.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to stop the stopwatch on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteStopWatch(owner: string, repo: string, index: number, options?: any): AxiosPromise<void> {
            return localVarFp.issueDeleteStopWatch(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unsubscribe user from issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} user user witch unsubscribe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteSubscription(owner: string, repo: string, index: number, user: string, options?: any): AxiosPromise<void> {
            return localVarFp.issueDeleteSubscription(owner, repo, index, user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete specific tracked time
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} id id of time to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteTime(owner: string, repo: string, index: number, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.issueDeleteTime(owner, repo, index, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment to edit
         * @param {EditIssueCommentOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEditComment(owner: string, repo: string, id: number, body?: EditIssueCommentOption, options?: any): AxiosPromise<Comment> {
            return localVarFp.issueEditComment(owner, repo, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index this parameter is ignored
         * @param {number} id id of the comment to edit
         * @param {EditIssueCommentOption} [body] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        issueEditCommentDeprecated(owner: string, repo: string, index: number, id: number, body?: EditIssueCommentOption, options?: any): AxiosPromise<Comment> {
            return localVarFp.issueEditCommentDeprecated(owner, repo, index, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit an issue. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to edit
         * @param {EditIssueOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEditIssue(owner: string, repo: string, index: number, body?: EditIssueOption, options?: any): AxiosPromise<Issue> {
            return localVarFp.issueEditIssue(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set an issue deadline. If set to null, the deadline is deleted. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to create or update a deadline on
         * @param {EditDeadlineOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEditIssueDeadline(owner: string, repo: string, index: number, body?: EditDeadlineOption, options?: any): AxiosPromise<IssueDeadline> {
            return localVarFp.issueEditIssueDeadline(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a label
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the label to edit
         * @param {EditLabelOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEditLabel(owner: string, repo: string, id: number, body?: EditLabelOption, options?: any): AxiosPromise<Label> {
            return localVarFp.issueEditLabel(owner, repo, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a milestone
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id the milestone to edit, identified by ID and if not available by name
         * @param {EditMilestoneOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEditMilestone(owner: string, repo: string, id: string, body?: EditMilestoneOption, options?: any): AxiosPromise<Milestone> {
            return localVarFp.issueEditMilestone(owner, repo, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetComment(owner: string, repo: string, id: number, options?: any): AxiosPromise<Comment> {
            return localVarFp.issueGetComment(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of reactions from a comment of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment to edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetCommentReactions(owner: string, repo: string, id: number, options?: any): AxiosPromise<Array<Reaction>> {
            return localVarFp.issueGetCommentReactions(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all comments on an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} [since] if provided, only comments updated since the specified time are returned.
         * @param {string} [before] if provided, only comments updated before the provided time are returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetComments(owner: string, repo: string, index: number, since?: string, before?: string, options?: any): AxiosPromise<Array<Comment>> {
            return localVarFp.issueGetComments(owner, repo, index, since, before, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all comments and events on an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} [since] if provided, only comments updated since the specified time are returned.
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {string} [before] if provided, only comments updated before the provided time are returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetCommentsAndTimeline(owner: string, repo: string, index: number, since?: string, page?: number, limit?: number, before?: string, options?: any): AxiosPromise<Array<TimelineComment>> {
            return localVarFp.issueGetCommentsAndTimeline(owner, repo, index, since, page, limit, before, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetIssue(owner: string, repo: string, index: number, options?: any): AxiosPromise<Issue> {
            return localVarFp.issueGetIssue(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list reactions of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetIssueReactions(owner: string, repo: string, index: number, page?: number, limit?: number, options?: any): AxiosPromise<Array<Reaction>> {
            return localVarFp.issueGetIssueReactions(owner, repo, index, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single label
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the label to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetLabel(owner: string, repo: string, id: number, options?: any): AxiosPromise<Label> {
            return localVarFp.issueGetLabel(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an issue\'s labels
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetLabels(owner: string, repo: string, index: number, options?: any): AxiosPromise<Array<Label>> {
            return localVarFp.issueGetLabels(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a milestone
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id the milestone to get, identified by ID and if not available by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetMilestone(owner: string, repo: string, id: string, options?: any): AxiosPromise<Milestone> {
            return localVarFp.issueGetMilestone(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all of a repository\'s opened milestones
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [state] Milestone state, Recognized values are open, closed and all. Defaults to \&quot;open\&quot;
         * @param {string} [name] filter by milestone name
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetMilestonesList(owner: string, repo: string, state?: string, name?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Milestone>> {
            return localVarFp.issueGetMilestonesList(owner, repo, state, name, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all comments in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [since] if provided, only comments updated since the provided time are returned.
         * @param {string} [before] if provided, only comments updated before the provided time are returned.
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetRepoComments(owner: string, repo: string, since?: string, before?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Comment>> {
            return localVarFp.issueGetRepoComments(owner, repo, since, before, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repository\'s issues
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {'closed' | 'open' | 'all'} [state] whether issue is open or closed
         * @param {string} [labels] comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded
         * @param {string} [q] search string
         * @param {'issues' | 'pulls'} [type] filter by type (issues / pulls) if set
         * @param {string} [milestones] comma separated list of milestone names or ids. It uses names and fall back to ids. Fetch only issues that have any of this milestones. Non existent milestones are discarded
         * @param {string} [since] Only show items updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show items updated before the given time. This is a timestamp in RFC 3339 format
         * @param {string} [createdBy] Only show items which were created by the the given user
         * @param {string} [assignedBy] Only show items for which the given user is assigned
         * @param {string} [mentionedBy] Only show items in which the given user was mentioned
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueListIssues(owner: string, repo: string, state?: 'closed' | 'open' | 'all', labels?: string, q?: string, type?: 'issues' | 'pulls', milestones?: string, since?: string, before?: string, createdBy?: string, assignedBy?: string, mentionedBy?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Issue>> {
            return localVarFp.issueListIssues(owner, repo, state, labels, q, type, milestones, since, before, createdBy, assignedBy, mentionedBy, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all of a repository\'s labels
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueListLabels(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Label>> {
            return localVarFp.issueListLabels(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a reaction to a comment of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment to edit
         * @param {EditReactionOption} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuePostCommentReaction(owner: string, repo: string, id: number, content?: EditReactionOption, options?: any): AxiosPromise<Reaction> {
            return localVarFp.issuePostCommentReaction(owner, repo, id, content, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a reaction to an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {EditReactionOption} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuePostIssueReaction(owner: string, repo: string, index: number, content?: EditReactionOption, options?: any): AxiosPromise<Reaction> {
            return localVarFp.issuePostIssueReaction(owner, repo, index, content, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a label from an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} id id of the label to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueRemoveLabel(owner: string, repo: string, index: number, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.issueRemoveLabel(owner, repo, index, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Replace an issue\'s labels
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {IssueLabelsOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueReplaceLabels(owner: string, repo: string, index: number, body?: IssueLabelsOption, options?: any): AxiosPromise<Array<Label>> {
            return localVarFp.issueReplaceLabels(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset a tracked time of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to add tracked time to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueResetTime(owner: string, repo: string, index: number, options?: any): AxiosPromise<void> {
            return localVarFp.issueResetTime(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for issues across the repositories that the user has access to
         * @param {string} [state] whether issue is open or closed
         * @param {string} [labels] comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded
         * @param {string} [milestones] comma separated list of milestone names. Fetch only issues that have any of this milestones. Non existent are discarded
         * @param {string} [q] search string
         * @param {number} [priorityRepoId] repository to prioritize in the results
         * @param {string} [type] filter by type (issues / pulls) if set
         * @param {string} [since] Only show notifications updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show notifications updated before the given time. This is a timestamp in RFC 3339 format
         * @param {boolean} [assigned] filter (issues / pulls) assigned to you, default is false
         * @param {boolean} [created] filter (issues / pulls) created by you, default is false
         * @param {boolean} [mentioned] filter (issues / pulls) mentioning you, default is false
         * @param {boolean} [reviewRequested] filter pulls requesting your review, default is false
         * @param {string} [owner] filter by owner
         * @param {string} [team] filter by team (requires organization owner parameter to be provided)
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueSearchIssues(state?: string, labels?: string, milestones?: string, q?: string, priorityRepoId?: number, type?: string, since?: string, before?: string, assigned?: boolean, created?: boolean, mentioned?: boolean, reviewRequested?: boolean, owner?: string, team?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Issue>> {
            return localVarFp.issueSearchIssues(state, labels, milestones, q, priorityRepoId, type, since, before, assigned, created, mentioned, reviewRequested, owner, team, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start stopwatch on an issue.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to create the stopwatch on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueStartStopWatch(owner: string, repo: string, index: number, options?: any): AxiosPromise<void> {
            return localVarFp.issueStartStopWatch(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop an issue\'s existing stopwatch.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to stop the stopwatch on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueStopStopWatch(owner: string, repo: string, index: number, options?: any): AxiosPromise<void> {
            return localVarFp.issueStopStopWatch(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get users who subscribed on an issue.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueSubscriptions(owner: string, repo: string, index: number, page?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.issueSubscriptions(owner, repo, index, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List an issue\'s tracked times
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} [user] optional filter by user (available for issue managers)
         * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueTrackedTimes(owner: string, repo: string, index: number, user?: string, since?: string, before?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<TrackedTime>> {
            return localVarFp.issueTrackedTimes(owner, repo, index, user, since, before, page, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for issueAddLabel operation in IssueApi.
 * @export
 * @interface IssueApiIssueAddLabelRequest
 */
export interface IssueApiIssueAddLabelRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueAddLabel
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueAddLabel
     */
    readonly repo: string

    /**
     * index of the issue
     * @type {number}
     * @memberof IssueApiIssueAddLabel
     */
    readonly index: number

    /**
     * 
     * @type {IssueLabelsOption}
     * @memberof IssueApiIssueAddLabel
     */
    readonly body?: IssueLabelsOption
}

/**
 * Request parameters for issueAddSubscription operation in IssueApi.
 * @export
 * @interface IssueApiIssueAddSubscriptionRequest
 */
export interface IssueApiIssueAddSubscriptionRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueAddSubscription
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueAddSubscription
     */
    readonly repo: string

    /**
     * index of the issue
     * @type {number}
     * @memberof IssueApiIssueAddSubscription
     */
    readonly index: number

    /**
     * user to subscribe
     * @type {string}
     * @memberof IssueApiIssueAddSubscription
     */
    readonly user: string
}

/**
 * Request parameters for issueAddTime operation in IssueApi.
 * @export
 * @interface IssueApiIssueAddTimeRequest
 */
export interface IssueApiIssueAddTimeRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueAddTime
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueAddTime
     */
    readonly repo: string

    /**
     * index of the issue
     * @type {number}
     * @memberof IssueApiIssueAddTime
     */
    readonly index: number

    /**
     * 
     * @type {AddTimeOption}
     * @memberof IssueApiIssueAddTime
     */
    readonly body?: AddTimeOption
}

/**
 * Request parameters for issueCheckSubscription operation in IssueApi.
 * @export
 * @interface IssueApiIssueCheckSubscriptionRequest
 */
export interface IssueApiIssueCheckSubscriptionRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueCheckSubscription
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueCheckSubscription
     */
    readonly repo: string

    /**
     * index of the issue
     * @type {number}
     * @memberof IssueApiIssueCheckSubscription
     */
    readonly index: number
}

/**
 * Request parameters for issueClearLabels operation in IssueApi.
 * @export
 * @interface IssueApiIssueClearLabelsRequest
 */
export interface IssueApiIssueClearLabelsRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueClearLabels
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueClearLabels
     */
    readonly repo: string

    /**
     * index of the issue
     * @type {number}
     * @memberof IssueApiIssueClearLabels
     */
    readonly index: number
}

/**
 * Request parameters for issueCreateComment operation in IssueApi.
 * @export
 * @interface IssueApiIssueCreateCommentRequest
 */
export interface IssueApiIssueCreateCommentRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueCreateComment
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueCreateComment
     */
    readonly repo: string

    /**
     * index of the issue
     * @type {number}
     * @memberof IssueApiIssueCreateComment
     */
    readonly index: number

    /**
     * 
     * @type {CreateIssueCommentOption}
     * @memberof IssueApiIssueCreateComment
     */
    readonly body?: CreateIssueCommentOption
}

/**
 * Request parameters for issueCreateIssue operation in IssueApi.
 * @export
 * @interface IssueApiIssueCreateIssueRequest
 */
export interface IssueApiIssueCreateIssueRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueCreateIssue
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueCreateIssue
     */
    readonly repo: string

    /**
     * 
     * @type {CreateIssueOption}
     * @memberof IssueApiIssueCreateIssue
     */
    readonly body?: CreateIssueOption
}

/**
 * Request parameters for issueCreateLabel operation in IssueApi.
 * @export
 * @interface IssueApiIssueCreateLabelRequest
 */
export interface IssueApiIssueCreateLabelRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueCreateLabel
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueCreateLabel
     */
    readonly repo: string

    /**
     * 
     * @type {CreateLabelOption}
     * @memberof IssueApiIssueCreateLabel
     */
    readonly body?: CreateLabelOption
}

/**
 * Request parameters for issueCreateMilestone operation in IssueApi.
 * @export
 * @interface IssueApiIssueCreateMilestoneRequest
 */
export interface IssueApiIssueCreateMilestoneRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueCreateMilestone
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueCreateMilestone
     */
    readonly repo: string

    /**
     * 
     * @type {CreateMilestoneOption}
     * @memberof IssueApiIssueCreateMilestone
     */
    readonly body?: CreateMilestoneOption
}

/**
 * Request parameters for issueDelete operation in IssueApi.
 * @export
 * @interface IssueApiIssueDeleteRequest
 */
export interface IssueApiIssueDeleteRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueDelete
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueDelete
     */
    readonly repo: string

    /**
     * index of issue to delete
     * @type {number}
     * @memberof IssueApiIssueDelete
     */
    readonly index: number
}

/**
 * Request parameters for issueDeleteComment operation in IssueApi.
 * @export
 * @interface IssueApiIssueDeleteCommentRequest
 */
export interface IssueApiIssueDeleteCommentRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueDeleteComment
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueDeleteComment
     */
    readonly repo: string

    /**
     * id of comment to delete
     * @type {number}
     * @memberof IssueApiIssueDeleteComment
     */
    readonly id: number
}

/**
 * Request parameters for issueDeleteCommentDeprecated operation in IssueApi.
 * @export
 * @interface IssueApiIssueDeleteCommentDeprecatedRequest
 */
export interface IssueApiIssueDeleteCommentDeprecatedRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueDeleteCommentDeprecated
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueDeleteCommentDeprecated
     */
    readonly repo: string

    /**
     * this parameter is ignored
     * @type {number}
     * @memberof IssueApiIssueDeleteCommentDeprecated
     */
    readonly index: number

    /**
     * id of comment to delete
     * @type {number}
     * @memberof IssueApiIssueDeleteCommentDeprecated
     */
    readonly id: number
}

/**
 * Request parameters for issueDeleteCommentReaction operation in IssueApi.
 * @export
 * @interface IssueApiIssueDeleteCommentReactionRequest
 */
export interface IssueApiIssueDeleteCommentReactionRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueDeleteCommentReaction
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueDeleteCommentReaction
     */
    readonly repo: string

    /**
     * id of the comment to edit
     * @type {number}
     * @memberof IssueApiIssueDeleteCommentReaction
     */
    readonly id: number

    /**
     * 
     * @type {EditReactionOption}
     * @memberof IssueApiIssueDeleteCommentReaction
     */
    readonly content?: EditReactionOption
}

/**
 * Request parameters for issueDeleteIssueReaction operation in IssueApi.
 * @export
 * @interface IssueApiIssueDeleteIssueReactionRequest
 */
export interface IssueApiIssueDeleteIssueReactionRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueDeleteIssueReaction
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueDeleteIssueReaction
     */
    readonly repo: string

    /**
     * index of the issue
     * @type {number}
     * @memberof IssueApiIssueDeleteIssueReaction
     */
    readonly index: number

    /**
     * 
     * @type {EditReactionOption}
     * @memberof IssueApiIssueDeleteIssueReaction
     */
    readonly content?: EditReactionOption
}

/**
 * Request parameters for issueDeleteLabel operation in IssueApi.
 * @export
 * @interface IssueApiIssueDeleteLabelRequest
 */
export interface IssueApiIssueDeleteLabelRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueDeleteLabel
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueDeleteLabel
     */
    readonly repo: string

    /**
     * id of the label to delete
     * @type {number}
     * @memberof IssueApiIssueDeleteLabel
     */
    readonly id: number
}

/**
 * Request parameters for issueDeleteMilestone operation in IssueApi.
 * @export
 * @interface IssueApiIssueDeleteMilestoneRequest
 */
export interface IssueApiIssueDeleteMilestoneRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueDeleteMilestone
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueDeleteMilestone
     */
    readonly repo: string

    /**
     * the milestone to delete, identified by ID and if not available by name
     * @type {string}
     * @memberof IssueApiIssueDeleteMilestone
     */
    readonly id: string
}

/**
 * Request parameters for issueDeleteStopWatch operation in IssueApi.
 * @export
 * @interface IssueApiIssueDeleteStopWatchRequest
 */
export interface IssueApiIssueDeleteStopWatchRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueDeleteStopWatch
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueDeleteStopWatch
     */
    readonly repo: string

    /**
     * index of the issue to stop the stopwatch on
     * @type {number}
     * @memberof IssueApiIssueDeleteStopWatch
     */
    readonly index: number
}

/**
 * Request parameters for issueDeleteSubscription operation in IssueApi.
 * @export
 * @interface IssueApiIssueDeleteSubscriptionRequest
 */
export interface IssueApiIssueDeleteSubscriptionRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueDeleteSubscription
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueDeleteSubscription
     */
    readonly repo: string

    /**
     * index of the issue
     * @type {number}
     * @memberof IssueApiIssueDeleteSubscription
     */
    readonly index: number

    /**
     * user witch unsubscribe
     * @type {string}
     * @memberof IssueApiIssueDeleteSubscription
     */
    readonly user: string
}

/**
 * Request parameters for issueDeleteTime operation in IssueApi.
 * @export
 * @interface IssueApiIssueDeleteTimeRequest
 */
export interface IssueApiIssueDeleteTimeRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueDeleteTime
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueDeleteTime
     */
    readonly repo: string

    /**
     * index of the issue
     * @type {number}
     * @memberof IssueApiIssueDeleteTime
     */
    readonly index: number

    /**
     * id of time to delete
     * @type {number}
     * @memberof IssueApiIssueDeleteTime
     */
    readonly id: number
}

/**
 * Request parameters for issueEditComment operation in IssueApi.
 * @export
 * @interface IssueApiIssueEditCommentRequest
 */
export interface IssueApiIssueEditCommentRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueEditComment
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueEditComment
     */
    readonly repo: string

    /**
     * id of the comment to edit
     * @type {number}
     * @memberof IssueApiIssueEditComment
     */
    readonly id: number

    /**
     * 
     * @type {EditIssueCommentOption}
     * @memberof IssueApiIssueEditComment
     */
    readonly body?: EditIssueCommentOption
}

/**
 * Request parameters for issueEditCommentDeprecated operation in IssueApi.
 * @export
 * @interface IssueApiIssueEditCommentDeprecatedRequest
 */
export interface IssueApiIssueEditCommentDeprecatedRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueEditCommentDeprecated
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueEditCommentDeprecated
     */
    readonly repo: string

    /**
     * this parameter is ignored
     * @type {number}
     * @memberof IssueApiIssueEditCommentDeprecated
     */
    readonly index: number

    /**
     * id of the comment to edit
     * @type {number}
     * @memberof IssueApiIssueEditCommentDeprecated
     */
    readonly id: number

    /**
     * 
     * @type {EditIssueCommentOption}
     * @memberof IssueApiIssueEditCommentDeprecated
     */
    readonly body?: EditIssueCommentOption
}

/**
 * Request parameters for issueEditIssue operation in IssueApi.
 * @export
 * @interface IssueApiIssueEditIssueRequest
 */
export interface IssueApiIssueEditIssueRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueEditIssue
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueEditIssue
     */
    readonly repo: string

    /**
     * index of the issue to edit
     * @type {number}
     * @memberof IssueApiIssueEditIssue
     */
    readonly index: number

    /**
     * 
     * @type {EditIssueOption}
     * @memberof IssueApiIssueEditIssue
     */
    readonly body?: EditIssueOption
}

/**
 * Request parameters for issueEditIssueDeadline operation in IssueApi.
 * @export
 * @interface IssueApiIssueEditIssueDeadlineRequest
 */
export interface IssueApiIssueEditIssueDeadlineRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueEditIssueDeadline
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueEditIssueDeadline
     */
    readonly repo: string

    /**
     * index of the issue to create or update a deadline on
     * @type {number}
     * @memberof IssueApiIssueEditIssueDeadline
     */
    readonly index: number

    /**
     * 
     * @type {EditDeadlineOption}
     * @memberof IssueApiIssueEditIssueDeadline
     */
    readonly body?: EditDeadlineOption
}

/**
 * Request parameters for issueEditLabel operation in IssueApi.
 * @export
 * @interface IssueApiIssueEditLabelRequest
 */
export interface IssueApiIssueEditLabelRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueEditLabel
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueEditLabel
     */
    readonly repo: string

    /**
     * id of the label to edit
     * @type {number}
     * @memberof IssueApiIssueEditLabel
     */
    readonly id: number

    /**
     * 
     * @type {EditLabelOption}
     * @memberof IssueApiIssueEditLabel
     */
    readonly body?: EditLabelOption
}

/**
 * Request parameters for issueEditMilestone operation in IssueApi.
 * @export
 * @interface IssueApiIssueEditMilestoneRequest
 */
export interface IssueApiIssueEditMilestoneRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueEditMilestone
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueEditMilestone
     */
    readonly repo: string

    /**
     * the milestone to edit, identified by ID and if not available by name
     * @type {string}
     * @memberof IssueApiIssueEditMilestone
     */
    readonly id: string

    /**
     * 
     * @type {EditMilestoneOption}
     * @memberof IssueApiIssueEditMilestone
     */
    readonly body?: EditMilestoneOption
}

/**
 * Request parameters for issueGetComment operation in IssueApi.
 * @export
 * @interface IssueApiIssueGetCommentRequest
 */
export interface IssueApiIssueGetCommentRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueGetComment
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueGetComment
     */
    readonly repo: string

    /**
     * id of the comment
     * @type {number}
     * @memberof IssueApiIssueGetComment
     */
    readonly id: number
}

/**
 * Request parameters for issueGetCommentReactions operation in IssueApi.
 * @export
 * @interface IssueApiIssueGetCommentReactionsRequest
 */
export interface IssueApiIssueGetCommentReactionsRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueGetCommentReactions
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueGetCommentReactions
     */
    readonly repo: string

    /**
     * id of the comment to edit
     * @type {number}
     * @memberof IssueApiIssueGetCommentReactions
     */
    readonly id: number
}

/**
 * Request parameters for issueGetComments operation in IssueApi.
 * @export
 * @interface IssueApiIssueGetCommentsRequest
 */
export interface IssueApiIssueGetCommentsRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueGetComments
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueGetComments
     */
    readonly repo: string

    /**
     * index of the issue
     * @type {number}
     * @memberof IssueApiIssueGetComments
     */
    readonly index: number

    /**
     * if provided, only comments updated since the specified time are returned.
     * @type {string}
     * @memberof IssueApiIssueGetComments
     */
    readonly since?: string

    /**
     * if provided, only comments updated before the provided time are returned.
     * @type {string}
     * @memberof IssueApiIssueGetComments
     */
    readonly before?: string
}

/**
 * Request parameters for issueGetCommentsAndTimeline operation in IssueApi.
 * @export
 * @interface IssueApiIssueGetCommentsAndTimelineRequest
 */
export interface IssueApiIssueGetCommentsAndTimelineRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueGetCommentsAndTimeline
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueGetCommentsAndTimeline
     */
    readonly repo: string

    /**
     * index of the issue
     * @type {number}
     * @memberof IssueApiIssueGetCommentsAndTimeline
     */
    readonly index: number

    /**
     * if provided, only comments updated since the specified time are returned.
     * @type {string}
     * @memberof IssueApiIssueGetCommentsAndTimeline
     */
    readonly since?: string

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof IssueApiIssueGetCommentsAndTimeline
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof IssueApiIssueGetCommentsAndTimeline
     */
    readonly limit?: number

    /**
     * if provided, only comments updated before the provided time are returned.
     * @type {string}
     * @memberof IssueApiIssueGetCommentsAndTimeline
     */
    readonly before?: string
}

/**
 * Request parameters for issueGetIssue operation in IssueApi.
 * @export
 * @interface IssueApiIssueGetIssueRequest
 */
export interface IssueApiIssueGetIssueRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueGetIssue
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueGetIssue
     */
    readonly repo: string

    /**
     * index of the issue to get
     * @type {number}
     * @memberof IssueApiIssueGetIssue
     */
    readonly index: number
}

/**
 * Request parameters for issueGetIssueReactions operation in IssueApi.
 * @export
 * @interface IssueApiIssueGetIssueReactionsRequest
 */
export interface IssueApiIssueGetIssueReactionsRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueGetIssueReactions
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueGetIssueReactions
     */
    readonly repo: string

    /**
     * index of the issue
     * @type {number}
     * @memberof IssueApiIssueGetIssueReactions
     */
    readonly index: number

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof IssueApiIssueGetIssueReactions
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof IssueApiIssueGetIssueReactions
     */
    readonly limit?: number
}

/**
 * Request parameters for issueGetLabel operation in IssueApi.
 * @export
 * @interface IssueApiIssueGetLabelRequest
 */
export interface IssueApiIssueGetLabelRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueGetLabel
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueGetLabel
     */
    readonly repo: string

    /**
     * id of the label to get
     * @type {number}
     * @memberof IssueApiIssueGetLabel
     */
    readonly id: number
}

/**
 * Request parameters for issueGetLabels operation in IssueApi.
 * @export
 * @interface IssueApiIssueGetLabelsRequest
 */
export interface IssueApiIssueGetLabelsRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueGetLabels
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueGetLabels
     */
    readonly repo: string

    /**
     * index of the issue
     * @type {number}
     * @memberof IssueApiIssueGetLabels
     */
    readonly index: number
}

/**
 * Request parameters for issueGetMilestone operation in IssueApi.
 * @export
 * @interface IssueApiIssueGetMilestoneRequest
 */
export interface IssueApiIssueGetMilestoneRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueGetMilestone
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueGetMilestone
     */
    readonly repo: string

    /**
     * the milestone to get, identified by ID and if not available by name
     * @type {string}
     * @memberof IssueApiIssueGetMilestone
     */
    readonly id: string
}

/**
 * Request parameters for issueGetMilestonesList operation in IssueApi.
 * @export
 * @interface IssueApiIssueGetMilestonesListRequest
 */
export interface IssueApiIssueGetMilestonesListRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueGetMilestonesList
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueGetMilestonesList
     */
    readonly repo: string

    /**
     * Milestone state, Recognized values are open, closed and all. Defaults to \&quot;open\&quot;
     * @type {string}
     * @memberof IssueApiIssueGetMilestonesList
     */
    readonly state?: string

    /**
     * filter by milestone name
     * @type {string}
     * @memberof IssueApiIssueGetMilestonesList
     */
    readonly name?: string

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof IssueApiIssueGetMilestonesList
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof IssueApiIssueGetMilestonesList
     */
    readonly limit?: number
}

/**
 * Request parameters for issueGetRepoComments operation in IssueApi.
 * @export
 * @interface IssueApiIssueGetRepoCommentsRequest
 */
export interface IssueApiIssueGetRepoCommentsRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueGetRepoComments
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueGetRepoComments
     */
    readonly repo: string

    /**
     * if provided, only comments updated since the provided time are returned.
     * @type {string}
     * @memberof IssueApiIssueGetRepoComments
     */
    readonly since?: string

    /**
     * if provided, only comments updated before the provided time are returned.
     * @type {string}
     * @memberof IssueApiIssueGetRepoComments
     */
    readonly before?: string

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof IssueApiIssueGetRepoComments
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof IssueApiIssueGetRepoComments
     */
    readonly limit?: number
}

/**
 * Request parameters for issueListIssues operation in IssueApi.
 * @export
 * @interface IssueApiIssueListIssuesRequest
 */
export interface IssueApiIssueListIssuesRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueListIssues
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueListIssues
     */
    readonly repo: string

    /**
     * whether issue is open or closed
     * @type {'closed' | 'open' | 'all'}
     * @memberof IssueApiIssueListIssues
     */
    readonly state?: 'closed' | 'open' | 'all'

    /**
     * comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded
     * @type {string}
     * @memberof IssueApiIssueListIssues
     */
    readonly labels?: string

    /**
     * search string
     * @type {string}
     * @memberof IssueApiIssueListIssues
     */
    readonly q?: string

    /**
     * filter by type (issues / pulls) if set
     * @type {'issues' | 'pulls'}
     * @memberof IssueApiIssueListIssues
     */
    readonly type?: 'issues' | 'pulls'

    /**
     * comma separated list of milestone names or ids. It uses names and fall back to ids. Fetch only issues that have any of this milestones. Non existent milestones are discarded
     * @type {string}
     * @memberof IssueApiIssueListIssues
     */
    readonly milestones?: string

    /**
     * Only show items updated after the given time. This is a timestamp in RFC 3339 format
     * @type {string}
     * @memberof IssueApiIssueListIssues
     */
    readonly since?: string

    /**
     * Only show items updated before the given time. This is a timestamp in RFC 3339 format
     * @type {string}
     * @memberof IssueApiIssueListIssues
     */
    readonly before?: string

    /**
     * Only show items which were created by the the given user
     * @type {string}
     * @memberof IssueApiIssueListIssues
     */
    readonly createdBy?: string

    /**
     * Only show items for which the given user is assigned
     * @type {string}
     * @memberof IssueApiIssueListIssues
     */
    readonly assignedBy?: string

    /**
     * Only show items in which the given user was mentioned
     * @type {string}
     * @memberof IssueApiIssueListIssues
     */
    readonly mentionedBy?: string

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof IssueApiIssueListIssues
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof IssueApiIssueListIssues
     */
    readonly limit?: number
}

/**
 * Request parameters for issueListLabels operation in IssueApi.
 * @export
 * @interface IssueApiIssueListLabelsRequest
 */
export interface IssueApiIssueListLabelsRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueListLabels
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueListLabels
     */
    readonly repo: string

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof IssueApiIssueListLabels
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof IssueApiIssueListLabels
     */
    readonly limit?: number
}

/**
 * Request parameters for issuePostCommentReaction operation in IssueApi.
 * @export
 * @interface IssueApiIssuePostCommentReactionRequest
 */
export interface IssueApiIssuePostCommentReactionRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssuePostCommentReaction
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssuePostCommentReaction
     */
    readonly repo: string

    /**
     * id of the comment to edit
     * @type {number}
     * @memberof IssueApiIssuePostCommentReaction
     */
    readonly id: number

    /**
     * 
     * @type {EditReactionOption}
     * @memberof IssueApiIssuePostCommentReaction
     */
    readonly content?: EditReactionOption
}

/**
 * Request parameters for issuePostIssueReaction operation in IssueApi.
 * @export
 * @interface IssueApiIssuePostIssueReactionRequest
 */
export interface IssueApiIssuePostIssueReactionRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssuePostIssueReaction
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssuePostIssueReaction
     */
    readonly repo: string

    /**
     * index of the issue
     * @type {number}
     * @memberof IssueApiIssuePostIssueReaction
     */
    readonly index: number

    /**
     * 
     * @type {EditReactionOption}
     * @memberof IssueApiIssuePostIssueReaction
     */
    readonly content?: EditReactionOption
}

/**
 * Request parameters for issueRemoveLabel operation in IssueApi.
 * @export
 * @interface IssueApiIssueRemoveLabelRequest
 */
export interface IssueApiIssueRemoveLabelRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueRemoveLabel
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueRemoveLabel
     */
    readonly repo: string

    /**
     * index of the issue
     * @type {number}
     * @memberof IssueApiIssueRemoveLabel
     */
    readonly index: number

    /**
     * id of the label to remove
     * @type {number}
     * @memberof IssueApiIssueRemoveLabel
     */
    readonly id: number
}

/**
 * Request parameters for issueReplaceLabels operation in IssueApi.
 * @export
 * @interface IssueApiIssueReplaceLabelsRequest
 */
export interface IssueApiIssueReplaceLabelsRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueReplaceLabels
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueReplaceLabels
     */
    readonly repo: string

    /**
     * index of the issue
     * @type {number}
     * @memberof IssueApiIssueReplaceLabels
     */
    readonly index: number

    /**
     * 
     * @type {IssueLabelsOption}
     * @memberof IssueApiIssueReplaceLabels
     */
    readonly body?: IssueLabelsOption
}

/**
 * Request parameters for issueResetTime operation in IssueApi.
 * @export
 * @interface IssueApiIssueResetTimeRequest
 */
export interface IssueApiIssueResetTimeRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueResetTime
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueResetTime
     */
    readonly repo: string

    /**
     * index of the issue to add tracked time to
     * @type {number}
     * @memberof IssueApiIssueResetTime
     */
    readonly index: number
}

/**
 * Request parameters for issueSearchIssues operation in IssueApi.
 * @export
 * @interface IssueApiIssueSearchIssuesRequest
 */
export interface IssueApiIssueSearchIssuesRequest {
    /**
     * whether issue is open or closed
     * @type {string}
     * @memberof IssueApiIssueSearchIssues
     */
    readonly state?: string

    /**
     * comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded
     * @type {string}
     * @memberof IssueApiIssueSearchIssues
     */
    readonly labels?: string

    /**
     * comma separated list of milestone names. Fetch only issues that have any of this milestones. Non existent are discarded
     * @type {string}
     * @memberof IssueApiIssueSearchIssues
     */
    readonly milestones?: string

    /**
     * search string
     * @type {string}
     * @memberof IssueApiIssueSearchIssues
     */
    readonly q?: string

    /**
     * repository to prioritize in the results
     * @type {number}
     * @memberof IssueApiIssueSearchIssues
     */
    readonly priorityRepoId?: number

    /**
     * filter by type (issues / pulls) if set
     * @type {string}
     * @memberof IssueApiIssueSearchIssues
     */
    readonly type?: string

    /**
     * Only show notifications updated after the given time. This is a timestamp in RFC 3339 format
     * @type {string}
     * @memberof IssueApiIssueSearchIssues
     */
    readonly since?: string

    /**
     * Only show notifications updated before the given time. This is a timestamp in RFC 3339 format
     * @type {string}
     * @memberof IssueApiIssueSearchIssues
     */
    readonly before?: string

    /**
     * filter (issues / pulls) assigned to you, default is false
     * @type {boolean}
     * @memberof IssueApiIssueSearchIssues
     */
    readonly assigned?: boolean

    /**
     * filter (issues / pulls) created by you, default is false
     * @type {boolean}
     * @memberof IssueApiIssueSearchIssues
     */
    readonly created?: boolean

    /**
     * filter (issues / pulls) mentioning you, default is false
     * @type {boolean}
     * @memberof IssueApiIssueSearchIssues
     */
    readonly mentioned?: boolean

    /**
     * filter pulls requesting your review, default is false
     * @type {boolean}
     * @memberof IssueApiIssueSearchIssues
     */
    readonly reviewRequested?: boolean

    /**
     * filter by owner
     * @type {string}
     * @memberof IssueApiIssueSearchIssues
     */
    readonly owner?: string

    /**
     * filter by team (requires organization owner parameter to be provided)
     * @type {string}
     * @memberof IssueApiIssueSearchIssues
     */
    readonly team?: string

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof IssueApiIssueSearchIssues
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof IssueApiIssueSearchIssues
     */
    readonly limit?: number
}

/**
 * Request parameters for issueStartStopWatch operation in IssueApi.
 * @export
 * @interface IssueApiIssueStartStopWatchRequest
 */
export interface IssueApiIssueStartStopWatchRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueStartStopWatch
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueStartStopWatch
     */
    readonly repo: string

    /**
     * index of the issue to create the stopwatch on
     * @type {number}
     * @memberof IssueApiIssueStartStopWatch
     */
    readonly index: number
}

/**
 * Request parameters for issueStopStopWatch operation in IssueApi.
 * @export
 * @interface IssueApiIssueStopStopWatchRequest
 */
export interface IssueApiIssueStopStopWatchRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueStopStopWatch
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueStopStopWatch
     */
    readonly repo: string

    /**
     * index of the issue to stop the stopwatch on
     * @type {number}
     * @memberof IssueApiIssueStopStopWatch
     */
    readonly index: number
}

/**
 * Request parameters for issueSubscriptions operation in IssueApi.
 * @export
 * @interface IssueApiIssueSubscriptionsRequest
 */
export interface IssueApiIssueSubscriptionsRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueSubscriptions
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueSubscriptions
     */
    readonly repo: string

    /**
     * index of the issue
     * @type {number}
     * @memberof IssueApiIssueSubscriptions
     */
    readonly index: number

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof IssueApiIssueSubscriptions
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof IssueApiIssueSubscriptions
     */
    readonly limit?: number
}

/**
 * Request parameters for issueTrackedTimes operation in IssueApi.
 * @export
 * @interface IssueApiIssueTrackedTimesRequest
 */
export interface IssueApiIssueTrackedTimesRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof IssueApiIssueTrackedTimes
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof IssueApiIssueTrackedTimes
     */
    readonly repo: string

    /**
     * index of the issue
     * @type {number}
     * @memberof IssueApiIssueTrackedTimes
     */
    readonly index: number

    /**
     * optional filter by user (available for issue managers)
     * @type {string}
     * @memberof IssueApiIssueTrackedTimes
     */
    readonly user?: string

    /**
     * Only show times updated after the given time. This is a timestamp in RFC 3339 format
     * @type {string}
     * @memberof IssueApiIssueTrackedTimes
     */
    readonly since?: string

    /**
     * Only show times updated before the given time. This is a timestamp in RFC 3339 format
     * @type {string}
     * @memberof IssueApiIssueTrackedTimes
     */
    readonly before?: string

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof IssueApiIssueTrackedTimes
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof IssueApiIssueTrackedTimes
     */
    readonly limit?: number
}

/**
 * IssueApi - object-oriented interface
 * @export
 * @class IssueApi
 * @extends {BaseAPI}
 */
export class IssueApi extends BaseAPI {
    /**
     * 
     * @summary Add a label to an issue
     * @param {IssueApiIssueAddLabelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueAddLabel(requestParameters: IssueApiIssueAddLabelRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueAddLabel(requestParameters.owner, requestParameters.repo, requestParameters.index, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Subscribe user to issue
     * @param {IssueApiIssueAddSubscriptionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueAddSubscription(requestParameters: IssueApiIssueAddSubscriptionRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueAddSubscription(requestParameters.owner, requestParameters.repo, requestParameters.index, requestParameters.user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add tracked time to a issue
     * @param {IssueApiIssueAddTimeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueAddTime(requestParameters: IssueApiIssueAddTimeRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueAddTime(requestParameters.owner, requestParameters.repo, requestParameters.index, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if user is subscribed to an issue
     * @param {IssueApiIssueCheckSubscriptionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueCheckSubscription(requestParameters: IssueApiIssueCheckSubscriptionRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueCheckSubscription(requestParameters.owner, requestParameters.repo, requestParameters.index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove all labels from an issue
     * @param {IssueApiIssueClearLabelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueClearLabels(requestParameters: IssueApiIssueClearLabelsRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueClearLabels(requestParameters.owner, requestParameters.repo, requestParameters.index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a comment to an issue
     * @param {IssueApiIssueCreateCommentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueCreateComment(requestParameters: IssueApiIssueCreateCommentRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueCreateComment(requestParameters.owner, requestParameters.repo, requestParameters.index, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an issue. If using deadline only the date will be taken into account, and time of day ignored.
     * @param {IssueApiIssueCreateIssueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueCreateIssue(requestParameters: IssueApiIssueCreateIssueRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueCreateIssue(requestParameters.owner, requestParameters.repo, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a label
     * @param {IssueApiIssueCreateLabelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueCreateLabel(requestParameters: IssueApiIssueCreateLabelRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueCreateLabel(requestParameters.owner, requestParameters.repo, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a milestone
     * @param {IssueApiIssueCreateMilestoneRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueCreateMilestone(requestParameters: IssueApiIssueCreateMilestoneRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueCreateMilestone(requestParameters.owner, requestParameters.repo, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an issue
     * @param {IssueApiIssueDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueDelete(requestParameters: IssueApiIssueDeleteRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueDelete(requestParameters.owner, requestParameters.repo, requestParameters.index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a comment
     * @param {IssueApiIssueDeleteCommentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueDeleteComment(requestParameters: IssueApiIssueDeleteCommentRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueDeleteComment(requestParameters.owner, requestParameters.repo, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a comment
     * @param {IssueApiIssueDeleteCommentDeprecatedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueDeleteCommentDeprecated(requestParameters: IssueApiIssueDeleteCommentDeprecatedRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueDeleteCommentDeprecated(requestParameters.owner, requestParameters.repo, requestParameters.index, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a reaction from a comment of an issue
     * @param {IssueApiIssueDeleteCommentReactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueDeleteCommentReaction(requestParameters: IssueApiIssueDeleteCommentReactionRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueDeleteCommentReaction(requestParameters.owner, requestParameters.repo, requestParameters.id, requestParameters.content, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a reaction from an issue
     * @param {IssueApiIssueDeleteIssueReactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueDeleteIssueReaction(requestParameters: IssueApiIssueDeleteIssueReactionRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueDeleteIssueReaction(requestParameters.owner, requestParameters.repo, requestParameters.index, requestParameters.content, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a label
     * @param {IssueApiIssueDeleteLabelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueDeleteLabel(requestParameters: IssueApiIssueDeleteLabelRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueDeleteLabel(requestParameters.owner, requestParameters.repo, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a milestone
     * @param {IssueApiIssueDeleteMilestoneRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueDeleteMilestone(requestParameters: IssueApiIssueDeleteMilestoneRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueDeleteMilestone(requestParameters.owner, requestParameters.repo, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an issue\'s existing stopwatch.
     * @param {IssueApiIssueDeleteStopWatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueDeleteStopWatch(requestParameters: IssueApiIssueDeleteStopWatchRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueDeleteStopWatch(requestParameters.owner, requestParameters.repo, requestParameters.index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unsubscribe user from issue
     * @param {IssueApiIssueDeleteSubscriptionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueDeleteSubscription(requestParameters: IssueApiIssueDeleteSubscriptionRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueDeleteSubscription(requestParameters.owner, requestParameters.repo, requestParameters.index, requestParameters.user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete specific tracked time
     * @param {IssueApiIssueDeleteTimeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueDeleteTime(requestParameters: IssueApiIssueDeleteTimeRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueDeleteTime(requestParameters.owner, requestParameters.repo, requestParameters.index, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a comment
     * @param {IssueApiIssueEditCommentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueEditComment(requestParameters: IssueApiIssueEditCommentRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueEditComment(requestParameters.owner, requestParameters.repo, requestParameters.id, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a comment
     * @param {IssueApiIssueEditCommentDeprecatedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueEditCommentDeprecated(requestParameters: IssueApiIssueEditCommentDeprecatedRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueEditCommentDeprecated(requestParameters.owner, requestParameters.repo, requestParameters.index, requestParameters.id, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit an issue. If using deadline only the date will be taken into account, and time of day ignored.
     * @param {IssueApiIssueEditIssueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueEditIssue(requestParameters: IssueApiIssueEditIssueRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueEditIssue(requestParameters.owner, requestParameters.repo, requestParameters.index, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set an issue deadline. If set to null, the deadline is deleted. If using deadline only the date will be taken into account, and time of day ignored.
     * @param {IssueApiIssueEditIssueDeadlineRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueEditIssueDeadline(requestParameters: IssueApiIssueEditIssueDeadlineRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueEditIssueDeadline(requestParameters.owner, requestParameters.repo, requestParameters.index, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a label
     * @param {IssueApiIssueEditLabelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueEditLabel(requestParameters: IssueApiIssueEditLabelRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueEditLabel(requestParameters.owner, requestParameters.repo, requestParameters.id, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a milestone
     * @param {IssueApiIssueEditMilestoneRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueEditMilestone(requestParameters: IssueApiIssueEditMilestoneRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueEditMilestone(requestParameters.owner, requestParameters.repo, requestParameters.id, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a comment
     * @param {IssueApiIssueGetCommentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueGetComment(requestParameters: IssueApiIssueGetCommentRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueGetComment(requestParameters.owner, requestParameters.repo, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of reactions from a comment of an issue
     * @param {IssueApiIssueGetCommentReactionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueGetCommentReactions(requestParameters: IssueApiIssueGetCommentReactionsRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueGetCommentReactions(requestParameters.owner, requestParameters.repo, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all comments on an issue
     * @param {IssueApiIssueGetCommentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueGetComments(requestParameters: IssueApiIssueGetCommentsRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueGetComments(requestParameters.owner, requestParameters.repo, requestParameters.index, requestParameters.since, requestParameters.before, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all comments and events on an issue
     * @param {IssueApiIssueGetCommentsAndTimelineRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueGetCommentsAndTimeline(requestParameters: IssueApiIssueGetCommentsAndTimelineRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueGetCommentsAndTimeline(requestParameters.owner, requestParameters.repo, requestParameters.index, requestParameters.since, requestParameters.page, requestParameters.limit, requestParameters.before, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an issue
     * @param {IssueApiIssueGetIssueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueGetIssue(requestParameters: IssueApiIssueGetIssueRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueGetIssue(requestParameters.owner, requestParameters.repo, requestParameters.index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list reactions of an issue
     * @param {IssueApiIssueGetIssueReactionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueGetIssueReactions(requestParameters: IssueApiIssueGetIssueReactionsRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueGetIssueReactions(requestParameters.owner, requestParameters.repo, requestParameters.index, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single label
     * @param {IssueApiIssueGetLabelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueGetLabel(requestParameters: IssueApiIssueGetLabelRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueGetLabel(requestParameters.owner, requestParameters.repo, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an issue\'s labels
     * @param {IssueApiIssueGetLabelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueGetLabels(requestParameters: IssueApiIssueGetLabelsRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueGetLabels(requestParameters.owner, requestParameters.repo, requestParameters.index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a milestone
     * @param {IssueApiIssueGetMilestoneRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueGetMilestone(requestParameters: IssueApiIssueGetMilestoneRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueGetMilestone(requestParameters.owner, requestParameters.repo, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all of a repository\'s opened milestones
     * @param {IssueApiIssueGetMilestonesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueGetMilestonesList(requestParameters: IssueApiIssueGetMilestonesListRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueGetMilestonesList(requestParameters.owner, requestParameters.repo, requestParameters.state, requestParameters.name, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all comments in a repository
     * @param {IssueApiIssueGetRepoCommentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueGetRepoComments(requestParameters: IssueApiIssueGetRepoCommentsRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueGetRepoComments(requestParameters.owner, requestParameters.repo, requestParameters.since, requestParameters.before, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repository\'s issues
     * @param {IssueApiIssueListIssuesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueListIssues(requestParameters: IssueApiIssueListIssuesRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueListIssues(requestParameters.owner, requestParameters.repo, requestParameters.state, requestParameters.labels, requestParameters.q, requestParameters.type, requestParameters.milestones, requestParameters.since, requestParameters.before, requestParameters.createdBy, requestParameters.assignedBy, requestParameters.mentionedBy, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all of a repository\'s labels
     * @param {IssueApiIssueListLabelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueListLabels(requestParameters: IssueApiIssueListLabelsRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueListLabels(requestParameters.owner, requestParameters.repo, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a reaction to a comment of an issue
     * @param {IssueApiIssuePostCommentReactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issuePostCommentReaction(requestParameters: IssueApiIssuePostCommentReactionRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issuePostCommentReaction(requestParameters.owner, requestParameters.repo, requestParameters.id, requestParameters.content, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a reaction to an issue
     * @param {IssueApiIssuePostIssueReactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issuePostIssueReaction(requestParameters: IssueApiIssuePostIssueReactionRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issuePostIssueReaction(requestParameters.owner, requestParameters.repo, requestParameters.index, requestParameters.content, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a label from an issue
     * @param {IssueApiIssueRemoveLabelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueRemoveLabel(requestParameters: IssueApiIssueRemoveLabelRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueRemoveLabel(requestParameters.owner, requestParameters.repo, requestParameters.index, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Replace an issue\'s labels
     * @param {IssueApiIssueReplaceLabelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueReplaceLabels(requestParameters: IssueApiIssueReplaceLabelsRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueReplaceLabels(requestParameters.owner, requestParameters.repo, requestParameters.index, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset a tracked time of an issue
     * @param {IssueApiIssueResetTimeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueResetTime(requestParameters: IssueApiIssueResetTimeRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueResetTime(requestParameters.owner, requestParameters.repo, requestParameters.index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for issues across the repositories that the user has access to
     * @param {IssueApiIssueSearchIssuesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueSearchIssues(requestParameters: IssueApiIssueSearchIssuesRequest = {}, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueSearchIssues(requestParameters.state, requestParameters.labels, requestParameters.milestones, requestParameters.q, requestParameters.priorityRepoId, requestParameters.type, requestParameters.since, requestParameters.before, requestParameters.assigned, requestParameters.created, requestParameters.mentioned, requestParameters.reviewRequested, requestParameters.owner, requestParameters.team, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start stopwatch on an issue.
     * @param {IssueApiIssueStartStopWatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueStartStopWatch(requestParameters: IssueApiIssueStartStopWatchRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueStartStopWatch(requestParameters.owner, requestParameters.repo, requestParameters.index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop an issue\'s existing stopwatch.
     * @param {IssueApiIssueStopStopWatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueStopStopWatch(requestParameters: IssueApiIssueStopStopWatchRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueStopStopWatch(requestParameters.owner, requestParameters.repo, requestParameters.index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get users who subscribed on an issue.
     * @param {IssueApiIssueSubscriptionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueSubscriptions(requestParameters: IssueApiIssueSubscriptionsRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueSubscriptions(requestParameters.owner, requestParameters.repo, requestParameters.index, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List an issue\'s tracked times
     * @param {IssueApiIssueTrackedTimesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueTrackedTimes(requestParameters: IssueApiIssueTrackedTimesRequest, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueTrackedTimes(requestParameters.owner, requestParameters.repo, requestParameters.index, requestParameters.user, requestParameters.since, requestParameters.before, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }
}
