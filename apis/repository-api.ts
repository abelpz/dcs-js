/* tslint:disable */
/* eslint-disable */
/**
 * DCS (Gitea) API.
 * This documentation describes the DCS (Gitea) API.
 *
 * The version of the OpenAPI document: 1.17.4+dcs
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { APIError } from '../models';
// @ts-ignore
import { AddCollaboratorOption } from '../models';
// @ts-ignore
import { AnnotatedTag } from '../models';
// @ts-ignore
import { Attachment } from '../models';
// @ts-ignore
import { Branch } from '../models';
// @ts-ignore
import { BranchProtection } from '../models';
// @ts-ignore
import { CombinedStatus } from '../models';
// @ts-ignore
import { Commit } from '../models';
// @ts-ignore
import { CommitStatus } from '../models';
// @ts-ignore
import { ContentsResponse } from '../models';
// @ts-ignore
import { CreateBranchProtectionOption } from '../models';
// @ts-ignore
import { CreateBranchRepoOption } from '../models';
// @ts-ignore
import { CreateFileOptions } from '../models';
// @ts-ignore
import { CreateForkOption } from '../models';
// @ts-ignore
import { CreateGitRefOption } from '../models';
// @ts-ignore
import { CreateHookOption } from '../models';
// @ts-ignore
import { CreateKeyOption } from '../models';
// @ts-ignore
import { CreatePullRequestOption } from '../models';
// @ts-ignore
import { CreatePullReviewOptions } from '../models';
// @ts-ignore
import { CreateReleaseOption } from '../models';
// @ts-ignore
import { CreateRepoOption } from '../models';
// @ts-ignore
import { CreateStatusOption } from '../models';
// @ts-ignore
import { CreateTagOption } from '../models';
// @ts-ignore
import { CreateWikiPageOptions } from '../models';
// @ts-ignore
import { DeleteFileOptions } from '../models';
// @ts-ignore
import { DeployKey } from '../models';
// @ts-ignore
import { DismissPullReviewOptions } from '../models';
// @ts-ignore
import { EditAttachmentOptions } from '../models';
// @ts-ignore
import { EditBranchProtectionOption } from '../models';
// @ts-ignore
import { EditGitHookOption } from '../models';
// @ts-ignore
import { EditHookOption } from '../models';
// @ts-ignore
import { EditPullRequestOption } from '../models';
// @ts-ignore
import { EditReleaseOption } from '../models';
// @ts-ignore
import { EditRepoOption } from '../models';
// @ts-ignore
import { FileDeleteResponse } from '../models';
// @ts-ignore
import { FileResponse } from '../models';
// @ts-ignore
import { GenerateRepoOption } from '../models';
// @ts-ignore
import { GitBlobResponse } from '../models';
// @ts-ignore
import { GitHook } from '../models';
// @ts-ignore
import { GitTreeResponse } from '../models';
// @ts-ignore
import { Hook } from '../models';
// @ts-ignore
import { IssueTemplate } from '../models';
// @ts-ignore
import { MergePullRequestOption } from '../models';
// @ts-ignore
import { MigrateRepoOptions } from '../models';
// @ts-ignore
import { Note } from '../models';
// @ts-ignore
import { PullRequest } from '../models';
// @ts-ignore
import { PullReview } from '../models';
// @ts-ignore
import { PullReviewComment } from '../models';
// @ts-ignore
import { PullReviewRequestOptions } from '../models';
// @ts-ignore
import { Reference } from '../models';
// @ts-ignore
import { Release } from '../models';
// @ts-ignore
import { RepoCollaboratorPermission } from '../models';
// @ts-ignore
import { RepoTopicOptions } from '../models';
// @ts-ignore
import { Repository } from '../models';
// @ts-ignore
import { SearchResults } from '../models';
// @ts-ignore
import { SubmitPullReviewOptions } from '../models';
// @ts-ignore
import { Tag } from '../models';
// @ts-ignore
import { Team } from '../models';
// @ts-ignore
import { TopicName } from '../models';
// @ts-ignore
import { TopicResponse } from '../models';
// @ts-ignore
import { TrackedTime } from '../models';
// @ts-ignore
import { TransferRepoOption } from '../models';
// @ts-ignore
import { UpdateFileOptions } from '../models';
// @ts-ignore
import { UpdateGitRefOption } from '../models';
// @ts-ignore
import { User } from '../models';
// @ts-ignore
import { WatchInfo } from '../models';
// @ts-ignore
import { WikiCommitList } from '../models';
// @ts-ignore
import { WikiPage } from '../models';
// @ts-ignore
import { WikiPageMetaData } from '../models';
/**
 * RepositoryApi - axios parameter creator
 * @export
 */
export const RepositoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Accept a repo transfer
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptRepoTransfer: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('acceptRepoTransfer', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('acceptRepoTransfer', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/transfer/accept`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a repository
         * @param {CreateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCurrentUserRepo: async (body?: CreateRepoOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/repos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fork a repository
         * @param {string} owner owner of the repo to fork
         * @param {string} repo name of the repo to fork
         * @param {CreateForkOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFork: async (owner: string, repo: string, body?: CreateForkOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('createFork', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('createFork', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/forks`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a repository using a template
         * @param {string} templateOwner name of the template repository owner
         * @param {string} templateRepo name of the template repository
         * @param {GenerateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateRepo: async (templateOwner: string, templateRepo: string, body?: GenerateRepoOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateOwner' is not null or undefined
            assertParamExists('generateRepo', 'templateOwner', templateOwner)
            // verify required parameter 'templateRepo' is not null or undefined
            assertParamExists('generateRepo', 'templateRepo', templateRepo)
            const localVarPath = `/repos/{template_owner}/{template_repo}/generate`
                .replace(`{${"template_owner"}}`, encodeURIComponent(String(templateOwner)))
                .replace(`{${"template_repo"}}`, encodeURIComponent(String(templateRepo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the tag object of an annotated tag (not lightweight tags)
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnotatedTag: async (owner: string, repo: string, sha: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('getAnnotatedTag', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('getAnnotatedTag', 'repo', repo)
            // verify required parameter 'sha' is not null or undefined
            assertParamExists('getAnnotatedTag', 'sha', sha)
            const localVarPath = `/repos/{owner}/{repo}/git/tags/{sha}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"sha"}}`, encodeURIComponent(String(sha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the blob of a repository.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlob: async (owner: string, repo: string, sha: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('getBlob', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('getBlob', 'repo', repo)
            // verify required parameter 'sha' is not null or undefined
            assertParamExists('getBlob', 'sha', sha)
            const localVarPath = `/repos/{owner}/{repo}/git/blobs/{sha}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"sha"}}`, encodeURIComponent(String(sha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the tree of a repository.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {boolean} [recursive] show all directories and files
         * @param {number} [page] page number; the \&#39;truncated\&#39; field in the response will be true if there are still more items after this page, false if the last page
         * @param {number} [perPage] number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTree: async (owner: string, repo: string, sha: string, recursive?: boolean, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('getTree', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('getTree', 'repo', repo)
            // verify required parameter 'sha' is not null or undefined
            assertParamExists('getTree', 'sha', sha)
            const localVarPath = `/repos/{owner}/{repo}/git/trees/{sha}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"sha"}}`, encodeURIComponent(String(sha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (recursive !== undefined) {
                localVarQueryParameter['recursive'] = recursive;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repository\'s forks
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listForks: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('listForks', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('listForks', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/forks`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reject a repo transfer
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectRepoTransfer: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('rejectRepoTransfer', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('rejectRepoTransfer', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/transfer/reject`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a collaborator to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator to add
         * @param {AddCollaboratorOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoAddCollaborator: async (owner: string, repo: string, collaborator: string, body?: AddCollaboratorOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoAddCollaborator', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoAddCollaborator', 'repo', repo)
            // verify required parameter 'collaborator' is not null or undefined
            assertParamExists('repoAddCollaborator', 'collaborator', collaborator)
            const localVarPath = `/repos/{owner}/{repo}/collaborators/{collaborator}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"collaborator"}}`, encodeURIComponent(String(collaborator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a team to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoAddTeam: async (owner: string, repo: string, team: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoAddTeam', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoAddTeam', 'repo', repo)
            // verify required parameter 'team' is not null or undefined
            assertParamExists('repoAddTeam', 'team', team)
            const localVarPath = `/repos/{owner}/{repo}/teams/{team}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a topic to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} topic name of the topic to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoAddTopic: async (owner: string, repo: string, topic: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoAddTopic', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoAddTopic', 'repo', repo)
            // verify required parameter 'topic' is not null or undefined
            assertParamExists('repoAddTopic', 'topic', topic)
            const localVarPath = `/repos/{owner}/{repo}/topics/{topic}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Apply diff patch to repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {UpdateFileOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoApplyDiffPatch: async (owner: string, repo: string, body: UpdateFileOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoApplyDiffPatch', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoApplyDiffPatch', 'repo', repo)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repoApplyDiffPatch', 'body', body)
            const localVarPath = `/repos/{owner}/{repo}/diffpatch`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancel the scheduled auto merge for the given pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to merge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCancelScheduledAutoMerge: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCancelScheduledAutoMerge', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCancelScheduledAutoMerge', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoCancelScheduledAutoMerge', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/merge`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if a user is a collaborator of a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCheckCollaborator: async (owner: string, repo: string, collaborator: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCheckCollaborator', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCheckCollaborator', 'repo', repo)
            // verify required parameter 'collaborator' is not null or undefined
            assertParamExists('repoCheckCollaborator', 'collaborator', collaborator)
            const localVarPath = `/repos/{owner}/{repo}/collaborators/{collaborator}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"collaborator"}}`, encodeURIComponent(String(collaborator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if a team is assigned to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCheckTeam: async (owner: string, repo: string, team: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCheckTeam', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCheckTeam', 'repo', repo)
            // verify required parameter 'team' is not null or undefined
            assertParamExists('repoCheckTeam', 'team', team)
            const localVarPath = `/repos/{owner}/{repo}/teams/{team}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a branch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateBranchRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateBranch: async (owner: string, repo: string, body?: CreateBranchRepoOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreateBranch', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreateBranch', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/branches`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a branch protections for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateBranchProtectionOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateBranchProtection: async (owner: string, repo: string, body?: CreateBranchProtectionOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreateBranchProtection', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreateBranchProtection', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/branch_protections`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to create
         * @param {CreateFileOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateFile: async (owner: string, repo: string, filepath: string, body: CreateFileOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreateFile', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreateFile', 'repo', repo)
            // verify required parameter 'filepath' is not null or undefined
            assertParamExists('repoCreateFile', 'filepath', filepath)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repoCreateFile', 'body', body)
            const localVarPath = `/repos/{owner}/{repo}/contents/{filepath}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"filepath"}}`, encodeURIComponent(String(filepath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a reference for your repository. You are unable to create new references for empty repositories, even if the commit SHA-1 hash used exists. Empty repositories are repositories without branches.
         * @summary Create a reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateGitRefOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateGitRef: async (owner: string, repo: string, body?: CreateGitRefOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreateGitRef', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreateGitRef', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/git/refs`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateHook: async (owner: string, repo: string, body?: CreateHookOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreateHook', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreateHook', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/hooks`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a key to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateKeyOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateKey: async (owner: string, repo: string, body?: CreateKeyOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreateKey', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreateKey', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/keys`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreatePullRequestOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreatePullRequest: async (owner: string, repo: string, body?: CreatePullRequestOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreatePullRequest', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreatePullRequest', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/pulls`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a review to an pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {CreatePullReviewOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreatePullReview: async (owner: string, repo: string, index: number, body: CreatePullReviewOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreatePullReview', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreatePullReview', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoCreatePullReview', 'index', index)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repoCreatePullReview', 'body', body)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary create review requests for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {PullReviewRequestOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreatePullReviewRequests: async (owner: string, repo: string, index: number, body: PullReviewRequestOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreatePullReviewRequests', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreatePullReviewRequests', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoCreatePullReviewRequests', 'index', index)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repoCreatePullReviewRequests', 'body', body)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/requested_reviewers`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateReleaseOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateRelease: async (owner: string, repo: string, body?: CreateReleaseOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreateRelease', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreateRelease', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/releases`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {File} attachment attachment to upload
         * @param {string} [name] name of the attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateReleaseAttachment: async (owner: string, repo: string, id: number, attachment: File, name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreateReleaseAttachment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreateReleaseAttachment', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoCreateReleaseAttachment', 'id', id)
            // verify required parameter 'attachment' is not null or undefined
            assertParamExists('repoCreateReleaseAttachment', 'attachment', attachment)
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}/assets`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


            if (attachment !== undefined) { 
                localVarFormParams.append('attachment', attachment as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a commit status
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {CreateStatusOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateStatus: async (owner: string, repo: string, sha: string, body?: CreateStatusOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreateStatus', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreateStatus', 'repo', repo)
            // verify required parameter 'sha' is not null or undefined
            assertParamExists('repoCreateStatus', 'sha', sha)
            const localVarPath = `/repos/{owner}/{repo}/statuses/{sha}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"sha"}}`, encodeURIComponent(String(sha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new git tag in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateTagOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateTag: async (owner: string, repo: string, body?: CreateTagOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreateTag', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreateTag', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/tags`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateWikiPageOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateWikiPage: async (owner: string, repo: string, body?: CreateWikiPageOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoCreateWikiPage', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoCreateWikiPage', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/wiki/new`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a repository
         * @param {string} owner owner of the repo to delete
         * @param {string} repo name of the repo to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDelete: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDelete', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDelete', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a specific branch from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} branch branch to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteBranch: async (owner: string, repo: string, branch: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteBranch', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteBranch', 'repo', repo)
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('repoDeleteBranch', 'branch', branch)
            const localVarPath = `/repos/{owner}/{repo}/branches/{branch}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"branch"}}`, encodeURIComponent(String(branch)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a specific branch protection for the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteBranchProtection: async (owner: string, repo: string, name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteBranchProtection', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteBranchProtection', 'repo', repo)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('repoDeleteBranchProtection', 'name', name)
            const localVarPath = `/repos/{owner}/{repo}/branch_protections/{name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a collaborator from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteCollaborator: async (owner: string, repo: string, collaborator: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteCollaborator', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteCollaborator', 'repo', repo)
            // verify required parameter 'collaborator' is not null or undefined
            assertParamExists('repoDeleteCollaborator', 'collaborator', collaborator)
            const localVarPath = `/repos/{owner}/{repo}/collaborators/{collaborator}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"collaborator"}}`, encodeURIComponent(String(collaborator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to delete
         * @param {DeleteFileOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteFile: async (owner: string, repo: string, filepath: string, body: DeleteFileOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteFile', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteFile', 'repo', repo)
            // verify required parameter 'filepath' is not null or undefined
            assertParamExists('repoDeleteFile', 'filepath', filepath)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repoDeleteFile', 'body', body)
            const localVarPath = `/repos/{owner}/{repo}/contents/{filepath}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"filepath"}}`, encodeURIComponent(String(filepath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Git hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteGitHook: async (owner: string, repo: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteGitHook', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteGitHook', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoDeleteGitHook', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/hooks/git/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref name of the ref to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteGitRef: async (owner: string, repo: string, ref: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteGitRef', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteGitRef', 'repo', repo)
            // verify required parameter 'ref' is not null or undefined
            assertParamExists('repoDeleteGitRef', 'ref', ref)
            const localVarPath = `/repos/{owner}/{repo}/git/refs/{ref}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"ref"}}`, encodeURIComponent(String(ref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteHook: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteHook', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteHook', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoDeleteHook', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/hooks/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a key from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteKey: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteKey', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteKey', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoDeleteKey', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/keys/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a specific review from a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeletePullReview: async (owner: string, repo: string, index: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeletePullReview', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeletePullReview', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoDeletePullReview', 'index', index)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoDeletePullReview', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary cancel review requests for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {PullReviewRequestOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeletePullReviewRequests: async (owner: string, repo: string, index: number, body: PullReviewRequestOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeletePullReviewRequests', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeletePullReviewRequests', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoDeletePullReviewRequests', 'index', index)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repoDeletePullReviewRequests', 'body', body)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/requested_reviewers`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteRelease: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteRelease', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteRelease', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoDeleteRelease', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteReleaseAttachment: async (owner: string, repo: string, id: number, attachmentId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteReleaseAttachment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteReleaseAttachment', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoDeleteReleaseAttachment', 'id', id)
            // verify required parameter 'attachmentId' is not null or undefined
            assertParamExists('repoDeleteReleaseAttachment', 'attachmentId', attachmentId)
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a release by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag tag name of the release to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteReleaseByTag: async (owner: string, repo: string, tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteReleaseByTag', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteReleaseByTag', 'repo', repo)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('repoDeleteReleaseByTag', 'tag', tag)
            const localVarPath = `/repos/{owner}/{repo}/releases/tags/{tag}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a repository\'s tag by name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag name of tag to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteTag: async (owner: string, repo: string, tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteTag', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteTag', 'repo', repo)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('repoDeleteTag', 'tag', tag)
            const localVarPath = `/repos/{owner}/{repo}/tags/{tag}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a team from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteTeam: async (owner: string, repo: string, team: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteTeam', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteTeam', 'repo', repo)
            // verify required parameter 'team' is not null or undefined
            assertParamExists('repoDeleteTeam', 'team', team)
            const localVarPath = `/repos/{owner}/{repo}/teams/{team}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a topic from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} topic name of the topic to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteTopic: async (owner: string, repo: string, topic: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteTopic', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteTopic', 'repo', repo)
            // verify required parameter 'topic' is not null or undefined
            assertParamExists('repoDeleteTopic', 'topic', topic)
            const localVarPath = `/repos/{owner}/{repo}/topics/{topic}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteWikiPage: async (owner: string, repo: string, pageName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDeleteWikiPage', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDeleteWikiPage', 'repo', repo)
            // verify required parameter 'pageName' is not null or undefined
            assertParamExists('repoDeleteWikiPage', 'pageName', pageName)
            const localVarPath = `/repos/{owner}/{repo}/wiki/page/{pageName}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"pageName"}}`, encodeURIComponent(String(pageName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dismiss a review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {DismissPullReviewOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDismissPullReview: async (owner: string, repo: string, index: number, id: number, body: DismissPullReviewOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDismissPullReview', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDismissPullReview', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoDismissPullReview', 'index', index)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoDismissPullReview', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repoDismissPullReview', 'body', body)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/dismissals`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a commit\'s diff or patch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha SHA of the commit to get
         * @param {'diff' | 'patch'} diffType whether the output is diff or patch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDownloadCommitDiffOrPatch: async (owner: string, repo: string, sha: string, diffType: 'diff' | 'patch', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDownloadCommitDiffOrPatch', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDownloadCommitDiffOrPatch', 'repo', repo)
            // verify required parameter 'sha' is not null or undefined
            assertParamExists('repoDownloadCommitDiffOrPatch', 'sha', sha)
            // verify required parameter 'diffType' is not null or undefined
            assertParamExists('repoDownloadCommitDiffOrPatch', 'diffType', diffType)
            const localVarPath = `/repos/{owner}/{repo}/git/commits/{sha}.{diffType}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"sha"}}`, encodeURIComponent(String(sha)))
                .replace(`{${"diffType"}}`, encodeURIComponent(String(diffType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a pull request diff or patch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {'diff' | 'patch'} diffType whether the output is diff or patch
         * @param {boolean} [binary] whether to include binary file changes. if true, the diff is applicable with &#x60;git apply&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDownloadPullDiffOrPatch: async (owner: string, repo: string, index: number, diffType: 'diff' | 'patch', binary?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoDownloadPullDiffOrPatch', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoDownloadPullDiffOrPatch', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoDownloadPullDiffOrPatch', 'index', index)
            // verify required parameter 'diffType' is not null or undefined
            assertParamExists('repoDownloadPullDiffOrPatch', 'diffType', diffType)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}.{diffType}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"diffType"}}`, encodeURIComponent(String(diffType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (binary !== undefined) {
                localVarQueryParameter['binary'] = binary;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a repository\'s properties. Only fields that are set will be changed.
         * @param {string} owner owner of the repo to edit
         * @param {string} repo name of the repo to edit
         * @param {EditRepoOption} [body] Properties of a repo that you can edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEdit: async (owner: string, repo: string, body?: EditRepoOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoEdit', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoEdit', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a branch protections for a repository. Only fields that are set will be changed
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {EditBranchProtectionOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditBranchProtection: async (owner: string, repo: string, name: string, body?: EditBranchProtectionOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoEditBranchProtection', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoEditBranchProtection', 'repo', repo)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('repoEditBranchProtection', 'name', name)
            const localVarPath = `/repos/{owner}/{repo}/branch_protections/{name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a Git hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {EditGitHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditGitHook: async (owner: string, repo: string, id: string, body?: EditGitHookOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoEditGitHook', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoEditGitHook', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoEditGitHook', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/hooks/git/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id index of the hook
         * @param {EditHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditHook: async (owner: string, repo: string, id: number, body?: EditHookOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoEditHook', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoEditHook', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoEditHook', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/hooks/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a pull request. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to edit
         * @param {EditPullRequestOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditPullRequest: async (owner: string, repo: string, index: number, body?: EditPullRequestOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoEditPullRequest', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoEditPullRequest', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoEditPullRequest', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to edit
         * @param {EditReleaseOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditRelease: async (owner: string, repo: string, id: number, body?: EditReleaseOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoEditRelease', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoEditRelease', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoEditRelease', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to edit
         * @param {EditAttachmentOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditReleaseAttachment: async (owner: string, repo: string, id: number, attachmentId: number, body?: EditAttachmentOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoEditReleaseAttachment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoEditReleaseAttachment', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoEditReleaseAttachment', 'id', id)
            // verify required parameter 'attachmentId' is not null or undefined
            assertParamExists('repoEditReleaseAttachment', 'attachmentId', attachmentId)
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {CreateWikiPageOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditWikiPage: async (owner: string, repo: string, pageName: string, body?: CreateWikiPageOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoEditWikiPage', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoEditWikiPage', 'repo', repo)
            // verify required parameter 'pageName' is not null or undefined
            assertParamExists('repoEditWikiPage', 'pageName', pageName)
            const localVarPath = `/repos/{owner}/{repo}/wiki/page/{pageName}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"pageName"}}`, encodeURIComponent(String(pageName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGet: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGet', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGet', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of all commits from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [sha] SHA or branch to start listing commits from (usually \&#39;master\&#39;)
         * @param {string} [path] filepath of a file/dir
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results (ignored if used with \&#39;path\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetAllCommits: async (owner: string, repo: string, sha?: string, path?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetAllCommits', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetAllCommits', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/commits`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (sha !== undefined) {
                localVarQueryParameter['sha'] = sha;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an archive of a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} archive the git reference for download with attached archive format (e.g. master.zip)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetArchive: async (owner: string, repo: string, archive: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetArchive', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetArchive', 'repo', repo)
            // verify required parameter 'archive' is not null or undefined
            assertParamExists('repoGetArchive', 'archive', archive)
            const localVarPath = `/repos/{owner}/{repo}/archive/{archive}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"archive"}}`, encodeURIComponent(String(archive)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return all users that have write access and can be assigned to issues
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetAssignees: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetAssignees', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetAssignees', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/assignees`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a specific branch from a repository, including its effective branch protection
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} branch branch to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetBranch: async (owner: string, repo: string, branch: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetBranch', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetBranch', 'repo', repo)
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('repoGetBranch', 'branch', branch)
            const localVarPath = `/repos/{owner}/{repo}/branches/{branch}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"branch"}}`, encodeURIComponent(String(branch)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific branch protection for the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetBranchProtection: async (owner: string, repo: string, name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetBranchProtection', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetBranchProtection', 'repo', repo)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('repoGetBranchProtection', 'name', name)
            const localVarPath = `/repos/{owner}/{repo}/branch_protections/{name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a repository by id
         * @param {number} id id of the repo to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetByID: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoGetByID', 'id', id)
            const localVarPath = `/repositories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a commit\'s combined status, by branch/tag/commit reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref name of branch/tag/commit
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetCombinedStatusByRef: async (owner: string, repo: string, ref: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetCombinedStatusByRef', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetCombinedStatusByRef', 'repo', repo)
            // verify required parameter 'ref' is not null or undefined
            assertParamExists('repoGetCombinedStatusByRef', 'ref', ref)
            const localVarPath = `/repos/{owner}/{repo}/commits/{ref}/status`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"ref"}}`, encodeURIComponent(String(ref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the dir, file, symlink or submodule in the repo
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetContents: async (owner: string, repo: string, filepath: string, ref?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetContents', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetContents', 'repo', repo)
            // verify required parameter 'filepath' is not null or undefined
            assertParamExists('repoGetContents', 'filepath', filepath)
            const localVarPath = `/repos/{owner}/{repo}/contents/{filepath}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"filepath"}}`, encodeURIComponent(String(filepath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (ref !== undefined) {
                localVarQueryParameter['ref'] = ref;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the metadata of all the entries of the root dir
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetContentsList: async (owner: string, repo: string, ref?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetContentsList', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetContentsList', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/contents`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (ref !== undefined) {
                localVarQueryParameter['ref'] = ref;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the EditorConfig definitions of a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of file to get
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetEditorConfig: async (owner: string, repo: string, filepath: string, ref?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetEditorConfig', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetEditorConfig', 'repo', repo)
            // verify required parameter 'filepath' is not null or undefined
            assertParamExists('repoGetEditorConfig', 'filepath', filepath)
            const localVarPath = `/repos/{owner}/{repo}/editorconfig/{filepath}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"filepath"}}`, encodeURIComponent(String(filepath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (ref !== undefined) {
                localVarQueryParameter['ref'] = ref;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Git hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetGitHook: async (owner: string, repo: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetGitHook', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetGitHook', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoGetGitHook', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/hooks/git/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetHook: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetHook', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetHook', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoGetHook', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/hooks/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get available issue templates for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetIssueTemplates: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetIssueTemplates', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetIssueTemplates', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/issue_templates`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a repository\'s key by id
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the key to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetKey: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetKey', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetKey', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoGetKey', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/keys/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get languages and number of bytes of code written
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetLanguages: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetLanguages', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetLanguages', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/languages`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a note corresponding to a single commit from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha a git ref or commit sha
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetNote: async (owner: string, repo: string, sha: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetNote', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetNote', 'repo', repo)
            // verify required parameter 'sha' is not null or undefined
            assertParamExists('repoGetNote', 'sha', sha)
            const localVarPath = `/repos/{owner}/{repo}/git/notes/{sha}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"sha"}}`, encodeURIComponent(String(sha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPullRequest: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetPullRequest', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetPullRequest', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoGetPullRequest', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get commits for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPullRequestCommits: async (owner: string, repo: string, index: number, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetPullRequestCommits', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetPullRequestCommits', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoGetPullRequestCommits', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/commits`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPullReview: async (owner: string, repo: string, index: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetPullReview', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetPullReview', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoGetPullReview', 'index', index)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoGetPullReview', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPullReviewComments: async (owner: string, repo: string, index: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetPullReviewComments', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetPullReviewComments', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoGetPullReviewComments', 'index', index)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoGetPullReviewComments', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/comments`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a file from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of the file to get
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetRawFile: async (owner: string, repo: string, filepath: string, ref?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetRawFile', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetRawFile', 'repo', repo)
            // verify required parameter 'filepath' is not null or undefined
            assertParamExists('repoGetRawFile', 'filepath', filepath)
            const localVarPath = `/repos/{owner}/{repo}/raw/{filepath}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"filepath"}}`, encodeURIComponent(String(filepath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (ref !== undefined) {
                localVarQueryParameter['ref'] = ref;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a file or it\'s LFS object from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of the file to get
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetRawFileOrLFS: async (owner: string, repo: string, filepath: string, ref?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetRawFileOrLFS', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetRawFileOrLFS', 'repo', repo)
            // verify required parameter 'filepath' is not null or undefined
            assertParamExists('repoGetRawFileOrLFS', 'filepath', filepath)
            const localVarPath = `/repos/{owner}/{repo}/media/{filepath}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"filepath"}}`, encodeURIComponent(String(filepath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (ref !== undefined) {
                localVarQueryParameter['ref'] = ref;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetRelease: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetRelease', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetRelease', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoGetRelease', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetReleaseAttachment: async (owner: string, repo: string, id: number, attachmentId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetReleaseAttachment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetReleaseAttachment', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoGetReleaseAttachment', 'id', id)
            // verify required parameter 'attachmentId' is not null or undefined
            assertParamExists('repoGetReleaseAttachment', 'attachmentId', attachmentId)
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a release by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag tag name of the release to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetReleaseByTag: async (owner: string, repo: string, tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetReleaseByTag', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetReleaseByTag', 'repo', repo)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('repoGetReleaseByTag', 'tag', tag)
            const localVarPath = `/repos/{owner}/{repo}/releases/tags/{tag}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get repository permissions for a user
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetRepoPermissions: async (owner: string, repo: string, collaborator: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetRepoPermissions', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetRepoPermissions', 'repo', repo)
            // verify required parameter 'collaborator' is not null or undefined
            assertParamExists('repoGetRepoPermissions', 'collaborator', collaborator)
            const localVarPath = `/repos/{owner}/{repo}/collaborators/{collaborator}/permission`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"collaborator"}}`, encodeURIComponent(String(collaborator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return all users that can be requested to review in this repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetReviewers: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetReviewers', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetReviewers', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/reviewers`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single commit from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha a git ref or commit sha
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetSingleCommit: async (owner: string, repo: string, sha: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetSingleCommit', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetSingleCommit', 'repo', repo)
            // verify required parameter 'sha' is not null or undefined
            assertParamExists('repoGetSingleCommit', 'sha', sha)
            const localVarPath = `/repos/{owner}/{repo}/git/commits/{sha}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"sha"}}`, encodeURIComponent(String(sha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the tag of a repository by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag name of tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetTag: async (owner: string, repo: string, tag: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetTag', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetTag', 'repo', repo)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('repoGetTag', 'tag', tag)
            const localVarPath = `/repos/{owner}/{repo}/tags/{tag}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetWikiPage: async (owner: string, repo: string, pageName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetWikiPage', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetWikiPage', 'repo', repo)
            // verify required parameter 'pageName' is not null or undefined
            assertParamExists('repoGetWikiPage', 'pageName', pageName)
            const localVarPath = `/repos/{owner}/{repo}/wiki/page/{pageName}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"pageName"}}`, encodeURIComponent(String(pageName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get revisions of a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {number} [page] page number of results to return (1-based)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetWikiPageRevisions: async (owner: string, repo: string, pageName: string, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetWikiPageRevisions', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetWikiPageRevisions', 'repo', repo)
            // verify required parameter 'pageName' is not null or undefined
            assertParamExists('repoGetWikiPageRevisions', 'pageName', pageName)
            const localVarPath = `/repos/{owner}/{repo}/wiki/revisions/{pageName}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"pageName"}}`, encodeURIComponent(String(pageName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all wiki pages
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetWikiPages: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoGetWikiPages', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoGetWikiPages', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/wiki/pages`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get specified ref or filtered repository\'s refs
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListAllGitRefs: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListAllGitRefs', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListAllGitRefs', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/git/refs`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List branch protections for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListBranchProtection: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListBranchProtection', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListBranchProtection', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/branch_protections`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repository\'s branches
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListBranches: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListBranches', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListBranches', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/branches`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repository\'s collaborators
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListCollaborators: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListCollaborators', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListCollaborators', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/collaborators`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the Git hooks in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListGitHooks: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListGitHooks', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListGitHooks', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/hooks/git`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get specified ref or filtered repository\'s refs
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref part or full name of the ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListGitRefs: async (owner: string, repo: string, ref: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListGitRefs', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListGitRefs', 'repo', repo)
            // verify required parameter 'ref' is not null or undefined
            assertParamExists('repoListGitRefs', 'ref', ref)
            const localVarPath = `/repos/{owner}/{repo}/git/refs/{ref}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"ref"}}`, encodeURIComponent(String(ref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the hooks in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListHooks: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListHooks', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListHooks', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/hooks`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repository\'s keys
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [keyId] the key_id to search for
         * @param {string} [fingerprint] fingerprint of the key
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListKeys: async (owner: string, repo: string, keyId?: number, fingerprint?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListKeys', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListKeys', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/keys`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (keyId !== undefined) {
                localVarQueryParameter['key_id'] = keyId;
            }

            if (fingerprint !== undefined) {
                localVarQueryParameter['fingerprint'] = fingerprint;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repo\'s pull requests
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {'closed' | 'open' | 'all'} [state] State of pull request: open or closed (optional)
         * @param {'oldest' | 'recentupdate' | 'leastupdate' | 'mostcomment' | 'leastcomment' | 'priority'} [sort] Type of sort
         * @param {number} [milestone] ID of the milestone
         * @param {Array<number>} [labels] Label IDs
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListPullRequests: async (owner: string, repo: string, state?: 'closed' | 'open' | 'all', sort?: 'oldest' | 'recentupdate' | 'leastupdate' | 'mostcomment' | 'leastcomment' | 'priority', milestone?: number, labels?: Array<number>, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListPullRequests', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListPullRequests', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/pulls`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (milestone !== undefined) {
                localVarQueryParameter['milestone'] = milestone;
            }

            if (labels) {
                localVarQueryParameter['labels'] = labels;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all reviews for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListPullReviews: async (owner: string, repo: string, index: number, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListPullReviews', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListPullReviews', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoListPullReviews', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List release\'s attachments
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListReleaseAttachments: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListReleaseAttachments', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListReleaseAttachments', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoListReleaseAttachments', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/releases/{id}/assets`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repo\'s releases
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {boolean} [draft] filter (exclude / include) drafts, if you dont have repo write access none will show
         * @param {boolean} [preRelease] filter (exclude / include) pre-releases
         * @param {number} [perPage] page size of results, deprecated - use limit
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListReleases: async (owner: string, repo: string, draft?: boolean, preRelease?: boolean, perPage?: number, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListReleases', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListReleases', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/releases`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (draft !== undefined) {
                localVarQueryParameter['draft'] = draft;
            }

            if (preRelease !== undefined) {
                localVarQueryParameter['pre-release'] = preRelease;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repo\'s stargazers
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListStargazers: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListStargazers', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListStargazers', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/stargazers`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a commit\'s statuses
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {'oldest' | 'recentupdate' | 'leastupdate' | 'leastindex' | 'highestindex'} [sort] type of sort
         * @param {'pending' | 'success' | 'error' | 'failure' | 'warning'} [state] type of state
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListStatuses: async (owner: string, repo: string, sha: string, sort?: 'oldest' | 'recentupdate' | 'leastupdate' | 'leastindex' | 'highestindex', state?: 'pending' | 'success' | 'error' | 'failure' | 'warning', page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListStatuses', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListStatuses', 'repo', repo)
            // verify required parameter 'sha' is not null or undefined
            assertParamExists('repoListStatuses', 'sha', sha)
            const localVarPath = `/repos/{owner}/{repo}/statuses/{sha}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"sha"}}`, encodeURIComponent(String(sha)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a commit\'s statuses, by branch/tag/commit reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref name of branch/tag/commit
         * @param {'oldest' | 'recentupdate' | 'leastupdate' | 'leastindex' | 'highestindex'} [sort] type of sort
         * @param {'pending' | 'success' | 'error' | 'failure' | 'warning'} [state] type of state
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListStatusesByRef: async (owner: string, repo: string, ref: string, sort?: 'oldest' | 'recentupdate' | 'leastupdate' | 'leastindex' | 'highestindex', state?: 'pending' | 'success' | 'error' | 'failure' | 'warning', page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListStatusesByRef', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListStatusesByRef', 'repo', repo)
            // verify required parameter 'ref' is not null or undefined
            assertParamExists('repoListStatusesByRef', 'ref', ref)
            const localVarPath = `/repos/{owner}/{repo}/commits/{ref}/statuses`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"ref"}}`, encodeURIComponent(String(ref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repo\'s watchers
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListSubscribers: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListSubscribers', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListSubscribers', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/subscribers`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repository\'s tags
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results, default maximum page size is 50
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListTags: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListTags', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListTags', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/tags`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repository\'s teams
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListTeams: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListTeams', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListTeams', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/teams`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of topics that a repository has
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListTopics: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoListTopics', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoListTopics', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/topics`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Merge a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to merge
         * @param {MergePullRequestOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoMergePullRequest: async (owner: string, repo: string, index: number, body?: MergePullRequestOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoMergePullRequest', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoMergePullRequest', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoMergePullRequest', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/merge`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Migrate a remote git repository
         * @param {MigrateRepoOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoMigrate: async (body?: MigrateRepoOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/repos/migrate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sync a mirrored repository
         * @param {string} owner owner of the repo to sync
         * @param {string} repo name of the repo to sync
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoMirrorSync: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoMirrorSync', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoMirrorSync', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/mirror-sync`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if a pull request has been merged
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoPullRequestIsMerged: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoPullRequestIsMerged', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoPullRequestIsMerged', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoPullRequestIsMerged', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/merge`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for repositories
         * @param {string} [q] keyword
         * @param {boolean} [topic] Limit search to repositories with keyword as topic
         * @param {boolean} [includeDesc] include search of keyword within repository description (defaults to false)
         * @param {number} [uid] search only for repos that the user with the given id owns or contributes to
         * @param {number} [priorityOwnerId] repo owner to prioritize in the results
         * @param {number} [teamId] search only for repos that belong to the given team id
         * @param {number} [starredBy] search only for repos that the user with the given id has starred
         * @param {boolean} [_private] include private repositories this user has access to (defaults to true)
         * @param {boolean} [isPrivate] show only pubic, private or all repositories (defaults to all)
         * @param {boolean} [template] include template repositories this user has access to (defaults to true)
         * @param {boolean} [archived] show only archived, non-archived or all repositories (defaults to all)
         * @param {string} [mode] type of repository to search for. Supported values are \&quot;fork\&quot;, \&quot;source\&quot;, \&quot;mirror\&quot; and \&quot;collaborative\&quot;
         * @param {boolean} [exclusive] if &#x60;uid&#x60; is given, search only for repos that the user owns
         * @param {string} [repo] name of the repo. Multiple repo\&#39;s are ORed.
         * @param {string} [owner] owner of the repo. Multiple owner\&#39;s are ORed.
         * @param {string} [lang] If the repo is a resource of the given language(s), the repo will be in the results. Multiple lang\&#39;s are ORed.
         * @param {string} [subject] resource subject. Multiple subject\&#39;s are ORed.
         * @param {string} [book] book (project id) that exist in a resource. If the resource contains the the book, its repository will be included in the results. Multiple book\&#39;s are ORed.
         * @param {boolean} [includeMetadata] if false, q value will only be searched for in the repo name, owner, description and title and subject; otherwise search all values of the manifest file. (defaults to false)
         * @param {string} [sort] sort repos by attribute. Supported values are \&quot;alpha\&quot;, \&quot;created\&quot;, \&quot;updated\&quot;, \&quot;size\&quot;, and \&quot;id\&quot;. Default is \&quot;alpha\&quot;
         * @param {string} [order] sort order, either \&quot;asc\&quot; (ascending) or \&quot;desc\&quot; (descending). Default is \&quot;asc\&quot;, ignored if \&quot;sort\&quot; is not specified.
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoSearch: async (q?: string, topic?: boolean, includeDesc?: boolean, uid?: number, priorityOwnerId?: number, teamId?: number, starredBy?: number, _private?: boolean, isPrivate?: boolean, template?: boolean, archived?: boolean, mode?: string, exclusive?: boolean, repo?: string, owner?: string, lang?: string, subject?: string, book?: string, includeMetadata?: boolean, sort?: string, order?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/repos/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (topic !== undefined) {
                localVarQueryParameter['topic'] = topic;
            }

            if (includeDesc !== undefined) {
                localVarQueryParameter['includeDesc'] = includeDesc;
            }

            if (uid !== undefined) {
                localVarQueryParameter['uid'] = uid;
            }

            if (priorityOwnerId !== undefined) {
                localVarQueryParameter['priority_owner_id'] = priorityOwnerId;
            }

            if (teamId !== undefined) {
                localVarQueryParameter['team_id'] = teamId;
            }

            if (starredBy !== undefined) {
                localVarQueryParameter['starredBy'] = starredBy;
            }

            if (_private !== undefined) {
                localVarQueryParameter['private'] = _private;
            }

            if (isPrivate !== undefined) {
                localVarQueryParameter['is_private'] = isPrivate;
            }

            if (template !== undefined) {
                localVarQueryParameter['template'] = template;
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (exclusive !== undefined) {
                localVarQueryParameter['exclusive'] = exclusive;
            }

            if (repo !== undefined) {
                localVarQueryParameter['repo'] = repo;
            }

            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }

            if (subject !== undefined) {
                localVarQueryParameter['subject'] = subject;
            }

            if (book !== undefined) {
                localVarQueryParameter['book'] = book;
            }

            if (includeMetadata !== undefined) {
                localVarQueryParameter['includeMetadata'] = includeMetadata;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get signing-key.gpg for given repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoSigningKey: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoSigningKey', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoSigningKey', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/signing-key.gpg`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Submit a pending review to an pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {SubmitPullReviewOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoSubmitPullReview: async (owner: string, repo: string, index: number, id: number, body: SubmitPullReviewOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoSubmitPullReview', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoSubmitPullReview', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoSubmitPullReview', 'index', index)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoSubmitPullReview', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repoSubmitPullReview', 'body', body)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Test a push webhook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to test
         * @param {string} [ref] The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoTestHook: async (owner: string, repo: string, id: number, ref?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoTestHook', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoTestHook', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoTestHook', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/hooks/{id}/tests`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (ref !== undefined) {
                localVarQueryParameter['ref'] = ref;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repo\'s tracked times
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [user] optional filter by user (available for issue managers)
         * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoTrackedTimes: async (owner: string, repo: string, user?: string, since?: string, before?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoTrackedTimes', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoTrackedTimes', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/times`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any instanceof Date) ?
                    (since as any).toISOString() :
                    since;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any instanceof Date) ?
                    (before as any).toISOString() :
                    before;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Transfer a repo ownership
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {TransferRepoOption} body Transfer Options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoTransfer: async (owner: string, repo: string, body: TransferRepoOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoTransfer', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoTransfer', 'repo', repo)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repoTransfer', 'body', body)
            const localVarPath = `/repos/{owner}/{repo}/transfer`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancel to dismiss a review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUnDismissPullReview: async (owner: string, repo: string, index: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoUnDismissPullReview', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoUnDismissPullReview', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoUnDismissPullReview', 'index', index)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repoUnDismissPullReview', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/undismissals`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to update
         * @param {UpdateFileOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUpdateFile: async (owner: string, repo: string, filepath: string, body: UpdateFileOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoUpdateFile', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoUpdateFile', 'repo', repo)
            // verify required parameter 'filepath' is not null or undefined
            assertParamExists('repoUpdateFile', 'filepath', filepath)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('repoUpdateFile', 'body', body)
            const localVarPath = `/repos/{owner}/{repo}/contents/{filepath}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"filepath"}}`, encodeURIComponent(String(filepath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref name of the ref to update
         * @param {UpdateGitRefOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUpdateGitRef: async (owner: string, repo: string, ref: string, body?: UpdateGitRefOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoUpdateGitRef', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoUpdateGitRef', 'repo', repo)
            // verify required parameter 'ref' is not null or undefined
            assertParamExists('repoUpdateGitRef', 'ref', ref)
            const localVarPath = `/repos/{owner}/{repo}/git/refs/{ref}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"ref"}}`, encodeURIComponent(String(ref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Merge PR\'s baseBranch into headBranch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {'merge' | 'rebase'} [style] how to update pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUpdatePullRequest: async (owner: string, repo: string, index: number, style?: 'merge' | 'rebase', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoUpdatePullRequest', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoUpdatePullRequest', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('repoUpdatePullRequest', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/pulls/{index}/update`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (style !== undefined) {
                localVarQueryParameter['style'] = style;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace list of topics for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {RepoTopicOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUpdateTopics: async (owner: string, repo: string, body?: RepoTopicOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('repoUpdateTopics', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('repoUpdateTopics', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/topics`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary search topics via keyword
         * @param {string} q keywords to search
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicSearch: async (q: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('topicSearch', 'q', q)
            const localVarPath = `/topics/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if the current user is watching a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentCheckSubscription: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('userCurrentCheckSubscription', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('userCurrentCheckSubscription', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/subscription`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unwatch a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentDeleteSubscription: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('userCurrentDeleteSubscription', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('userCurrentDeleteSubscription', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/subscription`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Watch a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentPutSubscription: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('userCurrentPutSubscription', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('userCurrentPutSubscription', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/subscription`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a user\'s tracked times in a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} user username of user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        userTrackedTimes: async (owner: string, repo: string, user: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('userTrackedTimes', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('userTrackedTimes', 'repo', repo)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('userTrackedTimes', 'user', user)
            const localVarPath = `/repos/{owner}/{repo}/times/{user}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepositoryApi - functional programming interface
 * @export
 */
export const RepositoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RepositoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Accept a repo transfer
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptRepoTransfer(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptRepoTransfer(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a repository
         * @param {CreateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCurrentUserRepo(body?: CreateRepoOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCurrentUserRepo(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fork a repository
         * @param {string} owner owner of the repo to fork
         * @param {string} repo name of the repo to fork
         * @param {CreateForkOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFork(owner: string, repo: string, body?: CreateForkOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFork(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a repository using a template
         * @param {string} templateOwner name of the template repository owner
         * @param {string} templateRepo name of the template repository
         * @param {GenerateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateRepo(templateOwner: string, templateRepo: string, body?: GenerateRepoOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateRepo(templateOwner, templateRepo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets the tag object of an annotated tag (not lightweight tags)
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnnotatedTag(owner: string, repo: string, sha: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnotatedTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnnotatedTag(owner, repo, sha, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets the blob of a repository.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlob(owner: string, repo: string, sha: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitBlobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlob(owner, repo, sha, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets the tree of a repository.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {boolean} [recursive] show all directories and files
         * @param {number} [page] page number; the \&#39;truncated\&#39; field in the response will be true if there are still more items after this page, false if the last page
         * @param {number} [perPage] number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTree(owner: string, repo: string, sha: string, recursive?: boolean, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitTreeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTree(owner, repo, sha, recursive, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repository\'s forks
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listForks(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Repository>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listForks(owner, repo, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reject a repo transfer
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectRepoTransfer(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectRepoTransfer(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a collaborator to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator to add
         * @param {AddCollaboratorOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoAddCollaborator(owner: string, repo: string, collaborator: string, body?: AddCollaboratorOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoAddCollaborator(owner, repo, collaborator, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a team to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoAddTeam(owner: string, repo: string, team: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoAddTeam(owner, repo, team, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a topic to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} topic name of the topic to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoAddTopic(owner: string, repo: string, topic: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoAddTopic(owner, repo, topic, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Apply diff patch to repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {UpdateFileOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoApplyDiffPatch(owner: string, repo: string, body: UpdateFileOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoApplyDiffPatch(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Cancel the scheduled auto merge for the given pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to merge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCancelScheduledAutoMerge(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCancelScheduledAutoMerge(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check if a user is a collaborator of a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCheckCollaborator(owner: string, repo: string, collaborator: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCheckCollaborator(owner, repo, collaborator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check if a team is assigned to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCheckTeam(owner: string, repo: string, team: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Team>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCheckTeam(owner, repo, team, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a branch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateBranchRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateBranch(owner: string, repo: string, body?: CreateBranchRepoOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Branch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreateBranch(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a branch protections for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateBranchProtectionOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateBranchProtection(owner: string, repo: string, body?: CreateBranchProtectionOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BranchProtection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreateBranchProtection(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to create
         * @param {CreateFileOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateFile(owner: string, repo: string, filepath: string, body: CreateFileOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreateFile(owner, repo, filepath, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a reference for your repository. You are unable to create new references for empty repositories, even if the commit SHA-1 hash used exists. Empty repositories are repositories without branches.
         * @summary Create a reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateGitRefOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateGitRef(owner: string, repo: string, body?: CreateGitRefOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreateGitRef(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateHook(owner: string, repo: string, body?: CreateHookOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreateHook(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a key to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateKeyOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateKey(owner: string, repo: string, body?: CreateKeyOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreateKey(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreatePullRequestOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreatePullRequest(owner: string, repo: string, body?: CreatePullRequestOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreatePullRequest(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a review to an pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {CreatePullReviewOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreatePullReview(owner: string, repo: string, index: number, body: CreatePullReviewOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreatePullReview(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary create review requests for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {PullReviewRequestOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreatePullReviewRequests(owner: string, repo: string, index: number, body: PullReviewRequestOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PullReview>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreatePullReviewRequests(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateReleaseOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateRelease(owner: string, repo: string, body?: CreateReleaseOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Release>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreateRelease(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {File} attachment attachment to upload
         * @param {string} [name] name of the attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateReleaseAttachment(owner: string, repo: string, id: number, attachment: File, name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreateReleaseAttachment(owner, repo, id, attachment, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a commit status
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {CreateStatusOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateStatus(owner: string, repo: string, sha: string, body?: CreateStatusOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommitStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreateStatus(owner, repo, sha, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new git tag in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateTagOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateTag(owner: string, repo: string, body?: CreateTagOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreateTag(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateWikiPageOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoCreateWikiPage(owner: string, repo: string, body?: CreateWikiPageOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WikiPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoCreateWikiPage(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a repository
         * @param {string} owner owner of the repo to delete
         * @param {string} repo name of the repo to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDelete(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDelete(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a specific branch from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} branch branch to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteBranch(owner: string, repo: string, branch: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteBranch(owner, repo, branch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a specific branch protection for the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteBranchProtection(owner: string, repo: string, name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteBranchProtection(owner, repo, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a collaborator from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteCollaborator(owner: string, repo: string, collaborator: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteCollaborator(owner, repo, collaborator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to delete
         * @param {DeleteFileOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteFile(owner: string, repo: string, filepath: string, body: DeleteFileOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteFile(owner, repo, filepath, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Git hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteGitHook(owner: string, repo: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteGitHook(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref name of the ref to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteGitRef(owner: string, repo: string, ref: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteGitRef(owner, repo, ref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteHook(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteHook(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a key from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteKey(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteKey(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a specific review from a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeletePullReview(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeletePullReview(owner, repo, index, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary cancel review requests for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {PullReviewRequestOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeletePullReviewRequests(owner: string, repo: string, index: number, body: PullReviewRequestOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeletePullReviewRequests(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteRelease(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteRelease(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteReleaseAttachment(owner, repo, id, attachmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a release by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag tag name of the release to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteReleaseByTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteReleaseByTag(owner, repo, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a repository\'s tag by name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag name of tag to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteTag(owner, repo, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a team from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteTeam(owner: string, repo: string, team: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteTeam(owner, repo, team, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a topic from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} topic name of the topic to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteTopic(owner: string, repo: string, topic: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteTopic(owner, repo, topic, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDeleteWikiPage(owner: string, repo: string, pageName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDeleteWikiPage(owner, repo, pageName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Dismiss a review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {DismissPullReviewOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDismissPullReview(owner: string, repo: string, index: number, id: number, body: DismissPullReviewOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDismissPullReview(owner, repo, index, id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a commit\'s diff or patch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha SHA of the commit to get
         * @param {'diff' | 'patch'} diffType whether the output is diff or patch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDownloadCommitDiffOrPatch(owner: string, repo: string, sha: string, diffType: 'diff' | 'patch', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDownloadCommitDiffOrPatch(owner, repo, sha, diffType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a pull request diff or patch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {'diff' | 'patch'} diffType whether the output is diff or patch
         * @param {boolean} [binary] whether to include binary file changes. if true, the diff is applicable with &#x60;git apply&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoDownloadPullDiffOrPatch(owner: string, repo: string, index: number, diffType: 'diff' | 'patch', binary?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoDownloadPullDiffOrPatch(owner, repo, index, diffType, binary, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a repository\'s properties. Only fields that are set will be changed.
         * @param {string} owner owner of the repo to edit
         * @param {string} repo name of the repo to edit
         * @param {EditRepoOption} [body] Properties of a repo that you can edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEdit(owner: string, repo: string, body?: EditRepoOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoEdit(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a branch protections for a repository. Only fields that are set will be changed
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {EditBranchProtectionOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditBranchProtection(owner: string, repo: string, name: string, body?: EditBranchProtectionOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BranchProtection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoEditBranchProtection(owner, repo, name, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a Git hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {EditGitHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditGitHook(owner: string, repo: string, id: string, body?: EditGitHookOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitHook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoEditGitHook(owner, repo, id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id index of the hook
         * @param {EditHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditHook(owner: string, repo: string, id: number, body?: EditHookOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoEditHook(owner, repo, id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a pull request. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to edit
         * @param {EditPullRequestOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditPullRequest(owner: string, repo: string, index: number, body?: EditPullRequestOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoEditPullRequest(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to edit
         * @param {EditReleaseOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditRelease(owner: string, repo: string, id: number, body?: EditReleaseOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Release>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoEditRelease(owner, repo, id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to edit
         * @param {EditAttachmentOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, body?: EditAttachmentOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoEditReleaseAttachment(owner, repo, id, attachmentId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {CreateWikiPageOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoEditWikiPage(owner: string, repo: string, pageName: string, body?: CreateWikiPageOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WikiPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoEditWikiPage(owner, repo, pageName, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGet(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGet(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of all commits from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [sha] SHA or branch to start listing commits from (usually \&#39;master\&#39;)
         * @param {string} [path] filepath of a file/dir
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results (ignored if used with \&#39;path\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetAllCommits(owner: string, repo: string, sha?: string, path?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Commit>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetAllCommits(owner, repo, sha, path, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get an archive of a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} archive the git reference for download with attached archive format (e.g. master.zip)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetArchive(owner: string, repo: string, archive: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetArchive(owner, repo, archive, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return all users that have write access and can be assigned to issues
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetAssignees(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetAssignees(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a specific branch from a repository, including its effective branch protection
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} branch branch to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetBranch(owner: string, repo: string, branch: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Branch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetBranch(owner, repo, branch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a specific branch protection for the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetBranchProtection(owner: string, repo: string, name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BranchProtection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetBranchProtection(owner, repo, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a repository by id
         * @param {number} id id of the repo to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetByID(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetByID(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a commit\'s combined status, by branch/tag/commit reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref name of branch/tag/commit
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetCombinedStatusByRef(owner: string, repo: string, ref: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CombinedStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetCombinedStatusByRef(owner, repo, ref, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the dir, file, symlink or submodule in the repo
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetContents(owner: string, repo: string, filepath: string, ref?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContentsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetContents(owner, repo, filepath, ref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets the metadata of all the entries of the root dir
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetContentsList(owner: string, repo: string, ref?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ContentsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetContentsList(owner, repo, ref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the EditorConfig definitions of a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of file to get
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetEditorConfig(owner: string, repo: string, filepath: string, ref?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetEditorConfig(owner, repo, filepath, ref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Git hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetGitHook(owner: string, repo: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitHook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetGitHook(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetHook(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetHook(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get available issue templates for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetIssueTemplates(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IssueTemplate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetIssueTemplates(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a repository\'s key by id
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the key to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetKey(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetKey(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get languages and number of bytes of code written
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetLanguages(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: number; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetLanguages(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a note corresponding to a single commit from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha a git ref or commit sha
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetNote(owner: string, repo: string, sha: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Note>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetNote(owner, repo, sha, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetPullRequest(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetPullRequest(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get commits for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetPullRequestCommits(owner: string, repo: string, index: number, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Commit>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetPullRequestCommits(owner, repo, index, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a specific review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetPullReview(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetPullReview(owner, repo, index, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a specific review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetPullReviewComments(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PullReviewComment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetPullReviewComments(owner, repo, index, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a file from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of the file to get
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetRawFile(owner: string, repo: string, filepath: string, ref?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetRawFile(owner, repo, filepath, ref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a file or it\'s LFS object from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of the file to get
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetRawFileOrLFS(owner: string, repo: string, filepath: string, ref?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetRawFileOrLFS(owner, repo, filepath, ref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetRelease(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Release>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetRelease(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetReleaseAttachment(owner, repo, id, attachmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a release by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag tag name of the release to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetReleaseByTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Release>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetReleaseByTag(owner, repo, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get repository permissions for a user
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetRepoPermissions(owner: string, repo: string, collaborator: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepoCollaboratorPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetRepoPermissions(owner, repo, collaborator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return all users that can be requested to review in this repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetReviewers(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetReviewers(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single commit from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha a git ref or commit sha
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetSingleCommit(owner: string, repo: string, sha: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Commit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetSingleCommit(owner, repo, sha, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the tag of a repository by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag name of tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetTag(owner: string, repo: string, tag: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetTag(owner, repo, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetWikiPage(owner: string, repo: string, pageName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WikiPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetWikiPage(owner, repo, pageName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get revisions of a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {number} [page] page number of results to return (1-based)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetWikiPageRevisions(owner: string, repo: string, pageName: string, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WikiCommitList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetWikiPageRevisions(owner, repo, pageName, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all wiki pages
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoGetWikiPages(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WikiPageMetaData>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoGetWikiPages(owner, repo, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get specified ref or filtered repository\'s refs
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListAllGitRefs(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Reference>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListAllGitRefs(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List branch protections for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListBranchProtection(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BranchProtection>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListBranchProtection(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repository\'s branches
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListBranches(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Branch>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListBranches(owner, repo, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repository\'s collaborators
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListCollaborators(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListCollaborators(owner, repo, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the Git hooks in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListGitHooks(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GitHook>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListGitHooks(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get specified ref or filtered repository\'s refs
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref part or full name of the ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListGitRefs(owner: string, repo: string, ref: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Reference>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListGitRefs(owner, repo, ref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the hooks in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListHooks(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Hook>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListHooks(owner, repo, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repository\'s keys
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [keyId] the key_id to search for
         * @param {string} [fingerprint] fingerprint of the key
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListKeys(owner: string, repo: string, keyId?: number, fingerprint?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeployKey>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListKeys(owner, repo, keyId, fingerprint, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repo\'s pull requests
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {'closed' | 'open' | 'all'} [state] State of pull request: open or closed (optional)
         * @param {'oldest' | 'recentupdate' | 'leastupdate' | 'mostcomment' | 'leastcomment' | 'priority'} [sort] Type of sort
         * @param {number} [milestone] ID of the milestone
         * @param {Array<number>} [labels] Label IDs
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListPullRequests(owner: string, repo: string, state?: 'closed' | 'open' | 'all', sort?: 'oldest' | 'recentupdate' | 'leastupdate' | 'mostcomment' | 'leastcomment' | 'priority', milestone?: number, labels?: Array<number>, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PullRequest>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListPullRequests(owner, repo, state, sort, milestone, labels, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all reviews for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListPullReviews(owner: string, repo: string, index: number, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PullReview>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListPullReviews(owner, repo, index, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List release\'s attachments
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListReleaseAttachments(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Attachment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListReleaseAttachments(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repo\'s releases
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {boolean} [draft] filter (exclude / include) drafts, if you dont have repo write access none will show
         * @param {boolean} [preRelease] filter (exclude / include) pre-releases
         * @param {number} [perPage] page size of results, deprecated - use limit
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListReleases(owner: string, repo: string, draft?: boolean, preRelease?: boolean, perPage?: number, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Release>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListReleases(owner, repo, draft, preRelease, perPage, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repo\'s stargazers
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListStargazers(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListStargazers(owner, repo, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a commit\'s statuses
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {'oldest' | 'recentupdate' | 'leastupdate' | 'leastindex' | 'highestindex'} [sort] type of sort
         * @param {'pending' | 'success' | 'error' | 'failure' | 'warning'} [state] type of state
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListStatuses(owner: string, repo: string, sha: string, sort?: 'oldest' | 'recentupdate' | 'leastupdate' | 'leastindex' | 'highestindex', state?: 'pending' | 'success' | 'error' | 'failure' | 'warning', page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CommitStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListStatuses(owner, repo, sha, sort, state, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a commit\'s statuses, by branch/tag/commit reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref name of branch/tag/commit
         * @param {'oldest' | 'recentupdate' | 'leastupdate' | 'leastindex' | 'highestindex'} [sort] type of sort
         * @param {'pending' | 'success' | 'error' | 'failure' | 'warning'} [state] type of state
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListStatusesByRef(owner: string, repo: string, ref: string, sort?: 'oldest' | 'recentupdate' | 'leastupdate' | 'leastindex' | 'highestindex', state?: 'pending' | 'success' | 'error' | 'failure' | 'warning', page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CommitStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListStatusesByRef(owner, repo, ref, sort, state, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repo\'s watchers
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListSubscribers(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListSubscribers(owner, repo, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repository\'s tags
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results, default maximum page size is 50
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListTags(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListTags(owner, repo, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repository\'s teams
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListTeams(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Team>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListTeams(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get list of topics that a repository has
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoListTopics(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TopicName>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoListTopics(owner, repo, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Merge a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to merge
         * @param {MergePullRequestOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoMergePullRequest(owner: string, repo: string, index: number, body?: MergePullRequestOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoMergePullRequest(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Migrate a remote git repository
         * @param {MigrateRepoOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoMigrate(body?: MigrateRepoOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoMigrate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Sync a mirrored repository
         * @param {string} owner owner of the repo to sync
         * @param {string} repo name of the repo to sync
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoMirrorSync(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoMirrorSync(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check if a pull request has been merged
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoPullRequestIsMerged(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoPullRequestIsMerged(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search for repositories
         * @param {string} [q] keyword
         * @param {boolean} [topic] Limit search to repositories with keyword as topic
         * @param {boolean} [includeDesc] include search of keyword within repository description (defaults to false)
         * @param {number} [uid] search only for repos that the user with the given id owns or contributes to
         * @param {number} [priorityOwnerId] repo owner to prioritize in the results
         * @param {number} [teamId] search only for repos that belong to the given team id
         * @param {number} [starredBy] search only for repos that the user with the given id has starred
         * @param {boolean} [_private] include private repositories this user has access to (defaults to true)
         * @param {boolean} [isPrivate] show only pubic, private or all repositories (defaults to all)
         * @param {boolean} [template] include template repositories this user has access to (defaults to true)
         * @param {boolean} [archived] show only archived, non-archived or all repositories (defaults to all)
         * @param {string} [mode] type of repository to search for. Supported values are \&quot;fork\&quot;, \&quot;source\&quot;, \&quot;mirror\&quot; and \&quot;collaborative\&quot;
         * @param {boolean} [exclusive] if &#x60;uid&#x60; is given, search only for repos that the user owns
         * @param {string} [repo] name of the repo. Multiple repo\&#39;s are ORed.
         * @param {string} [owner] owner of the repo. Multiple owner\&#39;s are ORed.
         * @param {string} [lang] If the repo is a resource of the given language(s), the repo will be in the results. Multiple lang\&#39;s are ORed.
         * @param {string} [subject] resource subject. Multiple subject\&#39;s are ORed.
         * @param {string} [book] book (project id) that exist in a resource. If the resource contains the the book, its repository will be included in the results. Multiple book\&#39;s are ORed.
         * @param {boolean} [includeMetadata] if false, q value will only be searched for in the repo name, owner, description and title and subject; otherwise search all values of the manifest file. (defaults to false)
         * @param {string} [sort] sort repos by attribute. Supported values are \&quot;alpha\&quot;, \&quot;created\&quot;, \&quot;updated\&quot;, \&quot;size\&quot;, and \&quot;id\&quot;. Default is \&quot;alpha\&quot;
         * @param {string} [order] sort order, either \&quot;asc\&quot; (ascending) or \&quot;desc\&quot; (descending). Default is \&quot;asc\&quot;, ignored if \&quot;sort\&quot; is not specified.
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoSearch(q?: string, topic?: boolean, includeDesc?: boolean, uid?: number, priorityOwnerId?: number, teamId?: number, starredBy?: number, _private?: boolean, isPrivate?: boolean, template?: boolean, archived?: boolean, mode?: string, exclusive?: boolean, repo?: string, owner?: string, lang?: string, subject?: string, book?: string, includeMetadata?: boolean, sort?: string, order?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchResults>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoSearch(q, topic, includeDesc, uid, priorityOwnerId, teamId, starredBy, _private, isPrivate, template, archived, mode, exclusive, repo, owner, lang, subject, book, includeMetadata, sort, order, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get signing-key.gpg for given repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoSigningKey(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoSigningKey(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Submit a pending review to an pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {SubmitPullReviewOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoSubmitPullReview(owner: string, repo: string, index: number, id: number, body: SubmitPullReviewOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoSubmitPullReview(owner, repo, index, id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Test a push webhook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to test
         * @param {string} [ref] The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoTestHook(owner: string, repo: string, id: number, ref?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoTestHook(owner, repo, id, ref, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repo\'s tracked times
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [user] optional filter by user (available for issue managers)
         * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoTrackedTimes(owner: string, repo: string, user?: string, since?: string, before?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TrackedTime>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoTrackedTimes(owner, repo, user, since, before, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Transfer a repo ownership
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {TransferRepoOption} body Transfer Options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoTransfer(owner: string, repo: string, body: TransferRepoOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoTransfer(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Cancel to dismiss a review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoUnDismissPullReview(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PullReview>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoUnDismissPullReview(owner, repo, index, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to update
         * @param {UpdateFileOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoUpdateFile(owner: string, repo: string, filepath: string, body: UpdateFileOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoUpdateFile(owner, repo, filepath, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref name of the ref to update
         * @param {UpdateGitRefOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoUpdateGitRef(owner: string, repo: string, ref: string, body?: UpdateGitRefOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoUpdateGitRef(owner, repo, ref, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Merge PR\'s baseBranch into headBranch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {'merge' | 'rebase'} [style] how to update pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoUpdatePullRequest(owner: string, repo: string, index: number, style?: 'merge' | 'rebase', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoUpdatePullRequest(owner, repo, index, style, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Replace list of topics for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {RepoTopicOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repoUpdateTopics(owner: string, repo: string, body?: RepoTopicOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repoUpdateTopics(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary search topics via keyword
         * @param {string} q keywords to search
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topicSearch(q: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TopicResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.topicSearch(q, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check if the current user is watching a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentCheckSubscription(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentCheckSubscription(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unwatch a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentDeleteSubscription(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentDeleteSubscription(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Watch a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentPutSubscription(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentPutSubscription(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a user\'s tracked times in a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} user username of user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async userTrackedTimes(owner: string, repo: string, user: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TrackedTime>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userTrackedTimes(owner, repo, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RepositoryApi - factory interface
 * @export
 */
export const RepositoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RepositoryApiFp(configuration)
    return {
        /**
         * 
         * @summary Accept a repo transfer
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptRepoTransfer(owner: string, repo: string, options?: any): AxiosPromise<Repository> {
            return localVarFp.acceptRepoTransfer(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a repository
         * @param {CreateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCurrentUserRepo(body?: CreateRepoOption, options?: any): AxiosPromise<Repository> {
            return localVarFp.createCurrentUserRepo(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fork a repository
         * @param {string} owner owner of the repo to fork
         * @param {string} repo name of the repo to fork
         * @param {CreateForkOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFork(owner: string, repo: string, body?: CreateForkOption, options?: any): AxiosPromise<Repository> {
            return localVarFp.createFork(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a repository using a template
         * @param {string} templateOwner name of the template repository owner
         * @param {string} templateRepo name of the template repository
         * @param {GenerateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateRepo(templateOwner: string, templateRepo: string, body?: GenerateRepoOption, options?: any): AxiosPromise<Repository> {
            return localVarFp.generateRepo(templateOwner, templateRepo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the tag object of an annotated tag (not lightweight tags)
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnotatedTag(owner: string, repo: string, sha: string, options?: any): AxiosPromise<AnnotatedTag> {
            return localVarFp.getAnnotatedTag(owner, repo, sha, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the blob of a repository.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlob(owner: string, repo: string, sha: string, options?: any): AxiosPromise<GitBlobResponse> {
            return localVarFp.getBlob(owner, repo, sha, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the tree of a repository.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {boolean} [recursive] show all directories and files
         * @param {number} [page] page number; the \&#39;truncated\&#39; field in the response will be true if there are still more items after this page, false if the last page
         * @param {number} [perPage] number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTree(owner: string, repo: string, sha: string, recursive?: boolean, page?: number, perPage?: number, options?: any): AxiosPromise<GitTreeResponse> {
            return localVarFp.getTree(owner, repo, sha, recursive, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repository\'s forks
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listForks(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Repository>> {
            return localVarFp.listForks(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reject a repo transfer
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectRepoTransfer(owner: string, repo: string, options?: any): AxiosPromise<Repository> {
            return localVarFp.rejectRepoTransfer(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a collaborator to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator to add
         * @param {AddCollaboratorOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoAddCollaborator(owner: string, repo: string, collaborator: string, body?: AddCollaboratorOption, options?: any): AxiosPromise<void> {
            return localVarFp.repoAddCollaborator(owner, repo, collaborator, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a team to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoAddTeam(owner: string, repo: string, team: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoAddTeam(owner, repo, team, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a topic to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} topic name of the topic to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoAddTopic(owner: string, repo: string, topic: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoAddTopic(owner, repo, topic, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Apply diff patch to repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {UpdateFileOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoApplyDiffPatch(owner: string, repo: string, body: UpdateFileOptions, options?: any): AxiosPromise<FileResponse> {
            return localVarFp.repoApplyDiffPatch(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancel the scheduled auto merge for the given pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to merge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCancelScheduledAutoMerge(owner: string, repo: string, index: number, options?: any): AxiosPromise<void> {
            return localVarFp.repoCancelScheduledAutoMerge(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if a user is a collaborator of a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCheckCollaborator(owner: string, repo: string, collaborator: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoCheckCollaborator(owner, repo, collaborator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if a team is assigned to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCheckTeam(owner: string, repo: string, team: string, options?: any): AxiosPromise<Team> {
            return localVarFp.repoCheckTeam(owner, repo, team, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a branch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateBranchRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateBranch(owner: string, repo: string, body?: CreateBranchRepoOption, options?: any): AxiosPromise<Branch> {
            return localVarFp.repoCreateBranch(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a branch protections for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateBranchProtectionOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateBranchProtection(owner: string, repo: string, body?: CreateBranchProtectionOption, options?: any): AxiosPromise<BranchProtection> {
            return localVarFp.repoCreateBranchProtection(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to create
         * @param {CreateFileOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateFile(owner: string, repo: string, filepath: string, body: CreateFileOptions, options?: any): AxiosPromise<FileResponse> {
            return localVarFp.repoCreateFile(owner, repo, filepath, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a reference for your repository. You are unable to create new references for empty repositories, even if the commit SHA-1 hash used exists. Empty repositories are repositories without branches.
         * @summary Create a reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateGitRefOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateGitRef(owner: string, repo: string, body?: CreateGitRefOption, options?: any): AxiosPromise<Reference> {
            return localVarFp.repoCreateGitRef(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateHook(owner: string, repo: string, body?: CreateHookOption, options?: any): AxiosPromise<Hook> {
            return localVarFp.repoCreateHook(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a key to a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateKeyOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateKey(owner: string, repo: string, body?: CreateKeyOption, options?: any): AxiosPromise<DeployKey> {
            return localVarFp.repoCreateKey(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreatePullRequestOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreatePullRequest(owner: string, repo: string, body?: CreatePullRequestOption, options?: any): AxiosPromise<PullRequest> {
            return localVarFp.repoCreatePullRequest(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a review to an pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {CreatePullReviewOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreatePullReview(owner: string, repo: string, index: number, body: CreatePullReviewOptions, options?: any): AxiosPromise<PullReview> {
            return localVarFp.repoCreatePullReview(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary create review requests for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {PullReviewRequestOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreatePullReviewRequests(owner: string, repo: string, index: number, body: PullReviewRequestOptions, options?: any): AxiosPromise<Array<PullReview>> {
            return localVarFp.repoCreatePullReviewRequests(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateReleaseOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateRelease(owner: string, repo: string, body?: CreateReleaseOption, options?: any): AxiosPromise<Release> {
            return localVarFp.repoCreateRelease(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {File} attachment attachment to upload
         * @param {string} [name] name of the attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateReleaseAttachment(owner: string, repo: string, id: number, attachment: File, name?: string, options?: any): AxiosPromise<Attachment> {
            return localVarFp.repoCreateReleaseAttachment(owner, repo, id, attachment, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a commit status
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {CreateStatusOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateStatus(owner: string, repo: string, sha: string, body?: CreateStatusOption, options?: any): AxiosPromise<CommitStatus> {
            return localVarFp.repoCreateStatus(owner, repo, sha, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new git tag in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateTagOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateTag(owner: string, repo: string, body?: CreateTagOption, options?: any): AxiosPromise<Tag> {
            return localVarFp.repoCreateTag(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateWikiPageOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoCreateWikiPage(owner: string, repo: string, body?: CreateWikiPageOptions, options?: any): AxiosPromise<WikiPage> {
            return localVarFp.repoCreateWikiPage(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a repository
         * @param {string} owner owner of the repo to delete
         * @param {string} repo name of the repo to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDelete(owner: string, repo: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoDelete(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a specific branch from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} branch branch to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteBranch(owner: string, repo: string, branch: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteBranch(owner, repo, branch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a specific branch protection for the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteBranchProtection(owner: string, repo: string, name: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteBranchProtection(owner, repo, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a collaborator from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteCollaborator(owner: string, repo: string, collaborator: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteCollaborator(owner, repo, collaborator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to delete
         * @param {DeleteFileOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteFile(owner: string, repo: string, filepath: string, body: DeleteFileOptions, options?: any): AxiosPromise<FileDeleteResponse> {
            return localVarFp.repoDeleteFile(owner, repo, filepath, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Git hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteGitHook(owner: string, repo: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteGitHook(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref name of the ref to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteGitRef(owner: string, repo: string, ref: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteGitRef(owner, repo, ref, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteHook(owner: string, repo: string, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteHook(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a key from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteKey(owner: string, repo: string, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteKey(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a specific review from a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeletePullReview(owner: string, repo: string, index: number, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeletePullReview(owner, repo, index, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary cancel review requests for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {PullReviewRequestOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeletePullReviewRequests(owner: string, repo: string, index: number, body: PullReviewRequestOptions, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeletePullReviewRequests(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteRelease(owner: string, repo: string, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteRelease(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteReleaseAttachment(owner, repo, id, attachmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a release by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag tag name of the release to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteReleaseByTag(owner: string, repo: string, tag: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteReleaseByTag(owner, repo, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a repository\'s tag by name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag name of tag to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteTag(owner: string, repo: string, tag: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteTag(owner, repo, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a team from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} team team name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteTeam(owner: string, repo: string, team: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteTeam(owner, repo, team, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a topic from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} topic name of the topic to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteTopic(owner: string, repo: string, topic: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteTopic(owner, repo, topic, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDeleteWikiPage(owner: string, repo: string, pageName: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoDeleteWikiPage(owner, repo, pageName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Dismiss a review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {DismissPullReviewOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDismissPullReview(owner: string, repo: string, index: number, id: number, body: DismissPullReviewOptions, options?: any): AxiosPromise<PullReview> {
            return localVarFp.repoDismissPullReview(owner, repo, index, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a commit\'s diff or patch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha SHA of the commit to get
         * @param {'diff' | 'patch'} diffType whether the output is diff or patch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDownloadCommitDiffOrPatch(owner: string, repo: string, sha: string, diffType: 'diff' | 'patch', options?: any): AxiosPromise<string> {
            return localVarFp.repoDownloadCommitDiffOrPatch(owner, repo, sha, diffType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a pull request diff or patch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {'diff' | 'patch'} diffType whether the output is diff or patch
         * @param {boolean} [binary] whether to include binary file changes. if true, the diff is applicable with &#x60;git apply&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoDownloadPullDiffOrPatch(owner: string, repo: string, index: number, diffType: 'diff' | 'patch', binary?: boolean, options?: any): AxiosPromise<string> {
            return localVarFp.repoDownloadPullDiffOrPatch(owner, repo, index, diffType, binary, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a repository\'s properties. Only fields that are set will be changed.
         * @param {string} owner owner of the repo to edit
         * @param {string} repo name of the repo to edit
         * @param {EditRepoOption} [body] Properties of a repo that you can edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEdit(owner: string, repo: string, body?: EditRepoOption, options?: any): AxiosPromise<Repository> {
            return localVarFp.repoEdit(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a branch protections for a repository. Only fields that are set will be changed
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {EditBranchProtectionOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditBranchProtection(owner: string, repo: string, name: string, body?: EditBranchProtectionOption, options?: any): AxiosPromise<BranchProtection> {
            return localVarFp.repoEditBranchProtection(owner, repo, name, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a Git hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {EditGitHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditGitHook(owner: string, repo: string, id: string, body?: EditGitHookOption, options?: any): AxiosPromise<GitHook> {
            return localVarFp.repoEditGitHook(owner, repo, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a hook in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id index of the hook
         * @param {EditHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditHook(owner: string, repo: string, id: number, body?: EditHookOption, options?: any): AxiosPromise<Hook> {
            return localVarFp.repoEditHook(owner, repo, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a pull request. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to edit
         * @param {EditPullRequestOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditPullRequest(owner: string, repo: string, index: number, body?: EditPullRequestOption, options?: any): AxiosPromise<PullRequest> {
            return localVarFp.repoEditPullRequest(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to edit
         * @param {EditReleaseOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditRelease(owner: string, repo: string, id: number, body?: EditReleaseOption, options?: any): AxiosPromise<Release> {
            return localVarFp.repoEditRelease(owner, repo, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to edit
         * @param {EditAttachmentOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, body?: EditAttachmentOptions, options?: any): AxiosPromise<Attachment> {
            return localVarFp.repoEditReleaseAttachment(owner, repo, id, attachmentId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {CreateWikiPageOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoEditWikiPage(owner: string, repo: string, pageName: string, body?: CreateWikiPageOptions, options?: any): AxiosPromise<WikiPage> {
            return localVarFp.repoEditWikiPage(owner, repo, pageName, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGet(owner: string, repo: string, options?: any): AxiosPromise<Repository> {
            return localVarFp.repoGet(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of all commits from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [sha] SHA or branch to start listing commits from (usually \&#39;master\&#39;)
         * @param {string} [path] filepath of a file/dir
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results (ignored if used with \&#39;path\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetAllCommits(owner: string, repo: string, sha?: string, path?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Commit>> {
            return localVarFp.repoGetAllCommits(owner, repo, sha, path, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an archive of a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} archive the git reference for download with attached archive format (e.g. master.zip)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetArchive(owner: string, repo: string, archive: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoGetArchive(owner, repo, archive, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return all users that have write access and can be assigned to issues
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetAssignees(owner: string, repo: string, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.repoGetAssignees(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a specific branch from a repository, including its effective branch protection
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} branch branch to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetBranch(owner: string, repo: string, branch: string, options?: any): AxiosPromise<Branch> {
            return localVarFp.repoGetBranch(owner, repo, branch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific branch protection for the repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} name name of protected branch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetBranchProtection(owner: string, repo: string, name: string, options?: any): AxiosPromise<BranchProtection> {
            return localVarFp.repoGetBranchProtection(owner, repo, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a repository by id
         * @param {number} id id of the repo to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetByID(id: number, options?: any): AxiosPromise<Repository> {
            return localVarFp.repoGetByID(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a commit\'s combined status, by branch/tag/commit reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref name of branch/tag/commit
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetCombinedStatusByRef(owner: string, repo: string, ref: string, page?: number, limit?: number, options?: any): AxiosPromise<CombinedStatus> {
            return localVarFp.repoGetCombinedStatusByRef(owner, repo, ref, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the dir, file, symlink or submodule in the repo
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetContents(owner: string, repo: string, filepath: string, ref?: string, options?: any): AxiosPromise<ContentsResponse> {
            return localVarFp.repoGetContents(owner, repo, filepath, ref, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the metadata of all the entries of the root dir
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetContentsList(owner: string, repo: string, ref?: string, options?: any): AxiosPromise<Array<ContentsResponse>> {
            return localVarFp.repoGetContentsList(owner, repo, ref, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the EditorConfig definitions of a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of file to get
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetEditorConfig(owner: string, repo: string, filepath: string, ref?: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoGetEditorConfig(owner, repo, filepath, ref, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Git hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetGitHook(owner: string, repo: string, id: string, options?: any): AxiosPromise<GitHook> {
            return localVarFp.repoGetGitHook(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a hook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetHook(owner: string, repo: string, id: number, options?: any): AxiosPromise<Hook> {
            return localVarFp.repoGetHook(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get available issue templates for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetIssueTemplates(owner: string, repo: string, options?: any): AxiosPromise<Array<IssueTemplate>> {
            return localVarFp.repoGetIssueTemplates(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a repository\'s key by id
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the key to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetKey(owner: string, repo: string, id: number, options?: any): AxiosPromise<DeployKey> {
            return localVarFp.repoGetKey(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get languages and number of bytes of code written
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetLanguages(owner: string, repo: string, options?: any): AxiosPromise<{ [key: string]: number; }> {
            return localVarFp.repoGetLanguages(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a note corresponding to a single commit from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha a git ref or commit sha
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetNote(owner: string, repo: string, sha: string, options?: any): AxiosPromise<Note> {
            return localVarFp.repoGetNote(owner, repo, sha, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPullRequest(owner: string, repo: string, index: number, options?: any): AxiosPromise<PullRequest> {
            return localVarFp.repoGetPullRequest(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get commits for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPullRequestCommits(owner: string, repo: string, index: number, page?: number, limit?: number, options?: any): AxiosPromise<Array<Commit>> {
            return localVarFp.repoGetPullRequestCommits(owner, repo, index, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPullReview(owner: string, repo: string, index: number, id: number, options?: any): AxiosPromise<PullReview> {
            return localVarFp.repoGetPullReview(owner, repo, index, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetPullReviewComments(owner: string, repo: string, index: number, id: number, options?: any): AxiosPromise<Array<PullReviewComment>> {
            return localVarFp.repoGetPullReviewComments(owner, repo, index, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a file from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of the file to get
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetRawFile(owner: string, repo: string, filepath: string, ref?: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoGetRawFile(owner, repo, filepath, ref, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a file or it\'s LFS object from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath filepath of the file to get
         * @param {string} [ref] The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetRawFileOrLFS(owner: string, repo: string, filepath: string, ref?: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoGetRawFileOrLFS(owner, repo, filepath, ref, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a release
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetRelease(owner: string, repo: string, id: number, options?: any): AxiosPromise<Release> {
            return localVarFp.repoGetRelease(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a release attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {number} attachmentId id of the attachment to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetReleaseAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: any): AxiosPromise<Attachment> {
            return localVarFp.repoGetReleaseAttachment(owner, repo, id, attachmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a release by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag tag name of the release to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetReleaseByTag(owner: string, repo: string, tag: string, options?: any): AxiosPromise<Release> {
            return localVarFp.repoGetReleaseByTag(owner, repo, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get repository permissions for a user
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} collaborator username of the collaborator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetRepoPermissions(owner: string, repo: string, collaborator: string, options?: any): AxiosPromise<RepoCollaboratorPermission> {
            return localVarFp.repoGetRepoPermissions(owner, repo, collaborator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return all users that can be requested to review in this repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetReviewers(owner: string, repo: string, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.repoGetReviewers(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single commit from a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha a git ref or commit sha
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetSingleCommit(owner: string, repo: string, sha: string, options?: any): AxiosPromise<Commit> {
            return localVarFp.repoGetSingleCommit(owner, repo, sha, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the tag of a repository by tag name
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} tag name of tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetTag(owner: string, repo: string, tag: string, options?: any): AxiosPromise<Tag> {
            return localVarFp.repoGetTag(owner, repo, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetWikiPage(owner: string, repo: string, pageName: string, options?: any): AxiosPromise<WikiPage> {
            return localVarFp.repoGetWikiPage(owner, repo, pageName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get revisions of a wiki page
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} pageName name of the page
         * @param {number} [page] page number of results to return (1-based)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetWikiPageRevisions(owner: string, repo: string, pageName: string, page?: number, options?: any): AxiosPromise<WikiCommitList> {
            return localVarFp.repoGetWikiPageRevisions(owner, repo, pageName, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all wiki pages
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoGetWikiPages(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<WikiPageMetaData>> {
            return localVarFp.repoGetWikiPages(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get specified ref or filtered repository\'s refs
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListAllGitRefs(owner: string, repo: string, options?: any): AxiosPromise<Array<Reference>> {
            return localVarFp.repoListAllGitRefs(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List branch protections for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListBranchProtection(owner: string, repo: string, options?: any): AxiosPromise<Array<BranchProtection>> {
            return localVarFp.repoListBranchProtection(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repository\'s branches
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListBranches(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Branch>> {
            return localVarFp.repoListBranches(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repository\'s collaborators
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListCollaborators(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.repoListCollaborators(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the Git hooks in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListGitHooks(owner: string, repo: string, options?: any): AxiosPromise<Array<GitHook>> {
            return localVarFp.repoListGitHooks(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get specified ref or filtered repository\'s refs
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref part or full name of the ref
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListGitRefs(owner: string, repo: string, ref: string, options?: any): AxiosPromise<Array<Reference>> {
            return localVarFp.repoListGitRefs(owner, repo, ref, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the hooks in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListHooks(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Hook>> {
            return localVarFp.repoListHooks(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repository\'s keys
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [keyId] the key_id to search for
         * @param {string} [fingerprint] fingerprint of the key
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListKeys(owner: string, repo: string, keyId?: number, fingerprint?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<DeployKey>> {
            return localVarFp.repoListKeys(owner, repo, keyId, fingerprint, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repo\'s pull requests
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {'closed' | 'open' | 'all'} [state] State of pull request: open or closed (optional)
         * @param {'oldest' | 'recentupdate' | 'leastupdate' | 'mostcomment' | 'leastcomment' | 'priority'} [sort] Type of sort
         * @param {number} [milestone] ID of the milestone
         * @param {Array<number>} [labels] Label IDs
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListPullRequests(owner: string, repo: string, state?: 'closed' | 'open' | 'all', sort?: 'oldest' | 'recentupdate' | 'leastupdate' | 'mostcomment' | 'leastcomment' | 'priority', milestone?: number, labels?: Array<number>, page?: number, limit?: number, options?: any): AxiosPromise<Array<PullRequest>> {
            return localVarFp.repoListPullRequests(owner, repo, state, sort, milestone, labels, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all reviews for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListPullReviews(owner: string, repo: string, index: number, page?: number, limit?: number, options?: any): AxiosPromise<Array<PullReview>> {
            return localVarFp.repoListPullReviews(owner, repo, index, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List release\'s attachments
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListReleaseAttachments(owner: string, repo: string, id: number, options?: any): AxiosPromise<Array<Attachment>> {
            return localVarFp.repoListReleaseAttachments(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repo\'s releases
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {boolean} [draft] filter (exclude / include) drafts, if you dont have repo write access none will show
         * @param {boolean} [preRelease] filter (exclude / include) pre-releases
         * @param {number} [perPage] page size of results, deprecated - use limit
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListReleases(owner: string, repo: string, draft?: boolean, preRelease?: boolean, perPage?: number, page?: number, limit?: number, options?: any): AxiosPromise<Array<Release>> {
            return localVarFp.repoListReleases(owner, repo, draft, preRelease, perPage, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repo\'s stargazers
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListStargazers(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.repoListStargazers(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a commit\'s statuses
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} sha sha of the commit
         * @param {'oldest' | 'recentupdate' | 'leastupdate' | 'leastindex' | 'highestindex'} [sort] type of sort
         * @param {'pending' | 'success' | 'error' | 'failure' | 'warning'} [state] type of state
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListStatuses(owner: string, repo: string, sha: string, sort?: 'oldest' | 'recentupdate' | 'leastupdate' | 'leastindex' | 'highestindex', state?: 'pending' | 'success' | 'error' | 'failure' | 'warning', page?: number, limit?: number, options?: any): AxiosPromise<Array<CommitStatus>> {
            return localVarFp.repoListStatuses(owner, repo, sha, sort, state, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a commit\'s statuses, by branch/tag/commit reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref name of branch/tag/commit
         * @param {'oldest' | 'recentupdate' | 'leastupdate' | 'leastindex' | 'highestindex'} [sort] type of sort
         * @param {'pending' | 'success' | 'error' | 'failure' | 'warning'} [state] type of state
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListStatusesByRef(owner: string, repo: string, ref: string, sort?: 'oldest' | 'recentupdate' | 'leastupdate' | 'leastindex' | 'highestindex', state?: 'pending' | 'success' | 'error' | 'failure' | 'warning', page?: number, limit?: number, options?: any): AxiosPromise<Array<CommitStatus>> {
            return localVarFp.repoListStatusesByRef(owner, repo, ref, sort, state, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repo\'s watchers
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListSubscribers(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.repoListSubscribers(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repository\'s tags
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results, default maximum page size is 50
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListTags(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.repoListTags(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repository\'s teams
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListTeams(owner: string, repo: string, options?: any): AxiosPromise<Array<Team>> {
            return localVarFp.repoListTeams(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get list of topics that a repository has
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoListTopics(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<TopicName> {
            return localVarFp.repoListTopics(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Merge a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to merge
         * @param {MergePullRequestOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoMergePullRequest(owner: string, repo: string, index: number, body?: MergePullRequestOption, options?: any): AxiosPromise<void> {
            return localVarFp.repoMergePullRequest(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Migrate a remote git repository
         * @param {MigrateRepoOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoMigrate(body?: MigrateRepoOptions, options?: any): AxiosPromise<Repository> {
            return localVarFp.repoMigrate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sync a mirrored repository
         * @param {string} owner owner of the repo to sync
         * @param {string} repo name of the repo to sync
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoMirrorSync(owner: string, repo: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoMirrorSync(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if a pull request has been merged
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoPullRequestIsMerged(owner: string, repo: string, index: number, options?: any): AxiosPromise<void> {
            return localVarFp.repoPullRequestIsMerged(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for repositories
         * @param {string} [q] keyword
         * @param {boolean} [topic] Limit search to repositories with keyword as topic
         * @param {boolean} [includeDesc] include search of keyword within repository description (defaults to false)
         * @param {number} [uid] search only for repos that the user with the given id owns or contributes to
         * @param {number} [priorityOwnerId] repo owner to prioritize in the results
         * @param {number} [teamId] search only for repos that belong to the given team id
         * @param {number} [starredBy] search only for repos that the user with the given id has starred
         * @param {boolean} [_private] include private repositories this user has access to (defaults to true)
         * @param {boolean} [isPrivate] show only pubic, private or all repositories (defaults to all)
         * @param {boolean} [template] include template repositories this user has access to (defaults to true)
         * @param {boolean} [archived] show only archived, non-archived or all repositories (defaults to all)
         * @param {string} [mode] type of repository to search for. Supported values are \&quot;fork\&quot;, \&quot;source\&quot;, \&quot;mirror\&quot; and \&quot;collaborative\&quot;
         * @param {boolean} [exclusive] if &#x60;uid&#x60; is given, search only for repos that the user owns
         * @param {string} [repo] name of the repo. Multiple repo\&#39;s are ORed.
         * @param {string} [owner] owner of the repo. Multiple owner\&#39;s are ORed.
         * @param {string} [lang] If the repo is a resource of the given language(s), the repo will be in the results. Multiple lang\&#39;s are ORed.
         * @param {string} [subject] resource subject. Multiple subject\&#39;s are ORed.
         * @param {string} [book] book (project id) that exist in a resource. If the resource contains the the book, its repository will be included in the results. Multiple book\&#39;s are ORed.
         * @param {boolean} [includeMetadata] if false, q value will only be searched for in the repo name, owner, description and title and subject; otherwise search all values of the manifest file. (defaults to false)
         * @param {string} [sort] sort repos by attribute. Supported values are \&quot;alpha\&quot;, \&quot;created\&quot;, \&quot;updated\&quot;, \&quot;size\&quot;, and \&quot;id\&quot;. Default is \&quot;alpha\&quot;
         * @param {string} [order] sort order, either \&quot;asc\&quot; (ascending) or \&quot;desc\&quot; (descending). Default is \&quot;asc\&quot;, ignored if \&quot;sort\&quot; is not specified.
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoSearch(q?: string, topic?: boolean, includeDesc?: boolean, uid?: number, priorityOwnerId?: number, teamId?: number, starredBy?: number, _private?: boolean, isPrivate?: boolean, template?: boolean, archived?: boolean, mode?: string, exclusive?: boolean, repo?: string, owner?: string, lang?: string, subject?: string, book?: string, includeMetadata?: boolean, sort?: string, order?: string, page?: number, limit?: number, options?: any): AxiosPromise<SearchResults> {
            return localVarFp.repoSearch(q, topic, includeDesc, uid, priorityOwnerId, teamId, starredBy, _private, isPrivate, template, archived, mode, exclusive, repo, owner, lang, subject, book, includeMetadata, sort, order, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get signing-key.gpg for given repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoSigningKey(owner: string, repo: string, options?: any): AxiosPromise<string> {
            return localVarFp.repoSigningKey(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Submit a pending review to an pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {SubmitPullReviewOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoSubmitPullReview(owner: string, repo: string, index: number, id: number, body: SubmitPullReviewOptions, options?: any): AxiosPromise<PullReview> {
            return localVarFp.repoSubmitPullReview(owner, repo, index, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Test a push webhook
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the hook to test
         * @param {string} [ref] The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoTestHook(owner: string, repo: string, id: number, ref?: string, options?: any): AxiosPromise<void> {
            return localVarFp.repoTestHook(owner, repo, id, ref, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repo\'s tracked times
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [user] optional filter by user (available for issue managers)
         * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoTrackedTimes(owner: string, repo: string, user?: string, since?: string, before?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<TrackedTime>> {
            return localVarFp.repoTrackedTimes(owner, repo, user, since, before, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Transfer a repo ownership
         * @param {string} owner owner of the repo to transfer
         * @param {string} repo name of the repo to transfer
         * @param {TransferRepoOption} body Transfer Options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoTransfer(owner: string, repo: string, body: TransferRepoOption, options?: any): AxiosPromise<Repository> {
            return localVarFp.repoTransfer(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancel to dismiss a review for a pull request
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request
         * @param {number} id id of the review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUnDismissPullReview(owner: string, repo: string, index: number, id: number, options?: any): AxiosPromise<PullReview> {
            return localVarFp.repoUnDismissPullReview(owner, repo, index, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a file in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} filepath path of the file to update
         * @param {UpdateFileOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUpdateFile(owner: string, repo: string, filepath: string, body: UpdateFileOptions, options?: any): AxiosPromise<FileResponse> {
            return localVarFp.repoUpdateFile(owner, repo, filepath, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a reference
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} ref name of the ref to update
         * @param {UpdateGitRefOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUpdateGitRef(owner: string, repo: string, ref: string, body?: UpdateGitRefOption, options?: any): AxiosPromise<Reference> {
            return localVarFp.repoUpdateGitRef(owner, repo, ref, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Merge PR\'s baseBranch into headBranch
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the pull request to get
         * @param {'merge' | 'rebase'} [style] how to update pull request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUpdatePullRequest(owner: string, repo: string, index: number, style?: 'merge' | 'rebase', options?: any): AxiosPromise<void> {
            return localVarFp.repoUpdatePullRequest(owner, repo, index, style, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Replace list of topics for a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {RepoTopicOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repoUpdateTopics(owner: string, repo: string, body?: RepoTopicOptions, options?: any): AxiosPromise<void> {
            return localVarFp.repoUpdateTopics(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary search topics via keyword
         * @param {string} q keywords to search
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topicSearch(q: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<TopicResponse>> {
            return localVarFp.topicSearch(q, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if the current user is watching a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentCheckSubscription(owner: string, repo: string, options?: any): AxiosPromise<WatchInfo> {
            return localVarFp.userCurrentCheckSubscription(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unwatch a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentDeleteSubscription(owner: string, repo: string, options?: any): AxiosPromise<void> {
            return localVarFp.userCurrentDeleteSubscription(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Watch a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentPutSubscription(owner: string, repo: string, options?: any): AxiosPromise<WatchInfo> {
            return localVarFp.userCurrentPutSubscription(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a user\'s tracked times in a repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} user username of user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        userTrackedTimes(owner: string, repo: string, user: string, options?: any): AxiosPromise<Array<TrackedTime>> {
            return localVarFp.userTrackedTimes(owner, repo, user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for acceptRepoTransfer operation in RepositoryApi.
 * @export
 * @interface RepositoryApiAcceptRepoTransferRequest
 */
export interface RepositoryApiAcceptRepoTransferRequest {
    /**
     * owner of the repo to transfer
     * @type {string}
     * @memberof RepositoryApiAcceptRepoTransfer
     */
    readonly owner: string

    /**
     * name of the repo to transfer
     * @type {string}
     * @memberof RepositoryApiAcceptRepoTransfer
     */
    readonly repo: string
}

/**
 * Request parameters for createCurrentUserRepo operation in RepositoryApi.
 * @export
 * @interface RepositoryApiCreateCurrentUserRepoRequest
 */
export interface RepositoryApiCreateCurrentUserRepoRequest {
    /**
     * 
     * @type {CreateRepoOption}
     * @memberof RepositoryApiCreateCurrentUserRepo
     */
    readonly body?: CreateRepoOption
}

/**
 * Request parameters for createFork operation in RepositoryApi.
 * @export
 * @interface RepositoryApiCreateForkRequest
 */
export interface RepositoryApiCreateForkRequest {
    /**
     * owner of the repo to fork
     * @type {string}
     * @memberof RepositoryApiCreateFork
     */
    readonly owner: string

    /**
     * name of the repo to fork
     * @type {string}
     * @memberof RepositoryApiCreateFork
     */
    readonly repo: string

    /**
     * 
     * @type {CreateForkOption}
     * @memberof RepositoryApiCreateFork
     */
    readonly body?: CreateForkOption
}

/**
 * Request parameters for generateRepo operation in RepositoryApi.
 * @export
 * @interface RepositoryApiGenerateRepoRequest
 */
export interface RepositoryApiGenerateRepoRequest {
    /**
     * name of the template repository owner
     * @type {string}
     * @memberof RepositoryApiGenerateRepo
     */
    readonly templateOwner: string

    /**
     * name of the template repository
     * @type {string}
     * @memberof RepositoryApiGenerateRepo
     */
    readonly templateRepo: string

    /**
     * 
     * @type {GenerateRepoOption}
     * @memberof RepositoryApiGenerateRepo
     */
    readonly body?: GenerateRepoOption
}

/**
 * Request parameters for getAnnotatedTag operation in RepositoryApi.
 * @export
 * @interface RepositoryApiGetAnnotatedTagRequest
 */
export interface RepositoryApiGetAnnotatedTagRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiGetAnnotatedTag
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiGetAnnotatedTag
     */
    readonly repo: string

    /**
     * sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.
     * @type {string}
     * @memberof RepositoryApiGetAnnotatedTag
     */
    readonly sha: string
}

/**
 * Request parameters for getBlob operation in RepositoryApi.
 * @export
 * @interface RepositoryApiGetBlobRequest
 */
export interface RepositoryApiGetBlobRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiGetBlob
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiGetBlob
     */
    readonly repo: string

    /**
     * sha of the commit
     * @type {string}
     * @memberof RepositoryApiGetBlob
     */
    readonly sha: string
}

/**
 * Request parameters for getTree operation in RepositoryApi.
 * @export
 * @interface RepositoryApiGetTreeRequest
 */
export interface RepositoryApiGetTreeRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiGetTree
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiGetTree
     */
    readonly repo: string

    /**
     * sha of the commit
     * @type {string}
     * @memberof RepositoryApiGetTree
     */
    readonly sha: string

    /**
     * show all directories and files
     * @type {boolean}
     * @memberof RepositoryApiGetTree
     */
    readonly recursive?: boolean

    /**
     * page number; the \&#39;truncated\&#39; field in the response will be true if there are still more items after this page, false if the last page
     * @type {number}
     * @memberof RepositoryApiGetTree
     */
    readonly page?: number

    /**
     * number of items per page
     * @type {number}
     * @memberof RepositoryApiGetTree
     */
    readonly perPage?: number
}

/**
 * Request parameters for listForks operation in RepositoryApi.
 * @export
 * @interface RepositoryApiListForksRequest
 */
export interface RepositoryApiListForksRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiListForks
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiListForks
     */
    readonly repo: string

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof RepositoryApiListForks
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof RepositoryApiListForks
     */
    readonly limit?: number
}

/**
 * Request parameters for rejectRepoTransfer operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRejectRepoTransferRequest
 */
export interface RepositoryApiRejectRepoTransferRequest {
    /**
     * owner of the repo to transfer
     * @type {string}
     * @memberof RepositoryApiRejectRepoTransfer
     */
    readonly owner: string

    /**
     * name of the repo to transfer
     * @type {string}
     * @memberof RepositoryApiRejectRepoTransfer
     */
    readonly repo: string
}

/**
 * Request parameters for repoAddCollaborator operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoAddCollaboratorRequest
 */
export interface RepositoryApiRepoAddCollaboratorRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoAddCollaborator
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoAddCollaborator
     */
    readonly repo: string

    /**
     * username of the collaborator to add
     * @type {string}
     * @memberof RepositoryApiRepoAddCollaborator
     */
    readonly collaborator: string

    /**
     * 
     * @type {AddCollaboratorOption}
     * @memberof RepositoryApiRepoAddCollaborator
     */
    readonly body?: AddCollaboratorOption
}

/**
 * Request parameters for repoAddTeam operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoAddTeamRequest
 */
export interface RepositoryApiRepoAddTeamRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoAddTeam
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoAddTeam
     */
    readonly repo: string

    /**
     * team name
     * @type {string}
     * @memberof RepositoryApiRepoAddTeam
     */
    readonly team: string
}

/**
 * Request parameters for repoAddTopic operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoAddTopicRequest
 */
export interface RepositoryApiRepoAddTopicRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoAddTopic
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoAddTopic
     */
    readonly repo: string

    /**
     * name of the topic to add
     * @type {string}
     * @memberof RepositoryApiRepoAddTopic
     */
    readonly topic: string
}

/**
 * Request parameters for repoApplyDiffPatch operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoApplyDiffPatchRequest
 */
export interface RepositoryApiRepoApplyDiffPatchRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoApplyDiffPatch
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoApplyDiffPatch
     */
    readonly repo: string

    /**
     * 
     * @type {UpdateFileOptions}
     * @memberof RepositoryApiRepoApplyDiffPatch
     */
    readonly body: UpdateFileOptions
}

/**
 * Request parameters for repoCancelScheduledAutoMerge operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoCancelScheduledAutoMergeRequest
 */
export interface RepositoryApiRepoCancelScheduledAutoMergeRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoCancelScheduledAutoMerge
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoCancelScheduledAutoMerge
     */
    readonly repo: string

    /**
     * index of the pull request to merge
     * @type {number}
     * @memberof RepositoryApiRepoCancelScheduledAutoMerge
     */
    readonly index: number
}

/**
 * Request parameters for repoCheckCollaborator operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoCheckCollaboratorRequest
 */
export interface RepositoryApiRepoCheckCollaboratorRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoCheckCollaborator
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoCheckCollaborator
     */
    readonly repo: string

    /**
     * username of the collaborator
     * @type {string}
     * @memberof RepositoryApiRepoCheckCollaborator
     */
    readonly collaborator: string
}

/**
 * Request parameters for repoCheckTeam operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoCheckTeamRequest
 */
export interface RepositoryApiRepoCheckTeamRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoCheckTeam
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoCheckTeam
     */
    readonly repo: string

    /**
     * team name
     * @type {string}
     * @memberof RepositoryApiRepoCheckTeam
     */
    readonly team: string
}

/**
 * Request parameters for repoCreateBranch operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoCreateBranchRequest
 */
export interface RepositoryApiRepoCreateBranchRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoCreateBranch
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoCreateBranch
     */
    readonly repo: string

    /**
     * 
     * @type {CreateBranchRepoOption}
     * @memberof RepositoryApiRepoCreateBranch
     */
    readonly body?: CreateBranchRepoOption
}

/**
 * Request parameters for repoCreateBranchProtection operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoCreateBranchProtectionRequest
 */
export interface RepositoryApiRepoCreateBranchProtectionRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoCreateBranchProtection
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoCreateBranchProtection
     */
    readonly repo: string

    /**
     * 
     * @type {CreateBranchProtectionOption}
     * @memberof RepositoryApiRepoCreateBranchProtection
     */
    readonly body?: CreateBranchProtectionOption
}

/**
 * Request parameters for repoCreateFile operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoCreateFileRequest
 */
export interface RepositoryApiRepoCreateFileRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoCreateFile
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoCreateFile
     */
    readonly repo: string

    /**
     * path of the file to create
     * @type {string}
     * @memberof RepositoryApiRepoCreateFile
     */
    readonly filepath: string

    /**
     * 
     * @type {CreateFileOptions}
     * @memberof RepositoryApiRepoCreateFile
     */
    readonly body: CreateFileOptions
}

/**
 * Request parameters for repoCreateGitRef operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoCreateGitRefRequest
 */
export interface RepositoryApiRepoCreateGitRefRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoCreateGitRef
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoCreateGitRef
     */
    readonly repo: string

    /**
     * 
     * @type {CreateGitRefOption}
     * @memberof RepositoryApiRepoCreateGitRef
     */
    readonly body?: CreateGitRefOption
}

/**
 * Request parameters for repoCreateHook operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoCreateHookRequest
 */
export interface RepositoryApiRepoCreateHookRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoCreateHook
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoCreateHook
     */
    readonly repo: string

    /**
     * 
     * @type {CreateHookOption}
     * @memberof RepositoryApiRepoCreateHook
     */
    readonly body?: CreateHookOption
}

/**
 * Request parameters for repoCreateKey operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoCreateKeyRequest
 */
export interface RepositoryApiRepoCreateKeyRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoCreateKey
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoCreateKey
     */
    readonly repo: string

    /**
     * 
     * @type {CreateKeyOption}
     * @memberof RepositoryApiRepoCreateKey
     */
    readonly body?: CreateKeyOption
}

/**
 * Request parameters for repoCreatePullRequest operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoCreatePullRequestRequest
 */
export interface RepositoryApiRepoCreatePullRequestRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoCreatePullRequest
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoCreatePullRequest
     */
    readonly repo: string

    /**
     * 
     * @type {CreatePullRequestOption}
     * @memberof RepositoryApiRepoCreatePullRequest
     */
    readonly body?: CreatePullRequestOption
}

/**
 * Request parameters for repoCreatePullReview operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoCreatePullReviewRequest
 */
export interface RepositoryApiRepoCreatePullReviewRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoCreatePullReview
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoCreatePullReview
     */
    readonly repo: string

    /**
     * index of the pull request
     * @type {number}
     * @memberof RepositoryApiRepoCreatePullReview
     */
    readonly index: number

    /**
     * 
     * @type {CreatePullReviewOptions}
     * @memberof RepositoryApiRepoCreatePullReview
     */
    readonly body: CreatePullReviewOptions
}

/**
 * Request parameters for repoCreatePullReviewRequests operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoCreatePullReviewRequestsRequest
 */
export interface RepositoryApiRepoCreatePullReviewRequestsRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoCreatePullReviewRequests
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoCreatePullReviewRequests
     */
    readonly repo: string

    /**
     * index of the pull request
     * @type {number}
     * @memberof RepositoryApiRepoCreatePullReviewRequests
     */
    readonly index: number

    /**
     * 
     * @type {PullReviewRequestOptions}
     * @memberof RepositoryApiRepoCreatePullReviewRequests
     */
    readonly body: PullReviewRequestOptions
}

/**
 * Request parameters for repoCreateRelease operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoCreateReleaseRequest
 */
export interface RepositoryApiRepoCreateReleaseRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoCreateRelease
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoCreateRelease
     */
    readonly repo: string

    /**
     * 
     * @type {CreateReleaseOption}
     * @memberof RepositoryApiRepoCreateRelease
     */
    readonly body?: CreateReleaseOption
}

/**
 * Request parameters for repoCreateReleaseAttachment operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoCreateReleaseAttachmentRequest
 */
export interface RepositoryApiRepoCreateReleaseAttachmentRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoCreateReleaseAttachment
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoCreateReleaseAttachment
     */
    readonly repo: string

    /**
     * id of the release
     * @type {number}
     * @memberof RepositoryApiRepoCreateReleaseAttachment
     */
    readonly id: number

    /**
     * attachment to upload
     * @type {File}
     * @memberof RepositoryApiRepoCreateReleaseAttachment
     */
    readonly attachment: File

    /**
     * name of the attachment
     * @type {string}
     * @memberof RepositoryApiRepoCreateReleaseAttachment
     */
    readonly name?: string
}

/**
 * Request parameters for repoCreateStatus operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoCreateStatusRequest
 */
export interface RepositoryApiRepoCreateStatusRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoCreateStatus
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoCreateStatus
     */
    readonly repo: string

    /**
     * sha of the commit
     * @type {string}
     * @memberof RepositoryApiRepoCreateStatus
     */
    readonly sha: string

    /**
     * 
     * @type {CreateStatusOption}
     * @memberof RepositoryApiRepoCreateStatus
     */
    readonly body?: CreateStatusOption
}

/**
 * Request parameters for repoCreateTag operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoCreateTagRequest
 */
export interface RepositoryApiRepoCreateTagRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoCreateTag
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoCreateTag
     */
    readonly repo: string

    /**
     * 
     * @type {CreateTagOption}
     * @memberof RepositoryApiRepoCreateTag
     */
    readonly body?: CreateTagOption
}

/**
 * Request parameters for repoCreateWikiPage operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoCreateWikiPageRequest
 */
export interface RepositoryApiRepoCreateWikiPageRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoCreateWikiPage
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoCreateWikiPage
     */
    readonly repo: string

    /**
     * 
     * @type {CreateWikiPageOptions}
     * @memberof RepositoryApiRepoCreateWikiPage
     */
    readonly body?: CreateWikiPageOptions
}

/**
 * Request parameters for repoDelete operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoDeleteRequest
 */
export interface RepositoryApiRepoDeleteRequest {
    /**
     * owner of the repo to delete
     * @type {string}
     * @memberof RepositoryApiRepoDelete
     */
    readonly owner: string

    /**
     * name of the repo to delete
     * @type {string}
     * @memberof RepositoryApiRepoDelete
     */
    readonly repo: string
}

/**
 * Request parameters for repoDeleteBranch operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoDeleteBranchRequest
 */
export interface RepositoryApiRepoDeleteBranchRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDeleteBranch
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDeleteBranch
     */
    readonly repo: string

    /**
     * branch to delete
     * @type {string}
     * @memberof RepositoryApiRepoDeleteBranch
     */
    readonly branch: string
}

/**
 * Request parameters for repoDeleteBranchProtection operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoDeleteBranchProtectionRequest
 */
export interface RepositoryApiRepoDeleteBranchProtectionRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDeleteBranchProtection
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDeleteBranchProtection
     */
    readonly repo: string

    /**
     * name of protected branch
     * @type {string}
     * @memberof RepositoryApiRepoDeleteBranchProtection
     */
    readonly name: string
}

/**
 * Request parameters for repoDeleteCollaborator operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoDeleteCollaboratorRequest
 */
export interface RepositoryApiRepoDeleteCollaboratorRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDeleteCollaborator
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDeleteCollaborator
     */
    readonly repo: string

    /**
     * username of the collaborator to delete
     * @type {string}
     * @memberof RepositoryApiRepoDeleteCollaborator
     */
    readonly collaborator: string
}

/**
 * Request parameters for repoDeleteFile operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoDeleteFileRequest
 */
export interface RepositoryApiRepoDeleteFileRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDeleteFile
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDeleteFile
     */
    readonly repo: string

    /**
     * path of the file to delete
     * @type {string}
     * @memberof RepositoryApiRepoDeleteFile
     */
    readonly filepath: string

    /**
     * 
     * @type {DeleteFileOptions}
     * @memberof RepositoryApiRepoDeleteFile
     */
    readonly body: DeleteFileOptions
}

/**
 * Request parameters for repoDeleteGitHook operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoDeleteGitHookRequest
 */
export interface RepositoryApiRepoDeleteGitHookRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDeleteGitHook
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDeleteGitHook
     */
    readonly repo: string

    /**
     * id of the hook to get
     * @type {string}
     * @memberof RepositoryApiRepoDeleteGitHook
     */
    readonly id: string
}

/**
 * Request parameters for repoDeleteGitRef operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoDeleteGitRefRequest
 */
export interface RepositoryApiRepoDeleteGitRefRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDeleteGitRef
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDeleteGitRef
     */
    readonly repo: string

    /**
     * name of the ref to be deleted
     * @type {string}
     * @memberof RepositoryApiRepoDeleteGitRef
     */
    readonly ref: string
}

/**
 * Request parameters for repoDeleteHook operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoDeleteHookRequest
 */
export interface RepositoryApiRepoDeleteHookRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDeleteHook
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDeleteHook
     */
    readonly repo: string

    /**
     * id of the hook to delete
     * @type {number}
     * @memberof RepositoryApiRepoDeleteHook
     */
    readonly id: number
}

/**
 * Request parameters for repoDeleteKey operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoDeleteKeyRequest
 */
export interface RepositoryApiRepoDeleteKeyRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDeleteKey
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDeleteKey
     */
    readonly repo: string

    /**
     * id of the key to delete
     * @type {number}
     * @memberof RepositoryApiRepoDeleteKey
     */
    readonly id: number
}

/**
 * Request parameters for repoDeletePullReview operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoDeletePullReviewRequest
 */
export interface RepositoryApiRepoDeletePullReviewRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDeletePullReview
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDeletePullReview
     */
    readonly repo: string

    /**
     * index of the pull request
     * @type {number}
     * @memberof RepositoryApiRepoDeletePullReview
     */
    readonly index: number

    /**
     * id of the review
     * @type {number}
     * @memberof RepositoryApiRepoDeletePullReview
     */
    readonly id: number
}

/**
 * Request parameters for repoDeletePullReviewRequests operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoDeletePullReviewRequestsRequest
 */
export interface RepositoryApiRepoDeletePullReviewRequestsRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDeletePullReviewRequests
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDeletePullReviewRequests
     */
    readonly repo: string

    /**
     * index of the pull request
     * @type {number}
     * @memberof RepositoryApiRepoDeletePullReviewRequests
     */
    readonly index: number

    /**
     * 
     * @type {PullReviewRequestOptions}
     * @memberof RepositoryApiRepoDeletePullReviewRequests
     */
    readonly body: PullReviewRequestOptions
}

/**
 * Request parameters for repoDeleteRelease operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoDeleteReleaseRequest
 */
export interface RepositoryApiRepoDeleteReleaseRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDeleteRelease
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDeleteRelease
     */
    readonly repo: string

    /**
     * id of the release to delete
     * @type {number}
     * @memberof RepositoryApiRepoDeleteRelease
     */
    readonly id: number
}

/**
 * Request parameters for repoDeleteReleaseAttachment operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoDeleteReleaseAttachmentRequest
 */
export interface RepositoryApiRepoDeleteReleaseAttachmentRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDeleteReleaseAttachment
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDeleteReleaseAttachment
     */
    readonly repo: string

    /**
     * id of the release
     * @type {number}
     * @memberof RepositoryApiRepoDeleteReleaseAttachment
     */
    readonly id: number

    /**
     * id of the attachment to delete
     * @type {number}
     * @memberof RepositoryApiRepoDeleteReleaseAttachment
     */
    readonly attachmentId: number
}

/**
 * Request parameters for repoDeleteReleaseByTag operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoDeleteReleaseByTagRequest
 */
export interface RepositoryApiRepoDeleteReleaseByTagRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDeleteReleaseByTag
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDeleteReleaseByTag
     */
    readonly repo: string

    /**
     * tag name of the release to delete
     * @type {string}
     * @memberof RepositoryApiRepoDeleteReleaseByTag
     */
    readonly tag: string
}

/**
 * Request parameters for repoDeleteTag operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoDeleteTagRequest
 */
export interface RepositoryApiRepoDeleteTagRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDeleteTag
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDeleteTag
     */
    readonly repo: string

    /**
     * name of tag to delete
     * @type {string}
     * @memberof RepositoryApiRepoDeleteTag
     */
    readonly tag: string
}

/**
 * Request parameters for repoDeleteTeam operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoDeleteTeamRequest
 */
export interface RepositoryApiRepoDeleteTeamRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDeleteTeam
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDeleteTeam
     */
    readonly repo: string

    /**
     * team name
     * @type {string}
     * @memberof RepositoryApiRepoDeleteTeam
     */
    readonly team: string
}

/**
 * Request parameters for repoDeleteTopic operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoDeleteTopicRequest
 */
export interface RepositoryApiRepoDeleteTopicRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDeleteTopic
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDeleteTopic
     */
    readonly repo: string

    /**
     * name of the topic to delete
     * @type {string}
     * @memberof RepositoryApiRepoDeleteTopic
     */
    readonly topic: string
}

/**
 * Request parameters for repoDeleteWikiPage operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoDeleteWikiPageRequest
 */
export interface RepositoryApiRepoDeleteWikiPageRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDeleteWikiPage
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDeleteWikiPage
     */
    readonly repo: string

    /**
     * name of the page
     * @type {string}
     * @memberof RepositoryApiRepoDeleteWikiPage
     */
    readonly pageName: string
}

/**
 * Request parameters for repoDismissPullReview operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoDismissPullReviewRequest
 */
export interface RepositoryApiRepoDismissPullReviewRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDismissPullReview
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDismissPullReview
     */
    readonly repo: string

    /**
     * index of the pull request
     * @type {number}
     * @memberof RepositoryApiRepoDismissPullReview
     */
    readonly index: number

    /**
     * id of the review
     * @type {number}
     * @memberof RepositoryApiRepoDismissPullReview
     */
    readonly id: number

    /**
     * 
     * @type {DismissPullReviewOptions}
     * @memberof RepositoryApiRepoDismissPullReview
     */
    readonly body: DismissPullReviewOptions
}

/**
 * Request parameters for repoDownloadCommitDiffOrPatch operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoDownloadCommitDiffOrPatchRequest
 */
export interface RepositoryApiRepoDownloadCommitDiffOrPatchRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDownloadCommitDiffOrPatch
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDownloadCommitDiffOrPatch
     */
    readonly repo: string

    /**
     * SHA of the commit to get
     * @type {string}
     * @memberof RepositoryApiRepoDownloadCommitDiffOrPatch
     */
    readonly sha: string

    /**
     * whether the output is diff or patch
     * @type {'diff' | 'patch'}
     * @memberof RepositoryApiRepoDownloadCommitDiffOrPatch
     */
    readonly diffType: 'diff' | 'patch'
}

/**
 * Request parameters for repoDownloadPullDiffOrPatch operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoDownloadPullDiffOrPatchRequest
 */
export interface RepositoryApiRepoDownloadPullDiffOrPatchRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDownloadPullDiffOrPatch
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoDownloadPullDiffOrPatch
     */
    readonly repo: string

    /**
     * index of the pull request to get
     * @type {number}
     * @memberof RepositoryApiRepoDownloadPullDiffOrPatch
     */
    readonly index: number

    /**
     * whether the output is diff or patch
     * @type {'diff' | 'patch'}
     * @memberof RepositoryApiRepoDownloadPullDiffOrPatch
     */
    readonly diffType: 'diff' | 'patch'

    /**
     * whether to include binary file changes. if true, the diff is applicable with &#x60;git apply&#x60;
     * @type {boolean}
     * @memberof RepositoryApiRepoDownloadPullDiffOrPatch
     */
    readonly binary?: boolean
}

/**
 * Request parameters for repoEdit operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoEditRequest
 */
export interface RepositoryApiRepoEditRequest {
    /**
     * owner of the repo to edit
     * @type {string}
     * @memberof RepositoryApiRepoEdit
     */
    readonly owner: string

    /**
     * name of the repo to edit
     * @type {string}
     * @memberof RepositoryApiRepoEdit
     */
    readonly repo: string

    /**
     * Properties of a repo that you can edit
     * @type {EditRepoOption}
     * @memberof RepositoryApiRepoEdit
     */
    readonly body?: EditRepoOption
}

/**
 * Request parameters for repoEditBranchProtection operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoEditBranchProtectionRequest
 */
export interface RepositoryApiRepoEditBranchProtectionRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoEditBranchProtection
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoEditBranchProtection
     */
    readonly repo: string

    /**
     * name of protected branch
     * @type {string}
     * @memberof RepositoryApiRepoEditBranchProtection
     */
    readonly name: string

    /**
     * 
     * @type {EditBranchProtectionOption}
     * @memberof RepositoryApiRepoEditBranchProtection
     */
    readonly body?: EditBranchProtectionOption
}

/**
 * Request parameters for repoEditGitHook operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoEditGitHookRequest
 */
export interface RepositoryApiRepoEditGitHookRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoEditGitHook
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoEditGitHook
     */
    readonly repo: string

    /**
     * id of the hook to get
     * @type {string}
     * @memberof RepositoryApiRepoEditGitHook
     */
    readonly id: string

    /**
     * 
     * @type {EditGitHookOption}
     * @memberof RepositoryApiRepoEditGitHook
     */
    readonly body?: EditGitHookOption
}

/**
 * Request parameters for repoEditHook operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoEditHookRequest
 */
export interface RepositoryApiRepoEditHookRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoEditHook
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoEditHook
     */
    readonly repo: string

    /**
     * index of the hook
     * @type {number}
     * @memberof RepositoryApiRepoEditHook
     */
    readonly id: number

    /**
     * 
     * @type {EditHookOption}
     * @memberof RepositoryApiRepoEditHook
     */
    readonly body?: EditHookOption
}

/**
 * Request parameters for repoEditPullRequest operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoEditPullRequestRequest
 */
export interface RepositoryApiRepoEditPullRequestRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoEditPullRequest
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoEditPullRequest
     */
    readonly repo: string

    /**
     * index of the pull request to edit
     * @type {number}
     * @memberof RepositoryApiRepoEditPullRequest
     */
    readonly index: number

    /**
     * 
     * @type {EditPullRequestOption}
     * @memberof RepositoryApiRepoEditPullRequest
     */
    readonly body?: EditPullRequestOption
}

/**
 * Request parameters for repoEditRelease operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoEditReleaseRequest
 */
export interface RepositoryApiRepoEditReleaseRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoEditRelease
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoEditRelease
     */
    readonly repo: string

    /**
     * id of the release to edit
     * @type {number}
     * @memberof RepositoryApiRepoEditRelease
     */
    readonly id: number

    /**
     * 
     * @type {EditReleaseOption}
     * @memberof RepositoryApiRepoEditRelease
     */
    readonly body?: EditReleaseOption
}

/**
 * Request parameters for repoEditReleaseAttachment operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoEditReleaseAttachmentRequest
 */
export interface RepositoryApiRepoEditReleaseAttachmentRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoEditReleaseAttachment
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoEditReleaseAttachment
     */
    readonly repo: string

    /**
     * id of the release
     * @type {number}
     * @memberof RepositoryApiRepoEditReleaseAttachment
     */
    readonly id: number

    /**
     * id of the attachment to edit
     * @type {number}
     * @memberof RepositoryApiRepoEditReleaseAttachment
     */
    readonly attachmentId: number

    /**
     * 
     * @type {EditAttachmentOptions}
     * @memberof RepositoryApiRepoEditReleaseAttachment
     */
    readonly body?: EditAttachmentOptions
}

/**
 * Request parameters for repoEditWikiPage operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoEditWikiPageRequest
 */
export interface RepositoryApiRepoEditWikiPageRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoEditWikiPage
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoEditWikiPage
     */
    readonly repo: string

    /**
     * name of the page
     * @type {string}
     * @memberof RepositoryApiRepoEditWikiPage
     */
    readonly pageName: string

    /**
     * 
     * @type {CreateWikiPageOptions}
     * @memberof RepositoryApiRepoEditWikiPage
     */
    readonly body?: CreateWikiPageOptions
}

/**
 * Request parameters for repoGet operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoGetRequest
 */
export interface RepositoryApiRepoGetRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGet
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGet
     */
    readonly repo: string
}

/**
 * Request parameters for repoGetAllCommits operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoGetAllCommitsRequest
 */
export interface RepositoryApiRepoGetAllCommitsRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetAllCommits
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetAllCommits
     */
    readonly repo: string

    /**
     * SHA or branch to start listing commits from (usually \&#39;master\&#39;)
     * @type {string}
     * @memberof RepositoryApiRepoGetAllCommits
     */
    readonly sha?: string

    /**
     * filepath of a file/dir
     * @type {string}
     * @memberof RepositoryApiRepoGetAllCommits
     */
    readonly path?: string

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof RepositoryApiRepoGetAllCommits
     */
    readonly page?: number

    /**
     * page size of results (ignored if used with \&#39;path\&#39;)
     * @type {number}
     * @memberof RepositoryApiRepoGetAllCommits
     */
    readonly limit?: number
}

/**
 * Request parameters for repoGetArchive operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoGetArchiveRequest
 */
export interface RepositoryApiRepoGetArchiveRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetArchive
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetArchive
     */
    readonly repo: string

    /**
     * the git reference for download with attached archive format (e.g. master.zip)
     * @type {string}
     * @memberof RepositoryApiRepoGetArchive
     */
    readonly archive: string
}

/**
 * Request parameters for repoGetAssignees operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoGetAssigneesRequest
 */
export interface RepositoryApiRepoGetAssigneesRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetAssignees
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetAssignees
     */
    readonly repo: string
}

/**
 * Request parameters for repoGetBranch operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoGetBranchRequest
 */
export interface RepositoryApiRepoGetBranchRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetBranch
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetBranch
     */
    readonly repo: string

    /**
     * branch to get
     * @type {string}
     * @memberof RepositoryApiRepoGetBranch
     */
    readonly branch: string
}

/**
 * Request parameters for repoGetBranchProtection operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoGetBranchProtectionRequest
 */
export interface RepositoryApiRepoGetBranchProtectionRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetBranchProtection
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetBranchProtection
     */
    readonly repo: string

    /**
     * name of protected branch
     * @type {string}
     * @memberof RepositoryApiRepoGetBranchProtection
     */
    readonly name: string
}

/**
 * Request parameters for repoGetByID operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoGetByIDRequest
 */
export interface RepositoryApiRepoGetByIDRequest {
    /**
     * id of the repo to get
     * @type {number}
     * @memberof RepositoryApiRepoGetByID
     */
    readonly id: number
}

/**
 * Request parameters for repoGetCombinedStatusByRef operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoGetCombinedStatusByRefRequest
 */
export interface RepositoryApiRepoGetCombinedStatusByRefRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetCombinedStatusByRef
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetCombinedStatusByRef
     */
    readonly repo: string

    /**
     * name of branch/tag/commit
     * @type {string}
     * @memberof RepositoryApiRepoGetCombinedStatusByRef
     */
    readonly ref: string

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof RepositoryApiRepoGetCombinedStatusByRef
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof RepositoryApiRepoGetCombinedStatusByRef
     */
    readonly limit?: number
}

/**
 * Request parameters for repoGetContents operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoGetContentsRequest
 */
export interface RepositoryApiRepoGetContentsRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetContents
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetContents
     */
    readonly repo: string

    /**
     * path of the dir, file, symlink or submodule in the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetContents
     */
    readonly filepath: string

    /**
     * The name of the commit/branch/tag. Default the repositorys default branch (usually master)
     * @type {string}
     * @memberof RepositoryApiRepoGetContents
     */
    readonly ref?: string
}

/**
 * Request parameters for repoGetContentsList operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoGetContentsListRequest
 */
export interface RepositoryApiRepoGetContentsListRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetContentsList
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetContentsList
     */
    readonly repo: string

    /**
     * The name of the commit/branch/tag. Default the repositorys default branch (usually master)
     * @type {string}
     * @memberof RepositoryApiRepoGetContentsList
     */
    readonly ref?: string
}

/**
 * Request parameters for repoGetEditorConfig operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoGetEditorConfigRequest
 */
export interface RepositoryApiRepoGetEditorConfigRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetEditorConfig
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetEditorConfig
     */
    readonly repo: string

    /**
     * filepath of file to get
     * @type {string}
     * @memberof RepositoryApiRepoGetEditorConfig
     */
    readonly filepath: string

    /**
     * The name of the commit/branch/tag. Default the repositorys default branch (usually master)
     * @type {string}
     * @memberof RepositoryApiRepoGetEditorConfig
     */
    readonly ref?: string
}

/**
 * Request parameters for repoGetGitHook operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoGetGitHookRequest
 */
export interface RepositoryApiRepoGetGitHookRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetGitHook
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetGitHook
     */
    readonly repo: string

    /**
     * id of the hook to get
     * @type {string}
     * @memberof RepositoryApiRepoGetGitHook
     */
    readonly id: string
}

/**
 * Request parameters for repoGetHook operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoGetHookRequest
 */
export interface RepositoryApiRepoGetHookRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetHook
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetHook
     */
    readonly repo: string

    /**
     * id of the hook to get
     * @type {number}
     * @memberof RepositoryApiRepoGetHook
     */
    readonly id: number
}

/**
 * Request parameters for repoGetIssueTemplates operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoGetIssueTemplatesRequest
 */
export interface RepositoryApiRepoGetIssueTemplatesRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetIssueTemplates
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetIssueTemplates
     */
    readonly repo: string
}

/**
 * Request parameters for repoGetKey operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoGetKeyRequest
 */
export interface RepositoryApiRepoGetKeyRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetKey
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetKey
     */
    readonly repo: string

    /**
     * id of the key to get
     * @type {number}
     * @memberof RepositoryApiRepoGetKey
     */
    readonly id: number
}

/**
 * Request parameters for repoGetLanguages operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoGetLanguagesRequest
 */
export interface RepositoryApiRepoGetLanguagesRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetLanguages
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetLanguages
     */
    readonly repo: string
}

/**
 * Request parameters for repoGetNote operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoGetNoteRequest
 */
export interface RepositoryApiRepoGetNoteRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetNote
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetNote
     */
    readonly repo: string

    /**
     * a git ref or commit sha
     * @type {string}
     * @memberof RepositoryApiRepoGetNote
     */
    readonly sha: string
}

/**
 * Request parameters for repoGetPullRequest operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoGetPullRequestRequest
 */
export interface RepositoryApiRepoGetPullRequestRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetPullRequest
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetPullRequest
     */
    readonly repo: string

    /**
     * index of the pull request to get
     * @type {number}
     * @memberof RepositoryApiRepoGetPullRequest
     */
    readonly index: number
}

/**
 * Request parameters for repoGetPullRequestCommits operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoGetPullRequestCommitsRequest
 */
export interface RepositoryApiRepoGetPullRequestCommitsRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetPullRequestCommits
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetPullRequestCommits
     */
    readonly repo: string

    /**
     * index of the pull request to get
     * @type {number}
     * @memberof RepositoryApiRepoGetPullRequestCommits
     */
    readonly index: number

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof RepositoryApiRepoGetPullRequestCommits
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof RepositoryApiRepoGetPullRequestCommits
     */
    readonly limit?: number
}

/**
 * Request parameters for repoGetPullReview operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoGetPullReviewRequest
 */
export interface RepositoryApiRepoGetPullReviewRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetPullReview
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetPullReview
     */
    readonly repo: string

    /**
     * index of the pull request
     * @type {number}
     * @memberof RepositoryApiRepoGetPullReview
     */
    readonly index: number

    /**
     * id of the review
     * @type {number}
     * @memberof RepositoryApiRepoGetPullReview
     */
    readonly id: number
}

/**
 * Request parameters for repoGetPullReviewComments operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoGetPullReviewCommentsRequest
 */
export interface RepositoryApiRepoGetPullReviewCommentsRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetPullReviewComments
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetPullReviewComments
     */
    readonly repo: string

    /**
     * index of the pull request
     * @type {number}
     * @memberof RepositoryApiRepoGetPullReviewComments
     */
    readonly index: number

    /**
     * id of the review
     * @type {number}
     * @memberof RepositoryApiRepoGetPullReviewComments
     */
    readonly id: number
}

/**
 * Request parameters for repoGetRawFile operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoGetRawFileRequest
 */
export interface RepositoryApiRepoGetRawFileRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetRawFile
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetRawFile
     */
    readonly repo: string

    /**
     * filepath of the file to get
     * @type {string}
     * @memberof RepositoryApiRepoGetRawFile
     */
    readonly filepath: string

    /**
     * The name of the commit/branch/tag. Default the repositorys default branch (usually master)
     * @type {string}
     * @memberof RepositoryApiRepoGetRawFile
     */
    readonly ref?: string
}

/**
 * Request parameters for repoGetRawFileOrLFS operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoGetRawFileOrLFSRequest
 */
export interface RepositoryApiRepoGetRawFileOrLFSRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetRawFileOrLFS
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetRawFileOrLFS
     */
    readonly repo: string

    /**
     * filepath of the file to get
     * @type {string}
     * @memberof RepositoryApiRepoGetRawFileOrLFS
     */
    readonly filepath: string

    /**
     * The name of the commit/branch/tag. Default the repositorys default branch (usually master)
     * @type {string}
     * @memberof RepositoryApiRepoGetRawFileOrLFS
     */
    readonly ref?: string
}

/**
 * Request parameters for repoGetRelease operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoGetReleaseRequest
 */
export interface RepositoryApiRepoGetReleaseRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetRelease
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetRelease
     */
    readonly repo: string

    /**
     * id of the release to get
     * @type {number}
     * @memberof RepositoryApiRepoGetRelease
     */
    readonly id: number
}

/**
 * Request parameters for repoGetReleaseAttachment operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoGetReleaseAttachmentRequest
 */
export interface RepositoryApiRepoGetReleaseAttachmentRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetReleaseAttachment
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetReleaseAttachment
     */
    readonly repo: string

    /**
     * id of the release
     * @type {number}
     * @memberof RepositoryApiRepoGetReleaseAttachment
     */
    readonly id: number

    /**
     * id of the attachment to get
     * @type {number}
     * @memberof RepositoryApiRepoGetReleaseAttachment
     */
    readonly attachmentId: number
}

/**
 * Request parameters for repoGetReleaseByTag operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoGetReleaseByTagRequest
 */
export interface RepositoryApiRepoGetReleaseByTagRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetReleaseByTag
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetReleaseByTag
     */
    readonly repo: string

    /**
     * tag name of the release to get
     * @type {string}
     * @memberof RepositoryApiRepoGetReleaseByTag
     */
    readonly tag: string
}

/**
 * Request parameters for repoGetRepoPermissions operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoGetRepoPermissionsRequest
 */
export interface RepositoryApiRepoGetRepoPermissionsRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetRepoPermissions
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetRepoPermissions
     */
    readonly repo: string

    /**
     * username of the collaborator
     * @type {string}
     * @memberof RepositoryApiRepoGetRepoPermissions
     */
    readonly collaborator: string
}

/**
 * Request parameters for repoGetReviewers operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoGetReviewersRequest
 */
export interface RepositoryApiRepoGetReviewersRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetReviewers
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetReviewers
     */
    readonly repo: string
}

/**
 * Request parameters for repoGetSingleCommit operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoGetSingleCommitRequest
 */
export interface RepositoryApiRepoGetSingleCommitRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetSingleCommit
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetSingleCommit
     */
    readonly repo: string

    /**
     * a git ref or commit sha
     * @type {string}
     * @memberof RepositoryApiRepoGetSingleCommit
     */
    readonly sha: string
}

/**
 * Request parameters for repoGetTag operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoGetTagRequest
 */
export interface RepositoryApiRepoGetTagRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetTag
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetTag
     */
    readonly repo: string

    /**
     * name of tag
     * @type {string}
     * @memberof RepositoryApiRepoGetTag
     */
    readonly tag: string
}

/**
 * Request parameters for repoGetWikiPage operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoGetWikiPageRequest
 */
export interface RepositoryApiRepoGetWikiPageRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetWikiPage
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetWikiPage
     */
    readonly repo: string

    /**
     * name of the page
     * @type {string}
     * @memberof RepositoryApiRepoGetWikiPage
     */
    readonly pageName: string
}

/**
 * Request parameters for repoGetWikiPageRevisions operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoGetWikiPageRevisionsRequest
 */
export interface RepositoryApiRepoGetWikiPageRevisionsRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetWikiPageRevisions
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetWikiPageRevisions
     */
    readonly repo: string

    /**
     * name of the page
     * @type {string}
     * @memberof RepositoryApiRepoGetWikiPageRevisions
     */
    readonly pageName: string

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof RepositoryApiRepoGetWikiPageRevisions
     */
    readonly page?: number
}

/**
 * Request parameters for repoGetWikiPages operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoGetWikiPagesRequest
 */
export interface RepositoryApiRepoGetWikiPagesRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetWikiPages
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoGetWikiPages
     */
    readonly repo: string

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof RepositoryApiRepoGetWikiPages
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof RepositoryApiRepoGetWikiPages
     */
    readonly limit?: number
}

/**
 * Request parameters for repoListAllGitRefs operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoListAllGitRefsRequest
 */
export interface RepositoryApiRepoListAllGitRefsRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoListAllGitRefs
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoListAllGitRefs
     */
    readonly repo: string
}

/**
 * Request parameters for repoListBranchProtection operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoListBranchProtectionRequest
 */
export interface RepositoryApiRepoListBranchProtectionRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoListBranchProtection
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoListBranchProtection
     */
    readonly repo: string
}

/**
 * Request parameters for repoListBranches operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoListBranchesRequest
 */
export interface RepositoryApiRepoListBranchesRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoListBranches
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoListBranches
     */
    readonly repo: string

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof RepositoryApiRepoListBranches
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof RepositoryApiRepoListBranches
     */
    readonly limit?: number
}

/**
 * Request parameters for repoListCollaborators operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoListCollaboratorsRequest
 */
export interface RepositoryApiRepoListCollaboratorsRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoListCollaborators
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoListCollaborators
     */
    readonly repo: string

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof RepositoryApiRepoListCollaborators
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof RepositoryApiRepoListCollaborators
     */
    readonly limit?: number
}

/**
 * Request parameters for repoListGitHooks operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoListGitHooksRequest
 */
export interface RepositoryApiRepoListGitHooksRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoListGitHooks
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoListGitHooks
     */
    readonly repo: string
}

/**
 * Request parameters for repoListGitRefs operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoListGitRefsRequest
 */
export interface RepositoryApiRepoListGitRefsRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoListGitRefs
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoListGitRefs
     */
    readonly repo: string

    /**
     * part or full name of the ref
     * @type {string}
     * @memberof RepositoryApiRepoListGitRefs
     */
    readonly ref: string
}

/**
 * Request parameters for repoListHooks operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoListHooksRequest
 */
export interface RepositoryApiRepoListHooksRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoListHooks
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoListHooks
     */
    readonly repo: string

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof RepositoryApiRepoListHooks
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof RepositoryApiRepoListHooks
     */
    readonly limit?: number
}

/**
 * Request parameters for repoListKeys operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoListKeysRequest
 */
export interface RepositoryApiRepoListKeysRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoListKeys
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoListKeys
     */
    readonly repo: string

    /**
     * the key_id to search for
     * @type {number}
     * @memberof RepositoryApiRepoListKeys
     */
    readonly keyId?: number

    /**
     * fingerprint of the key
     * @type {string}
     * @memberof RepositoryApiRepoListKeys
     */
    readonly fingerprint?: string

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof RepositoryApiRepoListKeys
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof RepositoryApiRepoListKeys
     */
    readonly limit?: number
}

/**
 * Request parameters for repoListPullRequests operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoListPullRequestsRequest
 */
export interface RepositoryApiRepoListPullRequestsRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoListPullRequests
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoListPullRequests
     */
    readonly repo: string

    /**
     * State of pull request: open or closed (optional)
     * @type {'closed' | 'open' | 'all'}
     * @memberof RepositoryApiRepoListPullRequests
     */
    readonly state?: 'closed' | 'open' | 'all'

    /**
     * Type of sort
     * @type {'oldest' | 'recentupdate' | 'leastupdate' | 'mostcomment' | 'leastcomment' | 'priority'}
     * @memberof RepositoryApiRepoListPullRequests
     */
    readonly sort?: 'oldest' | 'recentupdate' | 'leastupdate' | 'mostcomment' | 'leastcomment' | 'priority'

    /**
     * ID of the milestone
     * @type {number}
     * @memberof RepositoryApiRepoListPullRequests
     */
    readonly milestone?: number

    /**
     * Label IDs
     * @type {Array<number>}
     * @memberof RepositoryApiRepoListPullRequests
     */
    readonly labels?: Array<number>

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof RepositoryApiRepoListPullRequests
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof RepositoryApiRepoListPullRequests
     */
    readonly limit?: number
}

/**
 * Request parameters for repoListPullReviews operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoListPullReviewsRequest
 */
export interface RepositoryApiRepoListPullReviewsRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoListPullReviews
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoListPullReviews
     */
    readonly repo: string

    /**
     * index of the pull request
     * @type {number}
     * @memberof RepositoryApiRepoListPullReviews
     */
    readonly index: number

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof RepositoryApiRepoListPullReviews
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof RepositoryApiRepoListPullReviews
     */
    readonly limit?: number
}

/**
 * Request parameters for repoListReleaseAttachments operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoListReleaseAttachmentsRequest
 */
export interface RepositoryApiRepoListReleaseAttachmentsRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoListReleaseAttachments
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoListReleaseAttachments
     */
    readonly repo: string

    /**
     * id of the release
     * @type {number}
     * @memberof RepositoryApiRepoListReleaseAttachments
     */
    readonly id: number
}

/**
 * Request parameters for repoListReleases operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoListReleasesRequest
 */
export interface RepositoryApiRepoListReleasesRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoListReleases
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoListReleases
     */
    readonly repo: string

    /**
     * filter (exclude / include) drafts, if you dont have repo write access none will show
     * @type {boolean}
     * @memberof RepositoryApiRepoListReleases
     */
    readonly draft?: boolean

    /**
     * filter (exclude / include) pre-releases
     * @type {boolean}
     * @memberof RepositoryApiRepoListReleases
     */
    readonly preRelease?: boolean

    /**
     * page size of results, deprecated - use limit
     * @type {number}
     * @memberof RepositoryApiRepoListReleases
     */
    readonly perPage?: number

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof RepositoryApiRepoListReleases
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof RepositoryApiRepoListReleases
     */
    readonly limit?: number
}

/**
 * Request parameters for repoListStargazers operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoListStargazersRequest
 */
export interface RepositoryApiRepoListStargazersRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoListStargazers
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoListStargazers
     */
    readonly repo: string

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof RepositoryApiRepoListStargazers
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof RepositoryApiRepoListStargazers
     */
    readonly limit?: number
}

/**
 * Request parameters for repoListStatuses operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoListStatusesRequest
 */
export interface RepositoryApiRepoListStatusesRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoListStatuses
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoListStatuses
     */
    readonly repo: string

    /**
     * sha of the commit
     * @type {string}
     * @memberof RepositoryApiRepoListStatuses
     */
    readonly sha: string

    /**
     * type of sort
     * @type {'oldest' | 'recentupdate' | 'leastupdate' | 'leastindex' | 'highestindex'}
     * @memberof RepositoryApiRepoListStatuses
     */
    readonly sort?: 'oldest' | 'recentupdate' | 'leastupdate' | 'leastindex' | 'highestindex'

    /**
     * type of state
     * @type {'pending' | 'success' | 'error' | 'failure' | 'warning'}
     * @memberof RepositoryApiRepoListStatuses
     */
    readonly state?: 'pending' | 'success' | 'error' | 'failure' | 'warning'

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof RepositoryApiRepoListStatuses
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof RepositoryApiRepoListStatuses
     */
    readonly limit?: number
}

/**
 * Request parameters for repoListStatusesByRef operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoListStatusesByRefRequest
 */
export interface RepositoryApiRepoListStatusesByRefRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoListStatusesByRef
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoListStatusesByRef
     */
    readonly repo: string

    /**
     * name of branch/tag/commit
     * @type {string}
     * @memberof RepositoryApiRepoListStatusesByRef
     */
    readonly ref: string

    /**
     * type of sort
     * @type {'oldest' | 'recentupdate' | 'leastupdate' | 'leastindex' | 'highestindex'}
     * @memberof RepositoryApiRepoListStatusesByRef
     */
    readonly sort?: 'oldest' | 'recentupdate' | 'leastupdate' | 'leastindex' | 'highestindex'

    /**
     * type of state
     * @type {'pending' | 'success' | 'error' | 'failure' | 'warning'}
     * @memberof RepositoryApiRepoListStatusesByRef
     */
    readonly state?: 'pending' | 'success' | 'error' | 'failure' | 'warning'

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof RepositoryApiRepoListStatusesByRef
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof RepositoryApiRepoListStatusesByRef
     */
    readonly limit?: number
}

/**
 * Request parameters for repoListSubscribers operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoListSubscribersRequest
 */
export interface RepositoryApiRepoListSubscribersRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoListSubscribers
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoListSubscribers
     */
    readonly repo: string

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof RepositoryApiRepoListSubscribers
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof RepositoryApiRepoListSubscribers
     */
    readonly limit?: number
}

/**
 * Request parameters for repoListTags operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoListTagsRequest
 */
export interface RepositoryApiRepoListTagsRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoListTags
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoListTags
     */
    readonly repo: string

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof RepositoryApiRepoListTags
     */
    readonly page?: number

    /**
     * page size of results, default maximum page size is 50
     * @type {number}
     * @memberof RepositoryApiRepoListTags
     */
    readonly limit?: number
}

/**
 * Request parameters for repoListTeams operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoListTeamsRequest
 */
export interface RepositoryApiRepoListTeamsRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoListTeams
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoListTeams
     */
    readonly repo: string
}

/**
 * Request parameters for repoListTopics operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoListTopicsRequest
 */
export interface RepositoryApiRepoListTopicsRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoListTopics
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoListTopics
     */
    readonly repo: string

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof RepositoryApiRepoListTopics
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof RepositoryApiRepoListTopics
     */
    readonly limit?: number
}

/**
 * Request parameters for repoMergePullRequest operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoMergePullRequestRequest
 */
export interface RepositoryApiRepoMergePullRequestRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoMergePullRequest
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoMergePullRequest
     */
    readonly repo: string

    /**
     * index of the pull request to merge
     * @type {number}
     * @memberof RepositoryApiRepoMergePullRequest
     */
    readonly index: number

    /**
     * 
     * @type {MergePullRequestOption}
     * @memberof RepositoryApiRepoMergePullRequest
     */
    readonly body?: MergePullRequestOption
}

/**
 * Request parameters for repoMigrate operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoMigrateRequest
 */
export interface RepositoryApiRepoMigrateRequest {
    /**
     * 
     * @type {MigrateRepoOptions}
     * @memberof RepositoryApiRepoMigrate
     */
    readonly body?: MigrateRepoOptions
}

/**
 * Request parameters for repoMirrorSync operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoMirrorSyncRequest
 */
export interface RepositoryApiRepoMirrorSyncRequest {
    /**
     * owner of the repo to sync
     * @type {string}
     * @memberof RepositoryApiRepoMirrorSync
     */
    readonly owner: string

    /**
     * name of the repo to sync
     * @type {string}
     * @memberof RepositoryApiRepoMirrorSync
     */
    readonly repo: string
}

/**
 * Request parameters for repoPullRequestIsMerged operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoPullRequestIsMergedRequest
 */
export interface RepositoryApiRepoPullRequestIsMergedRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoPullRequestIsMerged
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoPullRequestIsMerged
     */
    readonly repo: string

    /**
     * index of the pull request
     * @type {number}
     * @memberof RepositoryApiRepoPullRequestIsMerged
     */
    readonly index: number
}

/**
 * Request parameters for repoSearch operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoSearchRequest
 */
export interface RepositoryApiRepoSearchRequest {
    /**
     * keyword
     * @type {string}
     * @memberof RepositoryApiRepoSearch
     */
    readonly q?: string

    /**
     * Limit search to repositories with keyword as topic
     * @type {boolean}
     * @memberof RepositoryApiRepoSearch
     */
    readonly topic?: boolean

    /**
     * include search of keyword within repository description (defaults to false)
     * @type {boolean}
     * @memberof RepositoryApiRepoSearch
     */
    readonly includeDesc?: boolean

    /**
     * search only for repos that the user with the given id owns or contributes to
     * @type {number}
     * @memberof RepositoryApiRepoSearch
     */
    readonly uid?: number

    /**
     * repo owner to prioritize in the results
     * @type {number}
     * @memberof RepositoryApiRepoSearch
     */
    readonly priorityOwnerId?: number

    /**
     * search only for repos that belong to the given team id
     * @type {number}
     * @memberof RepositoryApiRepoSearch
     */
    readonly teamId?: number

    /**
     * search only for repos that the user with the given id has starred
     * @type {number}
     * @memberof RepositoryApiRepoSearch
     */
    readonly starredBy?: number

    /**
     * include private repositories this user has access to (defaults to true)
     * @type {boolean}
     * @memberof RepositoryApiRepoSearch
     */
    readonly _private?: boolean

    /**
     * show only pubic, private or all repositories (defaults to all)
     * @type {boolean}
     * @memberof RepositoryApiRepoSearch
     */
    readonly isPrivate?: boolean

    /**
     * include template repositories this user has access to (defaults to true)
     * @type {boolean}
     * @memberof RepositoryApiRepoSearch
     */
    readonly template?: boolean

    /**
     * show only archived, non-archived or all repositories (defaults to all)
     * @type {boolean}
     * @memberof RepositoryApiRepoSearch
     */
    readonly archived?: boolean

    /**
     * type of repository to search for. Supported values are \&quot;fork\&quot;, \&quot;source\&quot;, \&quot;mirror\&quot; and \&quot;collaborative\&quot;
     * @type {string}
     * @memberof RepositoryApiRepoSearch
     */
    readonly mode?: string

    /**
     * if &#x60;uid&#x60; is given, search only for repos that the user owns
     * @type {boolean}
     * @memberof RepositoryApiRepoSearch
     */
    readonly exclusive?: boolean

    /**
     * name of the repo. Multiple repo\&#39;s are ORed.
     * @type {string}
     * @memberof RepositoryApiRepoSearch
     */
    readonly repo?: string

    /**
     * owner of the repo. Multiple owner\&#39;s are ORed.
     * @type {string}
     * @memberof RepositoryApiRepoSearch
     */
    readonly owner?: string

    /**
     * If the repo is a resource of the given language(s), the repo will be in the results. Multiple lang\&#39;s are ORed.
     * @type {string}
     * @memberof RepositoryApiRepoSearch
     */
    readonly lang?: string

    /**
     * resource subject. Multiple subject\&#39;s are ORed.
     * @type {string}
     * @memberof RepositoryApiRepoSearch
     */
    readonly subject?: string

    /**
     * book (project id) that exist in a resource. If the resource contains the the book, its repository will be included in the results. Multiple book\&#39;s are ORed.
     * @type {string}
     * @memberof RepositoryApiRepoSearch
     */
    readonly book?: string

    /**
     * if false, q value will only be searched for in the repo name, owner, description and title and subject; otherwise search all values of the manifest file. (defaults to false)
     * @type {boolean}
     * @memberof RepositoryApiRepoSearch
     */
    readonly includeMetadata?: boolean

    /**
     * sort repos by attribute. Supported values are \&quot;alpha\&quot;, \&quot;created\&quot;, \&quot;updated\&quot;, \&quot;size\&quot;, and \&quot;id\&quot;. Default is \&quot;alpha\&quot;
     * @type {string}
     * @memberof RepositoryApiRepoSearch
     */
    readonly sort?: string

    /**
     * sort order, either \&quot;asc\&quot; (ascending) or \&quot;desc\&quot; (descending). Default is \&quot;asc\&quot;, ignored if \&quot;sort\&quot; is not specified.
     * @type {string}
     * @memberof RepositoryApiRepoSearch
     */
    readonly order?: string

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof RepositoryApiRepoSearch
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof RepositoryApiRepoSearch
     */
    readonly limit?: number
}

/**
 * Request parameters for repoSigningKey operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoSigningKeyRequest
 */
export interface RepositoryApiRepoSigningKeyRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoSigningKey
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoSigningKey
     */
    readonly repo: string
}

/**
 * Request parameters for repoSubmitPullReview operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoSubmitPullReviewRequest
 */
export interface RepositoryApiRepoSubmitPullReviewRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoSubmitPullReview
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoSubmitPullReview
     */
    readonly repo: string

    /**
     * index of the pull request
     * @type {number}
     * @memberof RepositoryApiRepoSubmitPullReview
     */
    readonly index: number

    /**
     * id of the review
     * @type {number}
     * @memberof RepositoryApiRepoSubmitPullReview
     */
    readonly id: number

    /**
     * 
     * @type {SubmitPullReviewOptions}
     * @memberof RepositoryApiRepoSubmitPullReview
     */
    readonly body: SubmitPullReviewOptions
}

/**
 * Request parameters for repoTestHook operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoTestHookRequest
 */
export interface RepositoryApiRepoTestHookRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoTestHook
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoTestHook
     */
    readonly repo: string

    /**
     * id of the hook to test
     * @type {number}
     * @memberof RepositoryApiRepoTestHook
     */
    readonly id: number

    /**
     * The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload.
     * @type {string}
     * @memberof RepositoryApiRepoTestHook
     */
    readonly ref?: string
}

/**
 * Request parameters for repoTrackedTimes operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoTrackedTimesRequest
 */
export interface RepositoryApiRepoTrackedTimesRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoTrackedTimes
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoTrackedTimes
     */
    readonly repo: string

    /**
     * optional filter by user (available for issue managers)
     * @type {string}
     * @memberof RepositoryApiRepoTrackedTimes
     */
    readonly user?: string

    /**
     * Only show times updated after the given time. This is a timestamp in RFC 3339 format
     * @type {string}
     * @memberof RepositoryApiRepoTrackedTimes
     */
    readonly since?: string

    /**
     * Only show times updated before the given time. This is a timestamp in RFC 3339 format
     * @type {string}
     * @memberof RepositoryApiRepoTrackedTimes
     */
    readonly before?: string

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof RepositoryApiRepoTrackedTimes
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof RepositoryApiRepoTrackedTimes
     */
    readonly limit?: number
}

/**
 * Request parameters for repoTransfer operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoTransferRequest
 */
export interface RepositoryApiRepoTransferRequest {
    /**
     * owner of the repo to transfer
     * @type {string}
     * @memberof RepositoryApiRepoTransfer
     */
    readonly owner: string

    /**
     * name of the repo to transfer
     * @type {string}
     * @memberof RepositoryApiRepoTransfer
     */
    readonly repo: string

    /**
     * Transfer Options
     * @type {TransferRepoOption}
     * @memberof RepositoryApiRepoTransfer
     */
    readonly body: TransferRepoOption
}

/**
 * Request parameters for repoUnDismissPullReview operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoUnDismissPullReviewRequest
 */
export interface RepositoryApiRepoUnDismissPullReviewRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoUnDismissPullReview
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoUnDismissPullReview
     */
    readonly repo: string

    /**
     * index of the pull request
     * @type {number}
     * @memberof RepositoryApiRepoUnDismissPullReview
     */
    readonly index: number

    /**
     * id of the review
     * @type {number}
     * @memberof RepositoryApiRepoUnDismissPullReview
     */
    readonly id: number
}

/**
 * Request parameters for repoUpdateFile operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoUpdateFileRequest
 */
export interface RepositoryApiRepoUpdateFileRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoUpdateFile
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoUpdateFile
     */
    readonly repo: string

    /**
     * path of the file to update
     * @type {string}
     * @memberof RepositoryApiRepoUpdateFile
     */
    readonly filepath: string

    /**
     * 
     * @type {UpdateFileOptions}
     * @memberof RepositoryApiRepoUpdateFile
     */
    readonly body: UpdateFileOptions
}

/**
 * Request parameters for repoUpdateGitRef operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoUpdateGitRefRequest
 */
export interface RepositoryApiRepoUpdateGitRefRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoUpdateGitRef
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoUpdateGitRef
     */
    readonly repo: string

    /**
     * name of the ref to update
     * @type {string}
     * @memberof RepositoryApiRepoUpdateGitRef
     */
    readonly ref: string

    /**
     * 
     * @type {UpdateGitRefOption}
     * @memberof RepositoryApiRepoUpdateGitRef
     */
    readonly body?: UpdateGitRefOption
}

/**
 * Request parameters for repoUpdatePullRequest operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoUpdatePullRequestRequest
 */
export interface RepositoryApiRepoUpdatePullRequestRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoUpdatePullRequest
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoUpdatePullRequest
     */
    readonly repo: string

    /**
     * index of the pull request to get
     * @type {number}
     * @memberof RepositoryApiRepoUpdatePullRequest
     */
    readonly index: number

    /**
     * how to update pull request
     * @type {'merge' | 'rebase'}
     * @memberof RepositoryApiRepoUpdatePullRequest
     */
    readonly style?: 'merge' | 'rebase'
}

/**
 * Request parameters for repoUpdateTopics operation in RepositoryApi.
 * @export
 * @interface RepositoryApiRepoUpdateTopicsRequest
 */
export interface RepositoryApiRepoUpdateTopicsRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiRepoUpdateTopics
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiRepoUpdateTopics
     */
    readonly repo: string

    /**
     * 
     * @type {RepoTopicOptions}
     * @memberof RepositoryApiRepoUpdateTopics
     */
    readonly body?: RepoTopicOptions
}

/**
 * Request parameters for topicSearch operation in RepositoryApi.
 * @export
 * @interface RepositoryApiTopicSearchRequest
 */
export interface RepositoryApiTopicSearchRequest {
    /**
     * keywords to search
     * @type {string}
     * @memberof RepositoryApiTopicSearch
     */
    readonly q: string

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof RepositoryApiTopicSearch
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof RepositoryApiTopicSearch
     */
    readonly limit?: number
}

/**
 * Request parameters for userCurrentCheckSubscription operation in RepositoryApi.
 * @export
 * @interface RepositoryApiUserCurrentCheckSubscriptionRequest
 */
export interface RepositoryApiUserCurrentCheckSubscriptionRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiUserCurrentCheckSubscription
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiUserCurrentCheckSubscription
     */
    readonly repo: string
}

/**
 * Request parameters for userCurrentDeleteSubscription operation in RepositoryApi.
 * @export
 * @interface RepositoryApiUserCurrentDeleteSubscriptionRequest
 */
export interface RepositoryApiUserCurrentDeleteSubscriptionRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiUserCurrentDeleteSubscription
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiUserCurrentDeleteSubscription
     */
    readonly repo: string
}

/**
 * Request parameters for userCurrentPutSubscription operation in RepositoryApi.
 * @export
 * @interface RepositoryApiUserCurrentPutSubscriptionRequest
 */
export interface RepositoryApiUserCurrentPutSubscriptionRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiUserCurrentPutSubscription
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiUserCurrentPutSubscription
     */
    readonly repo: string
}

/**
 * Request parameters for userTrackedTimes operation in RepositoryApi.
 * @export
 * @interface RepositoryApiUserTrackedTimesRequest
 */
export interface RepositoryApiUserTrackedTimesRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof RepositoryApiUserTrackedTimes
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof RepositoryApiUserTrackedTimes
     */
    readonly repo: string

    /**
     * username of user
     * @type {string}
     * @memberof RepositoryApiUserTrackedTimes
     */
    readonly user: string
}

/**
 * RepositoryApi - object-oriented interface
 * @export
 * @class RepositoryApi
 * @extends {BaseAPI}
 */
export class RepositoryApi extends BaseAPI {
    /**
     * 
     * @summary Accept a repo transfer
     * @param {RepositoryApiAcceptRepoTransferRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public acceptRepoTransfer(requestParameters: RepositoryApiAcceptRepoTransferRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).acceptRepoTransfer(requestParameters.owner, requestParameters.repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a repository
     * @param {RepositoryApiCreateCurrentUserRepoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public createCurrentUserRepo(requestParameters: RepositoryApiCreateCurrentUserRepoRequest = {}, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).createCurrentUserRepo(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fork a repository
     * @param {RepositoryApiCreateForkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public createFork(requestParameters: RepositoryApiCreateForkRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).createFork(requestParameters.owner, requestParameters.repo, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a repository using a template
     * @param {RepositoryApiGenerateRepoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public generateRepo(requestParameters: RepositoryApiGenerateRepoRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).generateRepo(requestParameters.templateOwner, requestParameters.templateRepo, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the tag object of an annotated tag (not lightweight tags)
     * @param {RepositoryApiGetAnnotatedTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getAnnotatedTag(requestParameters: RepositoryApiGetAnnotatedTagRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getAnnotatedTag(requestParameters.owner, requestParameters.repo, requestParameters.sha, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the blob of a repository.
     * @param {RepositoryApiGetBlobRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getBlob(requestParameters: RepositoryApiGetBlobRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getBlob(requestParameters.owner, requestParameters.repo, requestParameters.sha, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the tree of a repository.
     * @param {RepositoryApiGetTreeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getTree(requestParameters: RepositoryApiGetTreeRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).getTree(requestParameters.owner, requestParameters.repo, requestParameters.sha, requestParameters.recursive, requestParameters.page, requestParameters.perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repository\'s forks
     * @param {RepositoryApiListForksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public listForks(requestParameters: RepositoryApiListForksRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).listForks(requestParameters.owner, requestParameters.repo, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reject a repo transfer
     * @param {RepositoryApiRejectRepoTransferRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public rejectRepoTransfer(requestParameters: RepositoryApiRejectRepoTransferRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).rejectRepoTransfer(requestParameters.owner, requestParameters.repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a collaborator to a repository
     * @param {RepositoryApiRepoAddCollaboratorRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoAddCollaborator(requestParameters: RepositoryApiRepoAddCollaboratorRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoAddCollaborator(requestParameters.owner, requestParameters.repo, requestParameters.collaborator, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a team to a repository
     * @param {RepositoryApiRepoAddTeamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoAddTeam(requestParameters: RepositoryApiRepoAddTeamRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoAddTeam(requestParameters.owner, requestParameters.repo, requestParameters.team, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a topic to a repository
     * @param {RepositoryApiRepoAddTopicRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoAddTopic(requestParameters: RepositoryApiRepoAddTopicRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoAddTopic(requestParameters.owner, requestParameters.repo, requestParameters.topic, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Apply diff patch to repository
     * @param {RepositoryApiRepoApplyDiffPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoApplyDiffPatch(requestParameters: RepositoryApiRepoApplyDiffPatchRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoApplyDiffPatch(requestParameters.owner, requestParameters.repo, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancel the scheduled auto merge for the given pull request
     * @param {RepositoryApiRepoCancelScheduledAutoMergeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCancelScheduledAutoMerge(requestParameters: RepositoryApiRepoCancelScheduledAutoMergeRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCancelScheduledAutoMerge(requestParameters.owner, requestParameters.repo, requestParameters.index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if a user is a collaborator of a repository
     * @param {RepositoryApiRepoCheckCollaboratorRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCheckCollaborator(requestParameters: RepositoryApiRepoCheckCollaboratorRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCheckCollaborator(requestParameters.owner, requestParameters.repo, requestParameters.collaborator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if a team is assigned to a repository
     * @param {RepositoryApiRepoCheckTeamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCheckTeam(requestParameters: RepositoryApiRepoCheckTeamRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCheckTeam(requestParameters.owner, requestParameters.repo, requestParameters.team, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a branch
     * @param {RepositoryApiRepoCreateBranchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateBranch(requestParameters: RepositoryApiRepoCreateBranchRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreateBranch(requestParameters.owner, requestParameters.repo, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a branch protections for a repository
     * @param {RepositoryApiRepoCreateBranchProtectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateBranchProtection(requestParameters: RepositoryApiRepoCreateBranchProtectionRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreateBranchProtection(requestParameters.owner, requestParameters.repo, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a file in a repository
     * @param {RepositoryApiRepoCreateFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateFile(requestParameters: RepositoryApiRepoCreateFileRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreateFile(requestParameters.owner, requestParameters.repo, requestParameters.filepath, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a reference for your repository. You are unable to create new references for empty repositories, even if the commit SHA-1 hash used exists. Empty repositories are repositories without branches.
     * @summary Create a reference
     * @param {RepositoryApiRepoCreateGitRefRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateGitRef(requestParameters: RepositoryApiRepoCreateGitRefRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreateGitRef(requestParameters.owner, requestParameters.repo, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a hook
     * @param {RepositoryApiRepoCreateHookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateHook(requestParameters: RepositoryApiRepoCreateHookRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreateHook(requestParameters.owner, requestParameters.repo, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a key to a repository
     * @param {RepositoryApiRepoCreateKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateKey(requestParameters: RepositoryApiRepoCreateKeyRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreateKey(requestParameters.owner, requestParameters.repo, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a pull request
     * @param {RepositoryApiRepoCreatePullRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreatePullRequest(requestParameters: RepositoryApiRepoCreatePullRequestRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreatePullRequest(requestParameters.owner, requestParameters.repo, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a review to an pull request
     * @param {RepositoryApiRepoCreatePullReviewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreatePullReview(requestParameters: RepositoryApiRepoCreatePullReviewRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreatePullReview(requestParameters.owner, requestParameters.repo, requestParameters.index, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary create review requests for a pull request
     * @param {RepositoryApiRepoCreatePullReviewRequestsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreatePullReviewRequests(requestParameters: RepositoryApiRepoCreatePullReviewRequestsRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreatePullReviewRequests(requestParameters.owner, requestParameters.repo, requestParameters.index, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a release
     * @param {RepositoryApiRepoCreateReleaseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateRelease(requestParameters: RepositoryApiRepoCreateReleaseRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreateRelease(requestParameters.owner, requestParameters.repo, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a release attachment
     * @param {RepositoryApiRepoCreateReleaseAttachmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateReleaseAttachment(requestParameters: RepositoryApiRepoCreateReleaseAttachmentRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreateReleaseAttachment(requestParameters.owner, requestParameters.repo, requestParameters.id, requestParameters.attachment, requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a commit status
     * @param {RepositoryApiRepoCreateStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateStatus(requestParameters: RepositoryApiRepoCreateStatusRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreateStatus(requestParameters.owner, requestParameters.repo, requestParameters.sha, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new git tag in a repository
     * @param {RepositoryApiRepoCreateTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateTag(requestParameters: RepositoryApiRepoCreateTagRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreateTag(requestParameters.owner, requestParameters.repo, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a wiki page
     * @param {RepositoryApiRepoCreateWikiPageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoCreateWikiPage(requestParameters: RepositoryApiRepoCreateWikiPageRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoCreateWikiPage(requestParameters.owner, requestParameters.repo, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a repository
     * @param {RepositoryApiRepoDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDelete(requestParameters: RepositoryApiRepoDeleteRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDelete(requestParameters.owner, requestParameters.repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a specific branch from a repository
     * @param {RepositoryApiRepoDeleteBranchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteBranch(requestParameters: RepositoryApiRepoDeleteBranchRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteBranch(requestParameters.owner, requestParameters.repo, requestParameters.branch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a specific branch protection for the repository
     * @param {RepositoryApiRepoDeleteBranchProtectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteBranchProtection(requestParameters: RepositoryApiRepoDeleteBranchProtectionRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteBranchProtection(requestParameters.owner, requestParameters.repo, requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a collaborator from a repository
     * @param {RepositoryApiRepoDeleteCollaboratorRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteCollaborator(requestParameters: RepositoryApiRepoDeleteCollaboratorRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteCollaborator(requestParameters.owner, requestParameters.repo, requestParameters.collaborator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a file in a repository
     * @param {RepositoryApiRepoDeleteFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteFile(requestParameters: RepositoryApiRepoDeleteFileRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteFile(requestParameters.owner, requestParameters.repo, requestParameters.filepath, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Git hook in a repository
     * @param {RepositoryApiRepoDeleteGitHookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteGitHook(requestParameters: RepositoryApiRepoDeleteGitHookRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteGitHook(requestParameters.owner, requestParameters.repo, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a reference
     * @param {RepositoryApiRepoDeleteGitRefRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteGitRef(requestParameters: RepositoryApiRepoDeleteGitRefRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteGitRef(requestParameters.owner, requestParameters.repo, requestParameters.ref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a hook in a repository
     * @param {RepositoryApiRepoDeleteHookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteHook(requestParameters: RepositoryApiRepoDeleteHookRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteHook(requestParameters.owner, requestParameters.repo, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a key from a repository
     * @param {RepositoryApiRepoDeleteKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteKey(requestParameters: RepositoryApiRepoDeleteKeyRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteKey(requestParameters.owner, requestParameters.repo, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a specific review from a pull request
     * @param {RepositoryApiRepoDeletePullReviewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeletePullReview(requestParameters: RepositoryApiRepoDeletePullReviewRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeletePullReview(requestParameters.owner, requestParameters.repo, requestParameters.index, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary cancel review requests for a pull request
     * @param {RepositoryApiRepoDeletePullReviewRequestsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeletePullReviewRequests(requestParameters: RepositoryApiRepoDeletePullReviewRequestsRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeletePullReviewRequests(requestParameters.owner, requestParameters.repo, requestParameters.index, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a release
     * @param {RepositoryApiRepoDeleteReleaseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteRelease(requestParameters: RepositoryApiRepoDeleteReleaseRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteRelease(requestParameters.owner, requestParameters.repo, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a release attachment
     * @param {RepositoryApiRepoDeleteReleaseAttachmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteReleaseAttachment(requestParameters: RepositoryApiRepoDeleteReleaseAttachmentRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteReleaseAttachment(requestParameters.owner, requestParameters.repo, requestParameters.id, requestParameters.attachmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a release by tag name
     * @param {RepositoryApiRepoDeleteReleaseByTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteReleaseByTag(requestParameters: RepositoryApiRepoDeleteReleaseByTagRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteReleaseByTag(requestParameters.owner, requestParameters.repo, requestParameters.tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a repository\'s tag by name
     * @param {RepositoryApiRepoDeleteTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteTag(requestParameters: RepositoryApiRepoDeleteTagRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteTag(requestParameters.owner, requestParameters.repo, requestParameters.tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a team from a repository
     * @param {RepositoryApiRepoDeleteTeamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteTeam(requestParameters: RepositoryApiRepoDeleteTeamRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteTeam(requestParameters.owner, requestParameters.repo, requestParameters.team, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a topic from a repository
     * @param {RepositoryApiRepoDeleteTopicRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteTopic(requestParameters: RepositoryApiRepoDeleteTopicRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteTopic(requestParameters.owner, requestParameters.repo, requestParameters.topic, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a wiki page
     * @param {RepositoryApiRepoDeleteWikiPageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDeleteWikiPage(requestParameters: RepositoryApiRepoDeleteWikiPageRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDeleteWikiPage(requestParameters.owner, requestParameters.repo, requestParameters.pageName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Dismiss a review for a pull request
     * @param {RepositoryApiRepoDismissPullReviewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDismissPullReview(requestParameters: RepositoryApiRepoDismissPullReviewRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDismissPullReview(requestParameters.owner, requestParameters.repo, requestParameters.index, requestParameters.id, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a commit\'s diff or patch
     * @param {RepositoryApiRepoDownloadCommitDiffOrPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDownloadCommitDiffOrPatch(requestParameters: RepositoryApiRepoDownloadCommitDiffOrPatchRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDownloadCommitDiffOrPatch(requestParameters.owner, requestParameters.repo, requestParameters.sha, requestParameters.diffType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a pull request diff or patch
     * @param {RepositoryApiRepoDownloadPullDiffOrPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoDownloadPullDiffOrPatch(requestParameters: RepositoryApiRepoDownloadPullDiffOrPatchRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoDownloadPullDiffOrPatch(requestParameters.owner, requestParameters.repo, requestParameters.index, requestParameters.diffType, requestParameters.binary, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a repository\'s properties. Only fields that are set will be changed.
     * @param {RepositoryApiRepoEditRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoEdit(requestParameters: RepositoryApiRepoEditRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoEdit(requestParameters.owner, requestParameters.repo, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a branch protections for a repository. Only fields that are set will be changed
     * @param {RepositoryApiRepoEditBranchProtectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoEditBranchProtection(requestParameters: RepositoryApiRepoEditBranchProtectionRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoEditBranchProtection(requestParameters.owner, requestParameters.repo, requestParameters.name, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a Git hook in a repository
     * @param {RepositoryApiRepoEditGitHookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoEditGitHook(requestParameters: RepositoryApiRepoEditGitHookRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoEditGitHook(requestParameters.owner, requestParameters.repo, requestParameters.id, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a hook in a repository
     * @param {RepositoryApiRepoEditHookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoEditHook(requestParameters: RepositoryApiRepoEditHookRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoEditHook(requestParameters.owner, requestParameters.repo, requestParameters.id, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a pull request. If using deadline only the date will be taken into account, and time of day ignored.
     * @param {RepositoryApiRepoEditPullRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoEditPullRequest(requestParameters: RepositoryApiRepoEditPullRequestRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoEditPullRequest(requestParameters.owner, requestParameters.repo, requestParameters.index, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a release
     * @param {RepositoryApiRepoEditReleaseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoEditRelease(requestParameters: RepositoryApiRepoEditReleaseRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoEditRelease(requestParameters.owner, requestParameters.repo, requestParameters.id, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a release attachment
     * @param {RepositoryApiRepoEditReleaseAttachmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoEditReleaseAttachment(requestParameters: RepositoryApiRepoEditReleaseAttachmentRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoEditReleaseAttachment(requestParameters.owner, requestParameters.repo, requestParameters.id, requestParameters.attachmentId, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a wiki page
     * @param {RepositoryApiRepoEditWikiPageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoEditWikiPage(requestParameters: RepositoryApiRepoEditWikiPageRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoEditWikiPage(requestParameters.owner, requestParameters.repo, requestParameters.pageName, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a repository
     * @param {RepositoryApiRepoGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGet(requestParameters: RepositoryApiRepoGetRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGet(requestParameters.owner, requestParameters.repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of all commits from a repository
     * @param {RepositoryApiRepoGetAllCommitsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetAllCommits(requestParameters: RepositoryApiRepoGetAllCommitsRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetAllCommits(requestParameters.owner, requestParameters.repo, requestParameters.sha, requestParameters.path, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an archive of a repository
     * @param {RepositoryApiRepoGetArchiveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetArchive(requestParameters: RepositoryApiRepoGetArchiveRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetArchive(requestParameters.owner, requestParameters.repo, requestParameters.archive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return all users that have write access and can be assigned to issues
     * @param {RepositoryApiRepoGetAssigneesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetAssignees(requestParameters: RepositoryApiRepoGetAssigneesRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetAssignees(requestParameters.owner, requestParameters.repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a specific branch from a repository, including its effective branch protection
     * @param {RepositoryApiRepoGetBranchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetBranch(requestParameters: RepositoryApiRepoGetBranchRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetBranch(requestParameters.owner, requestParameters.repo, requestParameters.branch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific branch protection for the repository
     * @param {RepositoryApiRepoGetBranchProtectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetBranchProtection(requestParameters: RepositoryApiRepoGetBranchProtectionRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetBranchProtection(requestParameters.owner, requestParameters.repo, requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a repository by id
     * @param {RepositoryApiRepoGetByIDRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetByID(requestParameters: RepositoryApiRepoGetByIDRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetByID(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a commit\'s combined status, by branch/tag/commit reference
     * @param {RepositoryApiRepoGetCombinedStatusByRefRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetCombinedStatusByRef(requestParameters: RepositoryApiRepoGetCombinedStatusByRefRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetCombinedStatusByRef(requestParameters.owner, requestParameters.repo, requestParameters.ref, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir
     * @param {RepositoryApiRepoGetContentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetContents(requestParameters: RepositoryApiRepoGetContentsRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetContents(requestParameters.owner, requestParameters.repo, requestParameters.filepath, requestParameters.ref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the metadata of all the entries of the root dir
     * @param {RepositoryApiRepoGetContentsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetContentsList(requestParameters: RepositoryApiRepoGetContentsListRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetContentsList(requestParameters.owner, requestParameters.repo, requestParameters.ref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the EditorConfig definitions of a file in a repository
     * @param {RepositoryApiRepoGetEditorConfigRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetEditorConfig(requestParameters: RepositoryApiRepoGetEditorConfigRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetEditorConfig(requestParameters.owner, requestParameters.repo, requestParameters.filepath, requestParameters.ref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Git hook
     * @param {RepositoryApiRepoGetGitHookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetGitHook(requestParameters: RepositoryApiRepoGetGitHookRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetGitHook(requestParameters.owner, requestParameters.repo, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a hook
     * @param {RepositoryApiRepoGetHookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetHook(requestParameters: RepositoryApiRepoGetHookRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetHook(requestParameters.owner, requestParameters.repo, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get available issue templates for a repository
     * @param {RepositoryApiRepoGetIssueTemplatesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetIssueTemplates(requestParameters: RepositoryApiRepoGetIssueTemplatesRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetIssueTemplates(requestParameters.owner, requestParameters.repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a repository\'s key by id
     * @param {RepositoryApiRepoGetKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetKey(requestParameters: RepositoryApiRepoGetKeyRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetKey(requestParameters.owner, requestParameters.repo, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get languages and number of bytes of code written
     * @param {RepositoryApiRepoGetLanguagesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetLanguages(requestParameters: RepositoryApiRepoGetLanguagesRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetLanguages(requestParameters.owner, requestParameters.repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a note corresponding to a single commit from a repository
     * @param {RepositoryApiRepoGetNoteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetNote(requestParameters: RepositoryApiRepoGetNoteRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetNote(requestParameters.owner, requestParameters.repo, requestParameters.sha, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a pull request
     * @param {RepositoryApiRepoGetPullRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetPullRequest(requestParameters: RepositoryApiRepoGetPullRequestRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetPullRequest(requestParameters.owner, requestParameters.repo, requestParameters.index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get commits for a pull request
     * @param {RepositoryApiRepoGetPullRequestCommitsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetPullRequestCommits(requestParameters: RepositoryApiRepoGetPullRequestCommitsRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetPullRequestCommits(requestParameters.owner, requestParameters.repo, requestParameters.index, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific review for a pull request
     * @param {RepositoryApiRepoGetPullReviewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetPullReview(requestParameters: RepositoryApiRepoGetPullReviewRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetPullReview(requestParameters.owner, requestParameters.repo, requestParameters.index, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific review for a pull request
     * @param {RepositoryApiRepoGetPullReviewCommentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetPullReviewComments(requestParameters: RepositoryApiRepoGetPullReviewCommentsRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetPullReviewComments(requestParameters.owner, requestParameters.repo, requestParameters.index, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a file from a repository
     * @param {RepositoryApiRepoGetRawFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetRawFile(requestParameters: RepositoryApiRepoGetRawFileRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetRawFile(requestParameters.owner, requestParameters.repo, requestParameters.filepath, requestParameters.ref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a file or it\'s LFS object from a repository
     * @param {RepositoryApiRepoGetRawFileOrLFSRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetRawFileOrLFS(requestParameters: RepositoryApiRepoGetRawFileOrLFSRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetRawFileOrLFS(requestParameters.owner, requestParameters.repo, requestParameters.filepath, requestParameters.ref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a release
     * @param {RepositoryApiRepoGetReleaseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetRelease(requestParameters: RepositoryApiRepoGetReleaseRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetRelease(requestParameters.owner, requestParameters.repo, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a release attachment
     * @param {RepositoryApiRepoGetReleaseAttachmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetReleaseAttachment(requestParameters: RepositoryApiRepoGetReleaseAttachmentRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetReleaseAttachment(requestParameters.owner, requestParameters.repo, requestParameters.id, requestParameters.attachmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a release by tag name
     * @param {RepositoryApiRepoGetReleaseByTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetReleaseByTag(requestParameters: RepositoryApiRepoGetReleaseByTagRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetReleaseByTag(requestParameters.owner, requestParameters.repo, requestParameters.tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get repository permissions for a user
     * @param {RepositoryApiRepoGetRepoPermissionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetRepoPermissions(requestParameters: RepositoryApiRepoGetRepoPermissionsRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetRepoPermissions(requestParameters.owner, requestParameters.repo, requestParameters.collaborator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return all users that can be requested to review in this repo
     * @param {RepositoryApiRepoGetReviewersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetReviewers(requestParameters: RepositoryApiRepoGetReviewersRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetReviewers(requestParameters.owner, requestParameters.repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single commit from a repository
     * @param {RepositoryApiRepoGetSingleCommitRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetSingleCommit(requestParameters: RepositoryApiRepoGetSingleCommitRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetSingleCommit(requestParameters.owner, requestParameters.repo, requestParameters.sha, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the tag of a repository by tag name
     * @param {RepositoryApiRepoGetTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetTag(requestParameters: RepositoryApiRepoGetTagRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetTag(requestParameters.owner, requestParameters.repo, requestParameters.tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a wiki page
     * @param {RepositoryApiRepoGetWikiPageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetWikiPage(requestParameters: RepositoryApiRepoGetWikiPageRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetWikiPage(requestParameters.owner, requestParameters.repo, requestParameters.pageName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get revisions of a wiki page
     * @param {RepositoryApiRepoGetWikiPageRevisionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetWikiPageRevisions(requestParameters: RepositoryApiRepoGetWikiPageRevisionsRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetWikiPageRevisions(requestParameters.owner, requestParameters.repo, requestParameters.pageName, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all wiki pages
     * @param {RepositoryApiRepoGetWikiPagesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoGetWikiPages(requestParameters: RepositoryApiRepoGetWikiPagesRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoGetWikiPages(requestParameters.owner, requestParameters.repo, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get specified ref or filtered repository\'s refs
     * @param {RepositoryApiRepoListAllGitRefsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListAllGitRefs(requestParameters: RepositoryApiRepoListAllGitRefsRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListAllGitRefs(requestParameters.owner, requestParameters.repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List branch protections for a repository
     * @param {RepositoryApiRepoListBranchProtectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListBranchProtection(requestParameters: RepositoryApiRepoListBranchProtectionRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListBranchProtection(requestParameters.owner, requestParameters.repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repository\'s branches
     * @param {RepositoryApiRepoListBranchesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListBranches(requestParameters: RepositoryApiRepoListBranchesRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListBranches(requestParameters.owner, requestParameters.repo, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repository\'s collaborators
     * @param {RepositoryApiRepoListCollaboratorsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListCollaborators(requestParameters: RepositoryApiRepoListCollaboratorsRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListCollaborators(requestParameters.owner, requestParameters.repo, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the Git hooks in a repository
     * @param {RepositoryApiRepoListGitHooksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListGitHooks(requestParameters: RepositoryApiRepoListGitHooksRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListGitHooks(requestParameters.owner, requestParameters.repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get specified ref or filtered repository\'s refs
     * @param {RepositoryApiRepoListGitRefsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListGitRefs(requestParameters: RepositoryApiRepoListGitRefsRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListGitRefs(requestParameters.owner, requestParameters.repo, requestParameters.ref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the hooks in a repository
     * @param {RepositoryApiRepoListHooksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListHooks(requestParameters: RepositoryApiRepoListHooksRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListHooks(requestParameters.owner, requestParameters.repo, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repository\'s keys
     * @param {RepositoryApiRepoListKeysRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListKeys(requestParameters: RepositoryApiRepoListKeysRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListKeys(requestParameters.owner, requestParameters.repo, requestParameters.keyId, requestParameters.fingerprint, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repo\'s pull requests
     * @param {RepositoryApiRepoListPullRequestsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListPullRequests(requestParameters: RepositoryApiRepoListPullRequestsRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListPullRequests(requestParameters.owner, requestParameters.repo, requestParameters.state, requestParameters.sort, requestParameters.milestone, requestParameters.labels, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all reviews for a pull request
     * @param {RepositoryApiRepoListPullReviewsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListPullReviews(requestParameters: RepositoryApiRepoListPullReviewsRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListPullReviews(requestParameters.owner, requestParameters.repo, requestParameters.index, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List release\'s attachments
     * @param {RepositoryApiRepoListReleaseAttachmentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListReleaseAttachments(requestParameters: RepositoryApiRepoListReleaseAttachmentsRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListReleaseAttachments(requestParameters.owner, requestParameters.repo, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repo\'s releases
     * @param {RepositoryApiRepoListReleasesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListReleases(requestParameters: RepositoryApiRepoListReleasesRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListReleases(requestParameters.owner, requestParameters.repo, requestParameters.draft, requestParameters.preRelease, requestParameters.perPage, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repo\'s stargazers
     * @param {RepositoryApiRepoListStargazersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListStargazers(requestParameters: RepositoryApiRepoListStargazersRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListStargazers(requestParameters.owner, requestParameters.repo, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a commit\'s statuses
     * @param {RepositoryApiRepoListStatusesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListStatuses(requestParameters: RepositoryApiRepoListStatusesRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListStatuses(requestParameters.owner, requestParameters.repo, requestParameters.sha, requestParameters.sort, requestParameters.state, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a commit\'s statuses, by branch/tag/commit reference
     * @param {RepositoryApiRepoListStatusesByRefRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListStatusesByRef(requestParameters: RepositoryApiRepoListStatusesByRefRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListStatusesByRef(requestParameters.owner, requestParameters.repo, requestParameters.ref, requestParameters.sort, requestParameters.state, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repo\'s watchers
     * @param {RepositoryApiRepoListSubscribersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListSubscribers(requestParameters: RepositoryApiRepoListSubscribersRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListSubscribers(requestParameters.owner, requestParameters.repo, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repository\'s tags
     * @param {RepositoryApiRepoListTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListTags(requestParameters: RepositoryApiRepoListTagsRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListTags(requestParameters.owner, requestParameters.repo, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repository\'s teams
     * @param {RepositoryApiRepoListTeamsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListTeams(requestParameters: RepositoryApiRepoListTeamsRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListTeams(requestParameters.owner, requestParameters.repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get list of topics that a repository has
     * @param {RepositoryApiRepoListTopicsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoListTopics(requestParameters: RepositoryApiRepoListTopicsRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoListTopics(requestParameters.owner, requestParameters.repo, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Merge a pull request
     * @param {RepositoryApiRepoMergePullRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoMergePullRequest(requestParameters: RepositoryApiRepoMergePullRequestRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoMergePullRequest(requestParameters.owner, requestParameters.repo, requestParameters.index, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Migrate a remote git repository
     * @param {RepositoryApiRepoMigrateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoMigrate(requestParameters: RepositoryApiRepoMigrateRequest = {}, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoMigrate(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sync a mirrored repository
     * @param {RepositoryApiRepoMirrorSyncRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoMirrorSync(requestParameters: RepositoryApiRepoMirrorSyncRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoMirrorSync(requestParameters.owner, requestParameters.repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if a pull request has been merged
     * @param {RepositoryApiRepoPullRequestIsMergedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoPullRequestIsMerged(requestParameters: RepositoryApiRepoPullRequestIsMergedRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoPullRequestIsMerged(requestParameters.owner, requestParameters.repo, requestParameters.index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for repositories
     * @param {RepositoryApiRepoSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoSearch(requestParameters: RepositoryApiRepoSearchRequest = {}, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoSearch(requestParameters.q, requestParameters.topic, requestParameters.includeDesc, requestParameters.uid, requestParameters.priorityOwnerId, requestParameters.teamId, requestParameters.starredBy, requestParameters._private, requestParameters.isPrivate, requestParameters.template, requestParameters.archived, requestParameters.mode, requestParameters.exclusive, requestParameters.repo, requestParameters.owner, requestParameters.lang, requestParameters.subject, requestParameters.book, requestParameters.includeMetadata, requestParameters.sort, requestParameters.order, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get signing-key.gpg for given repository
     * @param {RepositoryApiRepoSigningKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoSigningKey(requestParameters: RepositoryApiRepoSigningKeyRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoSigningKey(requestParameters.owner, requestParameters.repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Submit a pending review to an pull request
     * @param {RepositoryApiRepoSubmitPullReviewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoSubmitPullReview(requestParameters: RepositoryApiRepoSubmitPullReviewRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoSubmitPullReview(requestParameters.owner, requestParameters.repo, requestParameters.index, requestParameters.id, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Test a push webhook
     * @param {RepositoryApiRepoTestHookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoTestHook(requestParameters: RepositoryApiRepoTestHookRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoTestHook(requestParameters.owner, requestParameters.repo, requestParameters.id, requestParameters.ref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repo\'s tracked times
     * @param {RepositoryApiRepoTrackedTimesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoTrackedTimes(requestParameters: RepositoryApiRepoTrackedTimesRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoTrackedTimes(requestParameters.owner, requestParameters.repo, requestParameters.user, requestParameters.since, requestParameters.before, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Transfer a repo ownership
     * @param {RepositoryApiRepoTransferRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoTransfer(requestParameters: RepositoryApiRepoTransferRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoTransfer(requestParameters.owner, requestParameters.repo, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancel to dismiss a review for a pull request
     * @param {RepositoryApiRepoUnDismissPullReviewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoUnDismissPullReview(requestParameters: RepositoryApiRepoUnDismissPullReviewRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoUnDismissPullReview(requestParameters.owner, requestParameters.repo, requestParameters.index, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a file in a repository
     * @param {RepositoryApiRepoUpdateFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoUpdateFile(requestParameters: RepositoryApiRepoUpdateFileRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoUpdateFile(requestParameters.owner, requestParameters.repo, requestParameters.filepath, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a reference
     * @param {RepositoryApiRepoUpdateGitRefRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoUpdateGitRef(requestParameters: RepositoryApiRepoUpdateGitRefRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoUpdateGitRef(requestParameters.owner, requestParameters.repo, requestParameters.ref, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Merge PR\'s baseBranch into headBranch
     * @param {RepositoryApiRepoUpdatePullRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoUpdatePullRequest(requestParameters: RepositoryApiRepoUpdatePullRequestRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoUpdatePullRequest(requestParameters.owner, requestParameters.repo, requestParameters.index, requestParameters.style, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Replace list of topics for a repository
     * @param {RepositoryApiRepoUpdateTopicsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public repoUpdateTopics(requestParameters: RepositoryApiRepoUpdateTopicsRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).repoUpdateTopics(requestParameters.owner, requestParameters.repo, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary search topics via keyword
     * @param {RepositoryApiTopicSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public topicSearch(requestParameters: RepositoryApiTopicSearchRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).topicSearch(requestParameters.q, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if the current user is watching a repo
     * @param {RepositoryApiUserCurrentCheckSubscriptionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public userCurrentCheckSubscription(requestParameters: RepositoryApiUserCurrentCheckSubscriptionRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).userCurrentCheckSubscription(requestParameters.owner, requestParameters.repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unwatch a repo
     * @param {RepositoryApiUserCurrentDeleteSubscriptionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public userCurrentDeleteSubscription(requestParameters: RepositoryApiUserCurrentDeleteSubscriptionRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).userCurrentDeleteSubscription(requestParameters.owner, requestParameters.repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Watch a repo
     * @param {RepositoryApiUserCurrentPutSubscriptionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public userCurrentPutSubscription(requestParameters: RepositoryApiUserCurrentPutSubscriptionRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).userCurrentPutSubscription(requestParameters.owner, requestParameters.repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a user\'s tracked times in a repo
     * @param {RepositoryApiUserTrackedTimesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public userTrackedTimes(requestParameters: RepositoryApiUserTrackedTimesRequest, options?: AxiosRequestConfig) {
        return RepositoryApiFp(this.configuration).userTrackedTimes(requestParameters.owner, requestParameters.repo, requestParameters.user, options).then((request) => request(this.axios, this.basePath));
    }
}
