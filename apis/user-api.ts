/* tslint:disable */
/* eslint-disable */
/**
 * DCS (Gitea) API.
 * This documentation describes the DCS (Gitea) API.
 *
 * The version of the OpenAPI document: 1.17.4+dcs
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AccessToken } from '../models';
// @ts-ignore
import { CreateAccessTokenOption } from '../models';
// @ts-ignore
import { CreateEmailOption } from '../models';
// @ts-ignore
import { CreateGPGKeyOption } from '../models';
// @ts-ignore
import { CreateKeyOption } from '../models';
// @ts-ignore
import { CreateOAuth2ApplicationOptions } from '../models';
// @ts-ignore
import { CreateRepoOption } from '../models';
// @ts-ignore
import { DeleteEmailOption } from '../models';
// @ts-ignore
import { Email } from '../models';
// @ts-ignore
import { GPGKey } from '../models';
// @ts-ignore
import { OAuth2Application } from '../models';
// @ts-ignore
import { PublicKey } from '../models';
// @ts-ignore
import { Repository } from '../models';
// @ts-ignore
import { StopWatch } from '../models';
// @ts-ignore
import { Team } from '../models';
// @ts-ignore
import { TrackedTime } from '../models';
// @ts-ignore
import { User } from '../models';
// @ts-ignore
import { UserHeatmapData } from '../models';
// @ts-ignore
import { UserSearch200Response } from '../models';
// @ts-ignore
import { UserSettings } from '../models';
// @ts-ignore
import { UserSettingsOptions } from '../models';
/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a repository
         * @param {CreateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCurrentUserRepo: async (body?: CreateRepoOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/repos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSettings: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Token to verify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVerificationToken: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/gpg_key_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user settings
         * @param {UserSettingsOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserSettings: async (body?: UserSettingsOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add email addresses
         * @param {CreateEmailOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAddEmail: async (body?: CreateEmailOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/emails`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if one user is following another user
         * @param {string} username username of following user
         * @param {string} target username of followed user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCheckFollowing: async (username: string, target: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userCheckFollowing', 'username', username)
            // verify required parameter 'target' is not null or undefined
            assertParamExists('userCheckFollowing', 'target', target)
            const localVarPath = `/users/{username}/following/{target}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)))
                .replace(`{${"target"}}`, encodeURIComponent(String(target)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary creates a new OAuth2 application
         * @param {CreateOAuth2ApplicationOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreateOAuth2Application: async (body: CreateOAuth2ApplicationOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('userCreateOAuth2Application', 'body', body)
            const localVarPath = `/user/applications/oauth2`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an access token
         * @param {string} username username of user
         * @param {CreateAccessTokenOption} [userCreateToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreateToken: async (username: string, userCreateToken?: CreateAccessTokenOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userCreateToken', 'username', username)
            const localVarPath = `/users/{username}/tokens`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreateToken, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check whether a user is followed by the authenticated user
         * @param {string} username username of followed user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentCheckFollowing: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userCurrentCheckFollowing', 'username', username)
            const localVarPath = `/user/following/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Whether the authenticated is starring the repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentCheckStarring: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('userCurrentCheckStarring', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('userCurrentCheckStarring', 'repo', repo)
            const localVarPath = `/user/starred/{owner}/{repo}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unfollow a user
         * @param {string} username username of user to unfollow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentDeleteFollow: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userCurrentDeleteFollow', 'username', username)
            const localVarPath = `/user/following/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a GPG key
         * @param {number} id id of key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentDeleteGPGKey: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userCurrentDeleteGPGKey', 'id', id)
            const localVarPath = `/user/gpg_keys/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a public key
         * @param {number} id id of key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentDeleteKey: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userCurrentDeleteKey', 'id', id)
            const localVarPath = `/user/keys/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unstar the given repo
         * @param {string} owner owner of the repo to unstar
         * @param {string} repo name of the repo to unstar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentDeleteStar: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('userCurrentDeleteStar', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('userCurrentDeleteStar', 'repo', repo)
            const localVarPath = `/user/starred/{owner}/{repo}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a GPG key
         * @param {number} id id of key to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentGetGPGKey: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userCurrentGetGPGKey', 'id', id)
            const localVarPath = `/user/gpg_keys/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a public key
         * @param {number} id id of key to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentGetKey: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userCurrentGetKey', 'id', id)
            const localVarPath = `/user/keys/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the authenticated user\'s followers
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListFollowers: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/followers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the users that the authenticated user is following
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListFollowing: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/following`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the authenticated user\'s GPG keys
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListGPGKeys: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/gpg_keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the authenticated user\'s public keys
         * @param {string} [fingerprint] fingerprint of the key
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListKeys: async (fingerprint?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (fingerprint !== undefined) {
                localVarQueryParameter['fingerprint'] = fingerprint;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the repos that the authenticated user owns
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListRepos: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/repos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary The repos that the authenticated user has starred
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListStarred: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/starred`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List repositories watched by the authenticated user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListSubscriptions: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a GPG key
         * @param {CreateGPGKeyOption} [form] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentPostGPGKey: async (form?: CreateGPGKeyOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/gpg_keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(form, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a public key
         * @param {CreateKeyOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentPostKey: async (body?: CreateKeyOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Follow a user
         * @param {string} username username of user to follow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentPutFollow: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userCurrentPutFollow', 'username', username)
            const localVarPath = `/user/following/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Star the given repo
         * @param {string} owner owner of the repo to star
         * @param {string} repo name of the repo to star
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentPutStar: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('userCurrentPutStar', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('userCurrentPutStar', 'repo', repo)
            const localVarPath = `/user/starred/{owner}/{repo}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the current user\'s tracked times
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentTrackedTimes: async (page?: number, limit?: number, since?: string, before?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/times`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any instanceof Date) ?
                    (since as any).toISOString() :
                    since;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any instanceof Date) ?
                    (before as any).toISOString() :
                    before;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete an access token
         * @param {string} username username of user
         * @param {string} token token to be deleted, identified by ID and if not available by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteAccessToken: async (username: string, token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userDeleteAccessToken', 'username', username)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('userDeleteAccessToken', 'token', token)
            const localVarPath = `/users/{username}/tokens/{token}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)))
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete email addresses
         * @param {DeleteEmailOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteEmail: async (body?: DeleteEmailOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/emails`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete an OAuth2 Application
         * @param {number} id token to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteOAuth2Application: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userDeleteOAuth2Application', 'id', id)
            const localVarPath = `/user/applications/oauth2/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user
         * @param {string} username username of user to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGet: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userGet', 'username', username)
            const localVarPath = `/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetCurrent: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user\'s heatmap
         * @param {string} username username of user to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetHeatmapData: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userGetHeatmapData', 'username', username)
            const localVarPath = `/users/{username}/heatmap`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get an OAuth2 Application
         * @param {number} id Application ID to be found
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetOAuth2Application: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userGetOAuth2Application', 'id', id)
            const localVarPath = `/user/applications/oauth2/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the authenticated user\'s oauth2 applications
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetOauth2Application: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/applications/oauth2`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of all existing stopwatches
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetStopWatches: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/stopwatches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the authenticated user\'s access tokens
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetTokens: async (username: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userGetTokens', 'username', username)
            const localVarPath = `/users/{username}/tokens`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the authenticated user\'s email addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListEmails: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/emails`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the given user\'s followers
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListFollowers: async (username: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userListFollowers', 'username', username)
            const localVarPath = `/users/{username}/followers`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the users that the given user is following
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListFollowing: async (username: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userListFollowing', 'username', username)
            const localVarPath = `/users/{username}/following`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the given user\'s GPG keys
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListGPGKeys: async (username: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userListGPGKeys', 'username', username)
            const localVarPath = `/users/{username}/gpg_keys`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the given user\'s public keys
         * @param {string} username username of user
         * @param {string} [fingerprint] fingerprint of the key
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListKeys: async (username: string, fingerprint?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userListKeys', 'username', username)
            const localVarPath = `/users/{username}/keys`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (fingerprint !== undefined) {
                localVarQueryParameter['fingerprint'] = fingerprint;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the repos owned by the given user
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListRepos: async (username: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userListRepos', 'username', username)
            const localVarPath = `/users/{username}/repos`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary The repos that the given user has starred
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListStarred: async (username: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userListStarred', 'username', username)
            const localVarPath = `/users/{username}/starred`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the repositories watched by a user
         * @param {string} username username of the user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListSubscriptions: async (username: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userListSubscriptions', 'username', username)
            const localVarPath = `/users/{username}/subscriptions`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all the teams a user belongs to
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListTeams: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for users
         * @param {string} [q] keyword
         * @param {number} [uid] ID of the user to search for
         * @param {string} [lang] If the user has one or more repos with the given language(s), the org will be in the results. Multiple lang\&#39;s are ORed.
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSearch: async (q?: string, uid?: number, lang?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (uid !== undefined) {
                localVarQueryParameter['uid'] = uid;
            }

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update an OAuth2 Application, this includes regenerating the client secret
         * @param {number} id application to be updated
         * @param {CreateOAuth2ApplicationOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdateOAuth2Application: async (id: number, body: CreateOAuth2ApplicationOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userUpdateOAuth2Application', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('userUpdateOAuth2Application', 'body', body)
            const localVarPath = `/user/applications/oauth2/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verify a GPG key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userVerifyGPGKey: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/gpg_key_verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-GITEA-OTP", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a repository
         * @param {CreateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCurrentUserRepo(body?: CreateRepoOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCurrentUserRepo(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get user settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserSettings(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserSettings>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserSettings(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Token to verify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVerificationToken(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVerificationToken(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update user settings
         * @param {UserSettingsOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserSettings(body?: UserSettingsOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserSettings>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserSettings(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add email addresses
         * @param {CreateEmailOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAddEmail(body?: CreateEmailOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Email>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAddEmail(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check if one user is following another user
         * @param {string} username username of following user
         * @param {string} target username of followed user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCheckFollowing(username: string, target: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCheckFollowing(username, target, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary creates a new OAuth2 application
         * @param {CreateOAuth2ApplicationOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCreateOAuth2Application(body: CreateOAuth2ApplicationOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuth2Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCreateOAuth2Application(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create an access token
         * @param {string} username username of user
         * @param {CreateAccessTokenOption} [userCreateToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCreateToken(username: string, userCreateToken?: CreateAccessTokenOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCreateToken(username, userCreateToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check whether a user is followed by the authenticated user
         * @param {string} username username of followed user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentCheckFollowing(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentCheckFollowing(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Whether the authenticated is starring the repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentCheckStarring(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentCheckStarring(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unfollow a user
         * @param {string} username username of user to unfollow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentDeleteFollow(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentDeleteFollow(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a GPG key
         * @param {number} id id of key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentDeleteGPGKey(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentDeleteGPGKey(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a public key
         * @param {number} id id of key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentDeleteKey(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentDeleteKey(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unstar the given repo
         * @param {string} owner owner of the repo to unstar
         * @param {string} repo name of the repo to unstar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentDeleteStar(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentDeleteStar(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a GPG key
         * @param {number} id id of key to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentGetGPGKey(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GPGKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentGetGPGKey(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a public key
         * @param {number} id id of key to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentGetKey(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentGetKey(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the authenticated user\'s followers
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentListFollowers(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentListFollowers(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the users that the authenticated user is following
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentListFollowing(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentListFollowing(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the authenticated user\'s GPG keys
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentListGPGKeys(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GPGKey>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentListGPGKeys(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the authenticated user\'s public keys
         * @param {string} [fingerprint] fingerprint of the key
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentListKeys(fingerprint?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PublicKey>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentListKeys(fingerprint, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the repos that the authenticated user owns
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentListRepos(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Repository>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentListRepos(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary The repos that the authenticated user has starred
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentListStarred(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Repository>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentListStarred(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List repositories watched by the authenticated user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentListSubscriptions(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Repository>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentListSubscriptions(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a GPG key
         * @param {CreateGPGKeyOption} [form] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentPostGPGKey(form?: CreateGPGKeyOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GPGKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentPostGPGKey(form, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a public key
         * @param {CreateKeyOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentPostKey(body?: CreateKeyOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentPostKey(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Follow a user
         * @param {string} username username of user to follow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentPutFollow(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentPutFollow(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Star the given repo
         * @param {string} owner owner of the repo to star
         * @param {string} repo name of the repo to star
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentPutStar(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentPutStar(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the current user\'s tracked times
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentTrackedTimes(page?: number, limit?: number, since?: string, before?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TrackedTime>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentTrackedTimes(page, limit, since, before, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary delete an access token
         * @param {string} username username of user
         * @param {string} token token to be deleted, identified by ID and if not available by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userDeleteAccessToken(username: string, token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userDeleteAccessToken(username, token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete email addresses
         * @param {DeleteEmailOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userDeleteEmail(body?: DeleteEmailOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userDeleteEmail(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary delete an OAuth2 Application
         * @param {number} id token to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userDeleteOAuth2Application(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userDeleteOAuth2Application(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a user
         * @param {string} username username of user to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGet(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGet(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetCurrent(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetCurrent(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a user\'s heatmap
         * @param {string} username username of user to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetHeatmapData(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserHeatmapData>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetHeatmapData(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get an OAuth2 Application
         * @param {number} id Application ID to be found
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetOAuth2Application(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuth2Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetOAuth2Application(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the authenticated user\'s oauth2 applications
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetOauth2Application(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OAuth2Application>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetOauth2Application(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get list of all existing stopwatches
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetStopWatches(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StopWatch>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetStopWatches(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the authenticated user\'s access tokens
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetTokens(username: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccessToken>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetTokens(username, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the authenticated user\'s email addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userListEmails(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Email>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userListEmails(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the given user\'s followers
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userListFollowers(username: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userListFollowers(username, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the users that the given user is following
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userListFollowing(username: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userListFollowing(username, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the given user\'s GPG keys
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userListGPGKeys(username: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GPGKey>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userListGPGKeys(username, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the given user\'s public keys
         * @param {string} username username of user
         * @param {string} [fingerprint] fingerprint of the key
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userListKeys(username: string, fingerprint?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PublicKey>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userListKeys(username, fingerprint, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the repos owned by the given user
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userListRepos(username: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Repository>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userListRepos(username, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary The repos that the given user has starred
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userListStarred(username: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Repository>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userListStarred(username, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the repositories watched by a user
         * @param {string} username username of the user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userListSubscriptions(username: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Repository>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userListSubscriptions(username, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all the teams a user belongs to
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userListTeams(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Team>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userListTeams(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search for users
         * @param {string} [q] keyword
         * @param {number} [uid] ID of the user to search for
         * @param {string} [lang] If the user has one or more repos with the given language(s), the org will be in the results. Multiple lang\&#39;s are ORed.
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSearch(q?: string, uid?: number, lang?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSearch200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSearch(q, uid, lang, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary update an OAuth2 Application, this includes regenerating the client secret
         * @param {number} id application to be updated
         * @param {CreateOAuth2ApplicationOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userUpdateOAuth2Application(id: number, body: CreateOAuth2ApplicationOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuth2Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userUpdateOAuth2Application(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Verify a GPG key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userVerifyGPGKey(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GPGKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userVerifyGPGKey(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a repository
         * @param {CreateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCurrentUserRepo(body?: CreateRepoOption, options?: any): AxiosPromise<Repository> {
            return localVarFp.createCurrentUserRepo(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSettings(options?: any): AxiosPromise<Array<UserSettings>> {
            return localVarFp.getUserSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Token to verify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVerificationToken(options?: any): AxiosPromise<string> {
            return localVarFp.getVerificationToken(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user settings
         * @param {UserSettingsOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserSettings(body?: UserSettingsOptions, options?: any): AxiosPromise<Array<UserSettings>> {
            return localVarFp.updateUserSettings(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add email addresses
         * @param {CreateEmailOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAddEmail(body?: CreateEmailOption, options?: any): AxiosPromise<Array<Email>> {
            return localVarFp.userAddEmail(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if one user is following another user
         * @param {string} username username of following user
         * @param {string} target username of followed user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCheckFollowing(username: string, target: string, options?: any): AxiosPromise<void> {
            return localVarFp.userCheckFollowing(username, target, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary creates a new OAuth2 application
         * @param {CreateOAuth2ApplicationOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreateOAuth2Application(body: CreateOAuth2ApplicationOptions, options?: any): AxiosPromise<OAuth2Application> {
            return localVarFp.userCreateOAuth2Application(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an access token
         * @param {string} username username of user
         * @param {CreateAccessTokenOption} [userCreateToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreateToken(username: string, userCreateToken?: CreateAccessTokenOption, options?: any): AxiosPromise<AccessToken> {
            return localVarFp.userCreateToken(username, userCreateToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check whether a user is followed by the authenticated user
         * @param {string} username username of followed user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentCheckFollowing(username: string, options?: any): AxiosPromise<void> {
            return localVarFp.userCurrentCheckFollowing(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Whether the authenticated is starring the repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentCheckStarring(owner: string, repo: string, options?: any): AxiosPromise<void> {
            return localVarFp.userCurrentCheckStarring(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unfollow a user
         * @param {string} username username of user to unfollow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentDeleteFollow(username: string, options?: any): AxiosPromise<void> {
            return localVarFp.userCurrentDeleteFollow(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a GPG key
         * @param {number} id id of key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentDeleteGPGKey(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.userCurrentDeleteGPGKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a public key
         * @param {number} id id of key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentDeleteKey(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.userCurrentDeleteKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unstar the given repo
         * @param {string} owner owner of the repo to unstar
         * @param {string} repo name of the repo to unstar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentDeleteStar(owner: string, repo: string, options?: any): AxiosPromise<void> {
            return localVarFp.userCurrentDeleteStar(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a GPG key
         * @param {number} id id of key to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentGetGPGKey(id: number, options?: any): AxiosPromise<GPGKey> {
            return localVarFp.userCurrentGetGPGKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a public key
         * @param {number} id id of key to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentGetKey(id: number, options?: any): AxiosPromise<PublicKey> {
            return localVarFp.userCurrentGetKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the authenticated user\'s followers
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListFollowers(page?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.userCurrentListFollowers(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the users that the authenticated user is following
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListFollowing(page?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.userCurrentListFollowing(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the authenticated user\'s GPG keys
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListGPGKeys(page?: number, limit?: number, options?: any): AxiosPromise<Array<GPGKey>> {
            return localVarFp.userCurrentListGPGKeys(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the authenticated user\'s public keys
         * @param {string} [fingerprint] fingerprint of the key
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListKeys(fingerprint?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<PublicKey>> {
            return localVarFp.userCurrentListKeys(fingerprint, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the repos that the authenticated user owns
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListRepos(page?: number, limit?: number, options?: any): AxiosPromise<Array<Repository>> {
            return localVarFp.userCurrentListRepos(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary The repos that the authenticated user has starred
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListStarred(page?: number, limit?: number, options?: any): AxiosPromise<Array<Repository>> {
            return localVarFp.userCurrentListStarred(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List repositories watched by the authenticated user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListSubscriptions(page?: number, limit?: number, options?: any): AxiosPromise<Array<Repository>> {
            return localVarFp.userCurrentListSubscriptions(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a GPG key
         * @param {CreateGPGKeyOption} [form] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentPostGPGKey(form?: CreateGPGKeyOption, options?: any): AxiosPromise<GPGKey> {
            return localVarFp.userCurrentPostGPGKey(form, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a public key
         * @param {CreateKeyOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentPostKey(body?: CreateKeyOption, options?: any): AxiosPromise<PublicKey> {
            return localVarFp.userCurrentPostKey(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Follow a user
         * @param {string} username username of user to follow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentPutFollow(username: string, options?: any): AxiosPromise<void> {
            return localVarFp.userCurrentPutFollow(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Star the given repo
         * @param {string} owner owner of the repo to star
         * @param {string} repo name of the repo to star
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentPutStar(owner: string, repo: string, options?: any): AxiosPromise<void> {
            return localVarFp.userCurrentPutStar(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the current user\'s tracked times
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentTrackedTimes(page?: number, limit?: number, since?: string, before?: string, options?: any): AxiosPromise<Array<TrackedTime>> {
            return localVarFp.userCurrentTrackedTimes(page, limit, since, before, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary delete an access token
         * @param {string} username username of user
         * @param {string} token token to be deleted, identified by ID and if not available by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteAccessToken(username: string, token: string, options?: any): AxiosPromise<void> {
            return localVarFp.userDeleteAccessToken(username, token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete email addresses
         * @param {DeleteEmailOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteEmail(body?: DeleteEmailOption, options?: any): AxiosPromise<void> {
            return localVarFp.userDeleteEmail(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary delete an OAuth2 Application
         * @param {number} id token to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteOAuth2Application(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.userDeleteOAuth2Application(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user
         * @param {string} username username of user to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGet(username: string, options?: any): AxiosPromise<User> {
            return localVarFp.userGet(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetCurrent(options?: any): AxiosPromise<User> {
            return localVarFp.userGetCurrent(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user\'s heatmap
         * @param {string} username username of user to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetHeatmapData(username: string, options?: any): AxiosPromise<Array<UserHeatmapData>> {
            return localVarFp.userGetHeatmapData(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get an OAuth2 Application
         * @param {number} id Application ID to be found
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetOAuth2Application(id: number, options?: any): AxiosPromise<OAuth2Application> {
            return localVarFp.userGetOAuth2Application(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the authenticated user\'s oauth2 applications
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetOauth2Application(page?: number, limit?: number, options?: any): AxiosPromise<Array<OAuth2Application>> {
            return localVarFp.userGetOauth2Application(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get list of all existing stopwatches
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetStopWatches(page?: number, limit?: number, options?: any): AxiosPromise<Array<StopWatch>> {
            return localVarFp.userGetStopWatches(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the authenticated user\'s access tokens
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetTokens(username: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<AccessToken>> {
            return localVarFp.userGetTokens(username, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the authenticated user\'s email addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListEmails(options?: any): AxiosPromise<Array<Email>> {
            return localVarFp.userListEmails(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the given user\'s followers
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListFollowers(username: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.userListFollowers(username, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the users that the given user is following
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListFollowing(username: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.userListFollowing(username, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the given user\'s GPG keys
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListGPGKeys(username: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<GPGKey>> {
            return localVarFp.userListGPGKeys(username, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the given user\'s public keys
         * @param {string} username username of user
         * @param {string} [fingerprint] fingerprint of the key
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListKeys(username: string, fingerprint?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<PublicKey>> {
            return localVarFp.userListKeys(username, fingerprint, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the repos owned by the given user
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListRepos(username: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Repository>> {
            return localVarFp.userListRepos(username, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary The repos that the given user has starred
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListStarred(username: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Repository>> {
            return localVarFp.userListStarred(username, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the repositories watched by a user
         * @param {string} username username of the user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListSubscriptions(username: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Repository>> {
            return localVarFp.userListSubscriptions(username, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all the teams a user belongs to
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListTeams(page?: number, limit?: number, options?: any): AxiosPromise<Array<Team>> {
            return localVarFp.userListTeams(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for users
         * @param {string} [q] keyword
         * @param {number} [uid] ID of the user to search for
         * @param {string} [lang] If the user has one or more repos with the given language(s), the org will be in the results. Multiple lang\&#39;s are ORed.
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSearch(q?: string, uid?: number, lang?: string, page?: number, limit?: number, options?: any): AxiosPromise<UserSearch200Response> {
            return localVarFp.userSearch(q, uid, lang, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary update an OAuth2 Application, this includes regenerating the client secret
         * @param {number} id application to be updated
         * @param {CreateOAuth2ApplicationOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdateOAuth2Application(id: number, body: CreateOAuth2ApplicationOptions, options?: any): AxiosPromise<OAuth2Application> {
            return localVarFp.userUpdateOAuth2Application(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Verify a GPG key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userVerifyGPGKey(options?: any): AxiosPromise<GPGKey> {
            return localVarFp.userVerifyGPGKey(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCurrentUserRepo operation in UserApi.
 * @export
 * @interface UserApiCreateCurrentUserRepoRequest
 */
export interface UserApiCreateCurrentUserRepoRequest {
    /**
     * 
     * @type {CreateRepoOption}
     * @memberof UserApiCreateCurrentUserRepo
     */
    readonly body?: CreateRepoOption
}

/**
 * Request parameters for updateUserSettings operation in UserApi.
 * @export
 * @interface UserApiUpdateUserSettingsRequest
 */
export interface UserApiUpdateUserSettingsRequest {
    /**
     * 
     * @type {UserSettingsOptions}
     * @memberof UserApiUpdateUserSettings
     */
    readonly body?: UserSettingsOptions
}

/**
 * Request parameters for userAddEmail operation in UserApi.
 * @export
 * @interface UserApiUserAddEmailRequest
 */
export interface UserApiUserAddEmailRequest {
    /**
     * 
     * @type {CreateEmailOption}
     * @memberof UserApiUserAddEmail
     */
    readonly body?: CreateEmailOption
}

/**
 * Request parameters for userCheckFollowing operation in UserApi.
 * @export
 * @interface UserApiUserCheckFollowingRequest
 */
export interface UserApiUserCheckFollowingRequest {
    /**
     * username of following user
     * @type {string}
     * @memberof UserApiUserCheckFollowing
     */
    readonly username: string

    /**
     * username of followed user
     * @type {string}
     * @memberof UserApiUserCheckFollowing
     */
    readonly target: string
}

/**
 * Request parameters for userCreateOAuth2Application operation in UserApi.
 * @export
 * @interface UserApiUserCreateOAuth2ApplicationRequest
 */
export interface UserApiUserCreateOAuth2ApplicationRequest {
    /**
     * 
     * @type {CreateOAuth2ApplicationOptions}
     * @memberof UserApiUserCreateOAuth2Application
     */
    readonly body: CreateOAuth2ApplicationOptions
}

/**
 * Request parameters for userCreateToken operation in UserApi.
 * @export
 * @interface UserApiUserCreateTokenRequest
 */
export interface UserApiUserCreateTokenRequest {
    /**
     * username of user
     * @type {string}
     * @memberof UserApiUserCreateToken
     */
    readonly username: string

    /**
     * 
     * @type {CreateAccessTokenOption}
     * @memberof UserApiUserCreateToken
     */
    readonly userCreateToken?: CreateAccessTokenOption
}

/**
 * Request parameters for userCurrentCheckFollowing operation in UserApi.
 * @export
 * @interface UserApiUserCurrentCheckFollowingRequest
 */
export interface UserApiUserCurrentCheckFollowingRequest {
    /**
     * username of followed user
     * @type {string}
     * @memberof UserApiUserCurrentCheckFollowing
     */
    readonly username: string
}

/**
 * Request parameters for userCurrentCheckStarring operation in UserApi.
 * @export
 * @interface UserApiUserCurrentCheckStarringRequest
 */
export interface UserApiUserCurrentCheckStarringRequest {
    /**
     * owner of the repo
     * @type {string}
     * @memberof UserApiUserCurrentCheckStarring
     */
    readonly owner: string

    /**
     * name of the repo
     * @type {string}
     * @memberof UserApiUserCurrentCheckStarring
     */
    readonly repo: string
}

/**
 * Request parameters for userCurrentDeleteFollow operation in UserApi.
 * @export
 * @interface UserApiUserCurrentDeleteFollowRequest
 */
export interface UserApiUserCurrentDeleteFollowRequest {
    /**
     * username of user to unfollow
     * @type {string}
     * @memberof UserApiUserCurrentDeleteFollow
     */
    readonly username: string
}

/**
 * Request parameters for userCurrentDeleteGPGKey operation in UserApi.
 * @export
 * @interface UserApiUserCurrentDeleteGPGKeyRequest
 */
export interface UserApiUserCurrentDeleteGPGKeyRequest {
    /**
     * id of key to delete
     * @type {number}
     * @memberof UserApiUserCurrentDeleteGPGKey
     */
    readonly id: number
}

/**
 * Request parameters for userCurrentDeleteKey operation in UserApi.
 * @export
 * @interface UserApiUserCurrentDeleteKeyRequest
 */
export interface UserApiUserCurrentDeleteKeyRequest {
    /**
     * id of key to delete
     * @type {number}
     * @memberof UserApiUserCurrentDeleteKey
     */
    readonly id: number
}

/**
 * Request parameters for userCurrentDeleteStar operation in UserApi.
 * @export
 * @interface UserApiUserCurrentDeleteStarRequest
 */
export interface UserApiUserCurrentDeleteStarRequest {
    /**
     * owner of the repo to unstar
     * @type {string}
     * @memberof UserApiUserCurrentDeleteStar
     */
    readonly owner: string

    /**
     * name of the repo to unstar
     * @type {string}
     * @memberof UserApiUserCurrentDeleteStar
     */
    readonly repo: string
}

/**
 * Request parameters for userCurrentGetGPGKey operation in UserApi.
 * @export
 * @interface UserApiUserCurrentGetGPGKeyRequest
 */
export interface UserApiUserCurrentGetGPGKeyRequest {
    /**
     * id of key to get
     * @type {number}
     * @memberof UserApiUserCurrentGetGPGKey
     */
    readonly id: number
}

/**
 * Request parameters for userCurrentGetKey operation in UserApi.
 * @export
 * @interface UserApiUserCurrentGetKeyRequest
 */
export interface UserApiUserCurrentGetKeyRequest {
    /**
     * id of key to get
     * @type {number}
     * @memberof UserApiUserCurrentGetKey
     */
    readonly id: number
}

/**
 * Request parameters for userCurrentListFollowers operation in UserApi.
 * @export
 * @interface UserApiUserCurrentListFollowersRequest
 */
export interface UserApiUserCurrentListFollowersRequest {
    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof UserApiUserCurrentListFollowers
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof UserApiUserCurrentListFollowers
     */
    readonly limit?: number
}

/**
 * Request parameters for userCurrentListFollowing operation in UserApi.
 * @export
 * @interface UserApiUserCurrentListFollowingRequest
 */
export interface UserApiUserCurrentListFollowingRequest {
    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof UserApiUserCurrentListFollowing
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof UserApiUserCurrentListFollowing
     */
    readonly limit?: number
}

/**
 * Request parameters for userCurrentListGPGKeys operation in UserApi.
 * @export
 * @interface UserApiUserCurrentListGPGKeysRequest
 */
export interface UserApiUserCurrentListGPGKeysRequest {
    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof UserApiUserCurrentListGPGKeys
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof UserApiUserCurrentListGPGKeys
     */
    readonly limit?: number
}

/**
 * Request parameters for userCurrentListKeys operation in UserApi.
 * @export
 * @interface UserApiUserCurrentListKeysRequest
 */
export interface UserApiUserCurrentListKeysRequest {
    /**
     * fingerprint of the key
     * @type {string}
     * @memberof UserApiUserCurrentListKeys
     */
    readonly fingerprint?: string

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof UserApiUserCurrentListKeys
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof UserApiUserCurrentListKeys
     */
    readonly limit?: number
}

/**
 * Request parameters for userCurrentListRepos operation in UserApi.
 * @export
 * @interface UserApiUserCurrentListReposRequest
 */
export interface UserApiUserCurrentListReposRequest {
    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof UserApiUserCurrentListRepos
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof UserApiUserCurrentListRepos
     */
    readonly limit?: number
}

/**
 * Request parameters for userCurrentListStarred operation in UserApi.
 * @export
 * @interface UserApiUserCurrentListStarredRequest
 */
export interface UserApiUserCurrentListStarredRequest {
    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof UserApiUserCurrentListStarred
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof UserApiUserCurrentListStarred
     */
    readonly limit?: number
}

/**
 * Request parameters for userCurrentListSubscriptions operation in UserApi.
 * @export
 * @interface UserApiUserCurrentListSubscriptionsRequest
 */
export interface UserApiUserCurrentListSubscriptionsRequest {
    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof UserApiUserCurrentListSubscriptions
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof UserApiUserCurrentListSubscriptions
     */
    readonly limit?: number
}

/**
 * Request parameters for userCurrentPostGPGKey operation in UserApi.
 * @export
 * @interface UserApiUserCurrentPostGPGKeyRequest
 */
export interface UserApiUserCurrentPostGPGKeyRequest {
    /**
     * 
     * @type {CreateGPGKeyOption}
     * @memberof UserApiUserCurrentPostGPGKey
     */
    readonly form?: CreateGPGKeyOption
}

/**
 * Request parameters for userCurrentPostKey operation in UserApi.
 * @export
 * @interface UserApiUserCurrentPostKeyRequest
 */
export interface UserApiUserCurrentPostKeyRequest {
    /**
     * 
     * @type {CreateKeyOption}
     * @memberof UserApiUserCurrentPostKey
     */
    readonly body?: CreateKeyOption
}

/**
 * Request parameters for userCurrentPutFollow operation in UserApi.
 * @export
 * @interface UserApiUserCurrentPutFollowRequest
 */
export interface UserApiUserCurrentPutFollowRequest {
    /**
     * username of user to follow
     * @type {string}
     * @memberof UserApiUserCurrentPutFollow
     */
    readonly username: string
}

/**
 * Request parameters for userCurrentPutStar operation in UserApi.
 * @export
 * @interface UserApiUserCurrentPutStarRequest
 */
export interface UserApiUserCurrentPutStarRequest {
    /**
     * owner of the repo to star
     * @type {string}
     * @memberof UserApiUserCurrentPutStar
     */
    readonly owner: string

    /**
     * name of the repo to star
     * @type {string}
     * @memberof UserApiUserCurrentPutStar
     */
    readonly repo: string
}

/**
 * Request parameters for userCurrentTrackedTimes operation in UserApi.
 * @export
 * @interface UserApiUserCurrentTrackedTimesRequest
 */
export interface UserApiUserCurrentTrackedTimesRequest {
    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof UserApiUserCurrentTrackedTimes
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof UserApiUserCurrentTrackedTimes
     */
    readonly limit?: number

    /**
     * Only show times updated after the given time. This is a timestamp in RFC 3339 format
     * @type {string}
     * @memberof UserApiUserCurrentTrackedTimes
     */
    readonly since?: string

    /**
     * Only show times updated before the given time. This is a timestamp in RFC 3339 format
     * @type {string}
     * @memberof UserApiUserCurrentTrackedTimes
     */
    readonly before?: string
}

/**
 * Request parameters for userDeleteAccessToken operation in UserApi.
 * @export
 * @interface UserApiUserDeleteAccessTokenRequest
 */
export interface UserApiUserDeleteAccessTokenRequest {
    /**
     * username of user
     * @type {string}
     * @memberof UserApiUserDeleteAccessToken
     */
    readonly username: string

    /**
     * token to be deleted, identified by ID and if not available by name
     * @type {string}
     * @memberof UserApiUserDeleteAccessToken
     */
    readonly token: string
}

/**
 * Request parameters for userDeleteEmail operation in UserApi.
 * @export
 * @interface UserApiUserDeleteEmailRequest
 */
export interface UserApiUserDeleteEmailRequest {
    /**
     * 
     * @type {DeleteEmailOption}
     * @memberof UserApiUserDeleteEmail
     */
    readonly body?: DeleteEmailOption
}

/**
 * Request parameters for userDeleteOAuth2Application operation in UserApi.
 * @export
 * @interface UserApiUserDeleteOAuth2ApplicationRequest
 */
export interface UserApiUserDeleteOAuth2ApplicationRequest {
    /**
     * token to be deleted
     * @type {number}
     * @memberof UserApiUserDeleteOAuth2Application
     */
    readonly id: number
}

/**
 * Request parameters for userGet operation in UserApi.
 * @export
 * @interface UserApiUserGetRequest
 */
export interface UserApiUserGetRequest {
    /**
     * username of user to get
     * @type {string}
     * @memberof UserApiUserGet
     */
    readonly username: string
}

/**
 * Request parameters for userGetHeatmapData operation in UserApi.
 * @export
 * @interface UserApiUserGetHeatmapDataRequest
 */
export interface UserApiUserGetHeatmapDataRequest {
    /**
     * username of user to get
     * @type {string}
     * @memberof UserApiUserGetHeatmapData
     */
    readonly username: string
}

/**
 * Request parameters for userGetOAuth2Application operation in UserApi.
 * @export
 * @interface UserApiUserGetOAuth2ApplicationRequest
 */
export interface UserApiUserGetOAuth2ApplicationRequest {
    /**
     * Application ID to be found
     * @type {number}
     * @memberof UserApiUserGetOAuth2Application
     */
    readonly id: number
}

/**
 * Request parameters for userGetOauth2Application operation in UserApi.
 * @export
 * @interface UserApiUserGetOauth2ApplicationRequest
 */
export interface UserApiUserGetOauth2ApplicationRequest {
    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof UserApiUserGetOauth2Application
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof UserApiUserGetOauth2Application
     */
    readonly limit?: number
}

/**
 * Request parameters for userGetStopWatches operation in UserApi.
 * @export
 * @interface UserApiUserGetStopWatchesRequest
 */
export interface UserApiUserGetStopWatchesRequest {
    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof UserApiUserGetStopWatches
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof UserApiUserGetStopWatches
     */
    readonly limit?: number
}

/**
 * Request parameters for userGetTokens operation in UserApi.
 * @export
 * @interface UserApiUserGetTokensRequest
 */
export interface UserApiUserGetTokensRequest {
    /**
     * username of user
     * @type {string}
     * @memberof UserApiUserGetTokens
     */
    readonly username: string

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof UserApiUserGetTokens
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof UserApiUserGetTokens
     */
    readonly limit?: number
}

/**
 * Request parameters for userListFollowers operation in UserApi.
 * @export
 * @interface UserApiUserListFollowersRequest
 */
export interface UserApiUserListFollowersRequest {
    /**
     * username of user
     * @type {string}
     * @memberof UserApiUserListFollowers
     */
    readonly username: string

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof UserApiUserListFollowers
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof UserApiUserListFollowers
     */
    readonly limit?: number
}

/**
 * Request parameters for userListFollowing operation in UserApi.
 * @export
 * @interface UserApiUserListFollowingRequest
 */
export interface UserApiUserListFollowingRequest {
    /**
     * username of user
     * @type {string}
     * @memberof UserApiUserListFollowing
     */
    readonly username: string

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof UserApiUserListFollowing
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof UserApiUserListFollowing
     */
    readonly limit?: number
}

/**
 * Request parameters for userListGPGKeys operation in UserApi.
 * @export
 * @interface UserApiUserListGPGKeysRequest
 */
export interface UserApiUserListGPGKeysRequest {
    /**
     * username of user
     * @type {string}
     * @memberof UserApiUserListGPGKeys
     */
    readonly username: string

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof UserApiUserListGPGKeys
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof UserApiUserListGPGKeys
     */
    readonly limit?: number
}

/**
 * Request parameters for userListKeys operation in UserApi.
 * @export
 * @interface UserApiUserListKeysRequest
 */
export interface UserApiUserListKeysRequest {
    /**
     * username of user
     * @type {string}
     * @memberof UserApiUserListKeys
     */
    readonly username: string

    /**
     * fingerprint of the key
     * @type {string}
     * @memberof UserApiUserListKeys
     */
    readonly fingerprint?: string

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof UserApiUserListKeys
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof UserApiUserListKeys
     */
    readonly limit?: number
}

/**
 * Request parameters for userListRepos operation in UserApi.
 * @export
 * @interface UserApiUserListReposRequest
 */
export interface UserApiUserListReposRequest {
    /**
     * username of user
     * @type {string}
     * @memberof UserApiUserListRepos
     */
    readonly username: string

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof UserApiUserListRepos
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof UserApiUserListRepos
     */
    readonly limit?: number
}

/**
 * Request parameters for userListStarred operation in UserApi.
 * @export
 * @interface UserApiUserListStarredRequest
 */
export interface UserApiUserListStarredRequest {
    /**
     * username of user
     * @type {string}
     * @memberof UserApiUserListStarred
     */
    readonly username: string

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof UserApiUserListStarred
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof UserApiUserListStarred
     */
    readonly limit?: number
}

/**
 * Request parameters for userListSubscriptions operation in UserApi.
 * @export
 * @interface UserApiUserListSubscriptionsRequest
 */
export interface UserApiUserListSubscriptionsRequest {
    /**
     * username of the user
     * @type {string}
     * @memberof UserApiUserListSubscriptions
     */
    readonly username: string

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof UserApiUserListSubscriptions
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof UserApiUserListSubscriptions
     */
    readonly limit?: number
}

/**
 * Request parameters for userListTeams operation in UserApi.
 * @export
 * @interface UserApiUserListTeamsRequest
 */
export interface UserApiUserListTeamsRequest {
    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof UserApiUserListTeams
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof UserApiUserListTeams
     */
    readonly limit?: number
}

/**
 * Request parameters for userSearch operation in UserApi.
 * @export
 * @interface UserApiUserSearchRequest
 */
export interface UserApiUserSearchRequest {
    /**
     * keyword
     * @type {string}
     * @memberof UserApiUserSearch
     */
    readonly q?: string

    /**
     * ID of the user to search for
     * @type {number}
     * @memberof UserApiUserSearch
     */
    readonly uid?: number

    /**
     * If the user has one or more repos with the given language(s), the org will be in the results. Multiple lang\&#39;s are ORed.
     * @type {string}
     * @memberof UserApiUserSearch
     */
    readonly lang?: string

    /**
     * page number of results to return (1-based)
     * @type {number}
     * @memberof UserApiUserSearch
     */
    readonly page?: number

    /**
     * page size of results
     * @type {number}
     * @memberof UserApiUserSearch
     */
    readonly limit?: number
}

/**
 * Request parameters for userUpdateOAuth2Application operation in UserApi.
 * @export
 * @interface UserApiUserUpdateOAuth2ApplicationRequest
 */
export interface UserApiUserUpdateOAuth2ApplicationRequest {
    /**
     * application to be updated
     * @type {number}
     * @memberof UserApiUserUpdateOAuth2Application
     */
    readonly id: number

    /**
     * 
     * @type {CreateOAuth2ApplicationOptions}
     * @memberof UserApiUserUpdateOAuth2Application
     */
    readonly body: CreateOAuth2ApplicationOptions
}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary Create a repository
     * @param {UserApiCreateCurrentUserRepoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createCurrentUserRepo(requestParameters: UserApiCreateCurrentUserRepoRequest = {}, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).createCurrentUserRepo(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserSettings(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Token to verify
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getVerificationToken(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getVerificationToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user settings
     * @param {UserApiUpdateUserSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUserSettings(requestParameters: UserApiUpdateUserSettingsRequest = {}, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).updateUserSettings(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add email addresses
     * @param {UserApiUserAddEmailRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userAddEmail(requestParameters: UserApiUserAddEmailRequest = {}, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userAddEmail(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if one user is following another user
     * @param {UserApiUserCheckFollowingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCheckFollowing(requestParameters: UserApiUserCheckFollowingRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCheckFollowing(requestParameters.username, requestParameters.target, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary creates a new OAuth2 application
     * @param {UserApiUserCreateOAuth2ApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCreateOAuth2Application(requestParameters: UserApiUserCreateOAuth2ApplicationRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCreateOAuth2Application(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an access token
     * @param {UserApiUserCreateTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCreateToken(requestParameters: UserApiUserCreateTokenRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCreateToken(requestParameters.username, requestParameters.userCreateToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check whether a user is followed by the authenticated user
     * @param {UserApiUserCurrentCheckFollowingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentCheckFollowing(requestParameters: UserApiUserCurrentCheckFollowingRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentCheckFollowing(requestParameters.username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Whether the authenticated is starring the repo
     * @param {UserApiUserCurrentCheckStarringRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentCheckStarring(requestParameters: UserApiUserCurrentCheckStarringRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentCheckStarring(requestParameters.owner, requestParameters.repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unfollow a user
     * @param {UserApiUserCurrentDeleteFollowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentDeleteFollow(requestParameters: UserApiUserCurrentDeleteFollowRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentDeleteFollow(requestParameters.username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a GPG key
     * @param {UserApiUserCurrentDeleteGPGKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentDeleteGPGKey(requestParameters: UserApiUserCurrentDeleteGPGKeyRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentDeleteGPGKey(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a public key
     * @param {UserApiUserCurrentDeleteKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentDeleteKey(requestParameters: UserApiUserCurrentDeleteKeyRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentDeleteKey(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unstar the given repo
     * @param {UserApiUserCurrentDeleteStarRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentDeleteStar(requestParameters: UserApiUserCurrentDeleteStarRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentDeleteStar(requestParameters.owner, requestParameters.repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a GPG key
     * @param {UserApiUserCurrentGetGPGKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentGetGPGKey(requestParameters: UserApiUserCurrentGetGPGKeyRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentGetGPGKey(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a public key
     * @param {UserApiUserCurrentGetKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentGetKey(requestParameters: UserApiUserCurrentGetKeyRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentGetKey(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the authenticated user\'s followers
     * @param {UserApiUserCurrentListFollowersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentListFollowers(requestParameters: UserApiUserCurrentListFollowersRequest = {}, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentListFollowers(requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the users that the authenticated user is following
     * @param {UserApiUserCurrentListFollowingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentListFollowing(requestParameters: UserApiUserCurrentListFollowingRequest = {}, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentListFollowing(requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the authenticated user\'s GPG keys
     * @param {UserApiUserCurrentListGPGKeysRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentListGPGKeys(requestParameters: UserApiUserCurrentListGPGKeysRequest = {}, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentListGPGKeys(requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the authenticated user\'s public keys
     * @param {UserApiUserCurrentListKeysRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentListKeys(requestParameters: UserApiUserCurrentListKeysRequest = {}, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentListKeys(requestParameters.fingerprint, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the repos that the authenticated user owns
     * @param {UserApiUserCurrentListReposRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentListRepos(requestParameters: UserApiUserCurrentListReposRequest = {}, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentListRepos(requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary The repos that the authenticated user has starred
     * @param {UserApiUserCurrentListStarredRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentListStarred(requestParameters: UserApiUserCurrentListStarredRequest = {}, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentListStarred(requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List repositories watched by the authenticated user
     * @param {UserApiUserCurrentListSubscriptionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentListSubscriptions(requestParameters: UserApiUserCurrentListSubscriptionsRequest = {}, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentListSubscriptions(requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a GPG key
     * @param {UserApiUserCurrentPostGPGKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentPostGPGKey(requestParameters: UserApiUserCurrentPostGPGKeyRequest = {}, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentPostGPGKey(requestParameters.form, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a public key
     * @param {UserApiUserCurrentPostKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentPostKey(requestParameters: UserApiUserCurrentPostKeyRequest = {}, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentPostKey(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Follow a user
     * @param {UserApiUserCurrentPutFollowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentPutFollow(requestParameters: UserApiUserCurrentPutFollowRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentPutFollow(requestParameters.username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Star the given repo
     * @param {UserApiUserCurrentPutStarRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentPutStar(requestParameters: UserApiUserCurrentPutStarRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentPutStar(requestParameters.owner, requestParameters.repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the current user\'s tracked times
     * @param {UserApiUserCurrentTrackedTimesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentTrackedTimes(requestParameters: UserApiUserCurrentTrackedTimesRequest = {}, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentTrackedTimes(requestParameters.page, requestParameters.limit, requestParameters.since, requestParameters.before, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary delete an access token
     * @param {UserApiUserDeleteAccessTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userDeleteAccessToken(requestParameters: UserApiUserDeleteAccessTokenRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userDeleteAccessToken(requestParameters.username, requestParameters.token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete email addresses
     * @param {UserApiUserDeleteEmailRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userDeleteEmail(requestParameters: UserApiUserDeleteEmailRequest = {}, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userDeleteEmail(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary delete an OAuth2 Application
     * @param {UserApiUserDeleteOAuth2ApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userDeleteOAuth2Application(requestParameters: UserApiUserDeleteOAuth2ApplicationRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userDeleteOAuth2Application(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user
     * @param {UserApiUserGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userGet(requestParameters: UserApiUserGetRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userGet(requestParameters.username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userGetCurrent(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userGetCurrent(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user\'s heatmap
     * @param {UserApiUserGetHeatmapDataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userGetHeatmapData(requestParameters: UserApiUserGetHeatmapDataRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userGetHeatmapData(requestParameters.username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get an OAuth2 Application
     * @param {UserApiUserGetOAuth2ApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userGetOAuth2Application(requestParameters: UserApiUserGetOAuth2ApplicationRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userGetOAuth2Application(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the authenticated user\'s oauth2 applications
     * @param {UserApiUserGetOauth2ApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userGetOauth2Application(requestParameters: UserApiUserGetOauth2ApplicationRequest = {}, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userGetOauth2Application(requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get list of all existing stopwatches
     * @param {UserApiUserGetStopWatchesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userGetStopWatches(requestParameters: UserApiUserGetStopWatchesRequest = {}, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userGetStopWatches(requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the authenticated user\'s access tokens
     * @param {UserApiUserGetTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userGetTokens(requestParameters: UserApiUserGetTokensRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userGetTokens(requestParameters.username, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the authenticated user\'s email addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userListEmails(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userListEmails(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the given user\'s followers
     * @param {UserApiUserListFollowersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userListFollowers(requestParameters: UserApiUserListFollowersRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userListFollowers(requestParameters.username, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the users that the given user is following
     * @param {UserApiUserListFollowingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userListFollowing(requestParameters: UserApiUserListFollowingRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userListFollowing(requestParameters.username, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the given user\'s GPG keys
     * @param {UserApiUserListGPGKeysRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userListGPGKeys(requestParameters: UserApiUserListGPGKeysRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userListGPGKeys(requestParameters.username, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the given user\'s public keys
     * @param {UserApiUserListKeysRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userListKeys(requestParameters: UserApiUserListKeysRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userListKeys(requestParameters.username, requestParameters.fingerprint, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the repos owned by the given user
     * @param {UserApiUserListReposRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userListRepos(requestParameters: UserApiUserListReposRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userListRepos(requestParameters.username, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary The repos that the given user has starred
     * @param {UserApiUserListStarredRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userListStarred(requestParameters: UserApiUserListStarredRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userListStarred(requestParameters.username, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the repositories watched by a user
     * @param {UserApiUserListSubscriptionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userListSubscriptions(requestParameters: UserApiUserListSubscriptionsRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userListSubscriptions(requestParameters.username, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all the teams a user belongs to
     * @param {UserApiUserListTeamsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userListTeams(requestParameters: UserApiUserListTeamsRequest = {}, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userListTeams(requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for users
     * @param {UserApiUserSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userSearch(requestParameters: UserApiUserSearchRequest = {}, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userSearch(requestParameters.q, requestParameters.uid, requestParameters.lang, requestParameters.page, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary update an OAuth2 Application, this includes regenerating the client secret
     * @param {UserApiUserUpdateOAuth2ApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userUpdateOAuth2Application(requestParameters: UserApiUserUpdateOAuth2ApplicationRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userUpdateOAuth2Application(requestParameters.id, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Verify a GPG key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userVerifyGPGKey(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userVerifyGPGKey(options).then((request) => request(this.axios, this.basePath));
    }
}
